# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

directive @extends on INTERFACE | OBJECT

directive @external on FIELD_DEFINITION | OBJECT

directive @inaccessible on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION

directive @key(fields: String!, resolvable: Boolean = true) repeatable on INTERFACE | OBJECT

directive @link(import: [link__Import], url: String!) on SCHEMA

directive @override(from: String!) on FIELD_DEFINITION

directive @provides(fields: String!) on FIELD_DEFINITION

directive @requires(fields: String!) on FIELD_DEFINITION

directive @shareable on FIELD_DEFINITION | OBJECT

directive @tag(name: String!) repeatable on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION

union Action = ArticleCreatedAction | AuthorCreatedAction | CommentCreatedAction | EventCreatedAction | PageCreatedAction | PollStartedAction | SubscriptionCreatedAction | UserCreatedAction

enum ActionType {
  ArticleCreated
  AuthorCreated
  CommentCreated
  EventCreated
  PageCreated
  PollStarted
  SubscriptionCreated
  UserCreated
}

type AllowedSettingVals {
  boolChoice: Boolean
  stringChoice: [String!]
}

type Article implements HasOptionalPaywall & HasOptionalPeerLc {
  createdAt: DateTime!
  disableComments: Boolean!
  draft: ArticleRevision
  hidden: Boolean!
  id: String!
  latest: ArticleRevision!
  likes: Int!
  modifiedAt: DateTime!
  paywall: Paywall
  paywallId: String
  peer: Peer
  peerArticleId: String
  peerId: String
  pending: ArticleRevision
  previewUrl: String!
  published: ArticleRevision
  publishedAt: DateTime
  shared: Boolean!
  slug: String
  tags: [Tag!]!
  trackingPixels: [TrackingPixel!]!
  url: String!
}

type ArticleCreatedAction implements BaseAction & HasArticleLc {
  actionType: ActionType!
  article: Article!
  articleId: String!
  date: DateTime!
}

input ArticleFilter {
  authors: [String!]
  body: String
  draft: Boolean
  excludeIds: [String!]
  ids: [String!]
  includeHidden: Boolean
  lead: String
  peerId: String
  pending: Boolean
  preTitle: String
  publicationDateFrom: DateFilter
  publicationDateTo: DateFilter
  published: Boolean
  shared: Boolean
  tags: [String!]
  title: String
}

type ArticleNavigationLink implements BaseNavigationLink & HasArticle {
  article: Article!
  articleID: String!
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  type: NavigationLinkType!
}

type ArticleRevision implements HasBlockContent {
  authors: [Author!]!
  blocks: [BlockContent!]!
  breaking: Boolean!
  canonicalUrl: String
  createdAt: DateTime!
  hideAuthor: Boolean!
  id: String!
  image: Image
  imageID: String
  lead: String
  preTitle: String
  properties: [Property!]!
  publishedAt: DateTime
  seoTitle: String
  socialMediaAuthors: [Author!]!
  socialMediaDescription: String
  socialMediaImage: Image
  socialMediaImageID: String
  socialMediaTitle: String
  title: String
}

enum ArticleSort {
  CreatedAt
  ModifiedAt
  PublishedAt
}

type ArticleTeaser implements BaseTeaser & HasImage & HasOptionalArticle {
  article: Article
  articleID: String
  image: Image
  imageID: String
  lead: String
  preTitle: String
  title: String
  type: String!
}

input ArticleTeaserInput {
  articleID: String
  imageID: String
  lead: String
  preTitle: String
  title: String
}

type Author {
  id: String!
}

type AuthorCreatedAction implements BaseAction & HasAuthor {
  actionType: ActionType!
  author: Author!
  authorId: String!
  date: DateTime!
}

type AvailablePaymentMethod {
  forceAutoRenewal: Boolean!
  paymentMethods: [PaymentMethod!]!
  paymentPeriodicities: [PaymentPeriodicity!]!
}

type Banner {
  actions: [BannerAction!]
  active: Boolean!
  cta: String
  delay: Int!
  html: String
  id: String!
  image: Image
  imageId: String
  showForLoginStatus: LoginStatus!
  showOnArticles: Boolean!
  showOnPages: [PageModel!]
  text: String!
  title: String!
}

type BannerAction {
  id: String!
  label: String!
  role: BannerActionRole!
  style: String!
  url: String!
}

enum BannerActionRole {
  CANCEL
  OTHER
  PRIMARY
}

enum BannerDocumentType {
  ARTICLE
  PAGE
}

interface BaseAction {
  actionType: ActionType!
  date: DateTime!
}

interface BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
}

interface BaseNavigationLink {
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  type: NavigationLinkType!
}

interface BaseTeaser implements HasImage {
  image: Image
  imageID: String
  lead: String
  preTitle: String
  title: String
  type: String!
}

type BildwurfAdBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  zoneID: String
}

input BildwurfAdBlockInput {
  blockStyle: String
  blockStyleName: String
  zoneID: String
}

union BlockContent = BildwurfAdBlock | BreakBlock | CommentBlock | CrowdfundingBlock | EventBlock | FacebookPostBlock | FacebookVideoBlock | HTMLBlock | IFrameBlock | ImageBlock | ImageGalleryBlock | InstagramPostBlock | ListicleBlock | PolisConversationBlock | PollBlock | QuoteBlock | RichTextBlock | SoundCloudTrackBlock | SubscribeBlock | TeaserGridBlock | TeaserGridFlexBlock | TeaserListBlock | TeaserSlotsBlock | TikTokVideoBlock | TitleBlock | TwitterTweetBlock | UnknownBlock | VimeoVideoBlock | YouTubeVideoBlock

input BlockContentInput {
  bildwurfAd: BildwurfAdBlockInput
  comment: CommentBlockInput
  crowdfunding: CrowdfundingBlockInput
  embed: IFrameBlockInput
  event: EventBlockInput
  facebookPost: FacebookPostBlockInput
  facebookVideo: FacebookVideoBlockInput
  html: HTMLBlockInput
  image: ImageBlockInput
  imageGallery: ImageGalleryBlockInput
  instagramPost: InstagramPostBlockInput
  linkPageBreak: BreakBlockInput
  listicle: ListicleBlockInput
  polisConversation: PolisConversationBlockInput
  poll: PollBlockInput
  quote: QuoteBlockInput
  richText: RichTextBlockInput
  soundCloudTrack: SoundCloudTrackBlockInput
  subscribe: SubscribeBlockInput
  teaserGrid: TeaserGridBlockInput
  teaserGridFlex: TeaserGridFlexBlockInput
  teaserList: TeaserListBlockInput
  teaserSlots: TeaserSlotsBlockInput
  tikTokVideo: TikTokVideoBlockInput
  title: TitleBlockInput
  twitterTweet: TwitterTweetBlockInput
  vimeoVideo: VimeoVideoBlockInput
  youTubeVideo: YouTubeVideoBlockInput
}

type BlockStyle {
  blocks: [EditorBlockType!]!
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String!
}

enum BlockType {
  BildwurfAd
  Comment
  Crowdfunding
  Embed
  Event
  FacebookPost
  FacebookVideo
  HTML
  Image
  ImageGallery
  InstagramPost
  LinkPageBreak
  Listicle
  PolisConversation
  Poll
  Quote
  RichText
  SoundCloudTrack
  Subscribe
  TeaserGrid
  TeaserGridFlex
  TeaserList
  TeaserSlots
  TikTokVideo
  Title
  TwitterTweet
  VimeoVideo
  YouTubeVideo
}

type BreakBlock implements BaseBlock & HasImage {
  blockStyle: String
  blockStyleName: String
  hideButton: Boolean
  image: Image
  imageID: String
  linkTarget: String
  linkText: String
  linkURL: String
  richText: RichText!
  text: String
  type: BlockType!
}

input BreakBlockInput {
  blockStyle: String
  blockStyleName: String
  hideButton: Boolean
  imageID: String
  linkTarget: String
  linkText: String
  linkURL: String
  richText: RichText!
  text: String
}

type Comment {
  id: String!
}

type CommentBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  comments: [Comment!]!
  filter: CommentBlockFilter!
  type: BlockType!
}

type CommentBlockFilter {
  comments: [String!]
  item: String
  tags: [String!]
}

input CommentBlockFilterInput {
  comments: [String!] = []
  item: String
  tags: [String!] = []
}

input CommentBlockInput {
  blockStyle: String
  blockStyleName: String
  filter: CommentBlockFilterInput!
}

type CommentCreatedAction implements BaseAction & HasComment {
  actionType: ActionType!
  comment: Comment!
  commentId: String!
  date: DateTime!
}

type Consent {
  createdAt: DateTime!
  defaultValue: Boolean!
  id: String!
  modifiedAt: DateTime!
  name: String!
  slug: String!
}

input ConsentFilter {
  defaultValue: Boolean
  name: String
  slug: String
}

input CreateBannerActionInput {
  label: String!
  role: BannerActionRole!
  style: String!
  url: String!
}

input CreateBannerInput {
  actions: [CreateBannerActionInput!]
  active: Boolean!
  cta: String
  delay: Int!
  html: String
  imageId: String
  showForLoginStatus: LoginStatus!
  showOnArticles: Boolean!
  showOnPages: [PageModelInput!]
  text: String!
  title: String!
}

input CreateCrowdfundingGoalInput {
  amount: Float!
  description: String
  title: String!
}

input CreateCrowdfundingInput {
  additionalRevenue: Float
  countSubscriptionsFrom: DateTime
  countSubscriptionsUntil: DateTime
  goals: [CreateCrowdfundingGoalInput!]
  memberPlans: [CreateCrowdfundingMemberPlan!]
  name: String!
}

input CreateCrowdfundingMemberPlan {
  id: String!
}

type Crowdfunding {
  additionalRevenue: Float
  countSubscriptionsFrom: DateTime
  countSubscriptionsUntil: DateTime
  createdAt: DateTime!
  goals: [CrowdfundingGoal!]!
  id: String!
  memberPlans: [CrowdfundingMemberPlan!]!
  modifiedAt: DateTime!
  name: String!
  revenue: Float
}

type CrowdfundingBlock implements BaseBlock & HasOptionalCrowdfunding {
  blockStyle: String
  blockStyleName: String
  crowdfunding: CrowdfundingWithActiveGoal
  crowdfundingId: String
  type: BlockType!
}

input CrowdfundingBlockInput {
  blockStyle: String
  blockStyleName: String
  crowdfundingId: String
}

type CrowdfundingGoal {
  amount: Float!
  createdAt: DateTime!
  description: String
  id: ID!
  modifiedAt: DateTime!
  title: String!
}

type CrowdfundingGoalWithProgress {
  amount: Float!
  createdAt: DateTime!
  description: String
  id: ID!
  modifiedAt: DateTime!
  progress: Float
  title: String!
}

type CrowdfundingMemberPlan {
  id: String!
  name: String!
}

type CrowdfundingWithActiveGoal {
  activeCrowdfundingGoal: CrowdfundingGoalWithProgress
  additionalRevenue: Float
  countSubscriptionsFrom: DateTime
  countSubscriptionsUntil: DateTime
  createdAt: DateTime!
  goals: [CrowdfundingGoal!]!
  id: String!
  memberPlans: [CrowdfundingMemberPlan!]!
  modifiedAt: DateTime!
  name: String!
  revenue: Float
}

enum Currency {
  CHF
  EUR
}

type CustomTeaser implements BaseTeaser & HasImage {
  contentUrl: String
  image: Image
  imageID: String
  lead: String
  preTitle: String
  properties: [NonDbProperty!]
  title: String
  type: String!
}

input CustomTeaserInput {
  contentUrl: String
  imageID: String
  lead: String
  preTitle: String
  properties: [PropertyInput!] = []
  title: String
}

type DailySubscriptionStats {
  createdSubscriptionCount: Float!
  createdSubscriptionUsers: [DailySubscriptionStatsUser!]!
  createdUnpaidSubscriptionCount: Float!
  createdUnpaidSubscriptionUsers: [DailySubscriptionStatsUser!]!
  date: String!
  deactivatedSubscriptionCount: Float!
  deactivatedSubscriptionUsers: [DailySubscriptionStatsUser!]!
  renewedSubscriptionCount: Float!
  renewedSubscriptionUsers: [DailySubscriptionStatsUser!]!
  replacedSubscriptionCount: Float!
  replacedSubscriptionUsers: [DailySubscriptionStatsUser!]!
  subscriptionDailyRevenue: Float!
  subscriptionDurationAvg: Float!
  subscriptionMonthlyRevenueAvg: Float!
  subscriptionMonthlyRevenueSum: Float!
  totalActiveSubscriptionCount: Float!
}

type DailySubscriptionStatsUser {
  email: String!
  firstName: String
  id: String!
  name: String!
}

type DashboardInvoice {
  amount: Int!
  dueAt: DateTime!
  memberPlan: String
  paidAt: DateTime
}

type DashboardSubscription {
  deactivationDate: DateTime
  endsAt: DateTime
  memberPlan: String!
  monthlyAmount: Int!
  paymentPeriodicity: PaymentPeriodicity!
  reasonForDeactivation: SubscriptionDeactivationReason
  renewsAt: DateTime
  startsAt: DateTime!
}

input DateFilter {
  comparison: DateFilterComparison!
  date: DateTime
}

enum DateFilterComparison {
  Equal
  GreaterThan
  GreaterThanOrEqual
  LowerThan
  LowerThanOrEqual
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type DeletePollVotesResult {
  count: Int!
}

enum EditorBlockType {
  Comment
  Crowdfunding
  Embed
  Event
  HTML
  Image
  ImageGallery
  LinkPageBreak
  Listicle
  Poll
  Quote
  RichText
  Subscribe
  TeaserGrid1
  TeaserGrid6
  TeaserGridFlex
  TeaserList
  TeaserSlots
  Title
}

type Event {
  createdAt: DateTime!
  description: RichText
  endsAt: DateTime
  externalSourceId: String
  externalSourceName: String
  id: String!
  image: Image
  imageId: String
  lead: String
  location: String
  modifiedAt: DateTime!
  name: String!
  startsAt: DateTime!
  status: EventStatus!
  tags: [Tag!]
  url: String!
}

type EventBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  events: [Event!]!
  filter: EventBlockFilter!
  type: BlockType!
}

type EventBlockFilter {
  events: [String!]
  tags: [String!]
}

input EventBlockFilterInput {
  events: [String!] = []
  tags: [String!] = []
}

input EventBlockInput {
  blockStyle: String
  blockStyleName: String
  filter: EventBlockFilterInput!
}

type EventCreatedAction implements BaseAction & HasEventLc {
  actionType: ActionType!
  date: DateTime!
  event: Event!
  eventId: String!
}

input EventFilter {
  from: DateTime
  location: String
  name: String
  tags: [String!]
  to: DateTime
  upcomingOnly: Boolean
}

type EventFromSource {
  createdAt: DateTime!
  description: RichText
  endsAt: DateTime
  externalSourceId: String
  externalSourceName: String
  id: String!
  imageUrl: String
  lead: String
  location: String
  modifiedAt: DateTime!
  name: String!
  startsAt: DateTime!
  status: EventStatus!
}

enum EventSort {
  CreatedAt
  EndsAt
  ModifiedAt
  StartsAt
}

enum EventStatus {
  Cancelled
  Postponed
  Rescheduled
  Scheduled
}

type EventTeaser implements BaseTeaser & HasImage & HasOptionalEvent {
  event: Event
  eventID: String
  image: Image
  imageID: String
  lead: String
  preTitle: String
  title: String
  type: String!
}

input EventTeaserInput {
  eventID: String
  imageID: String
  lead: String
  preTitle: String
  title: String
}

type ExternalNavigationLink implements BaseNavigationLink {
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  type: NavigationLinkType!
  url: String
}

type FacebookPostBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  postID: String
  type: BlockType!
  userID: String
}

input FacebookPostBlockInput {
  blockStyle: String
  blockStyleName: String
  postID: String
  userID: String
}

type FacebookVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  userID: String
  videoID: String
}

input FacebookVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  userID: String
  videoID: String
}

type FlexAlignment {
  h: Int!
  i: String!
  static: Boolean!
  w: Int!
  x: Int!
  y: Int!
}

input FlexAlignmentInput {
  h: Int!
  i: String!
  static: Boolean!
  w: Int!
  x: Int!
  y: Int!
}

type FlexTeaser {
  alignment: FlexAlignment!
  teaser: Teaser
}

input FlexTeaserInput {
  alignment: FlexAlignmentInput!
  teaser: TeaserInput
}

type FocalPoint {
  x: Float!
  y: Float!
}

type FullPoll {
  id: String!
}

"""Setting Value"""
scalar GraphQLSettingValueType

type HTMLBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  html: String
  type: BlockType!
}

input HTMLBlockInput {
  blockStyle: String
  blockStyleName: String
  html: String
}

interface HasArticle {
  article: Article!
  articleID: String!
}

interface HasArticleLc {
  article: Article!
  articleId: String!
}

interface HasAuthor {
  author: Author!
  authorId: String!
}

interface HasBlockContent {
  blocks: [BlockContent!]!
}

interface HasComment {
  comment: Comment!
  commentId: String!
}

interface HasEventLc {
  event: Event!
  eventId: String!
}

interface HasImage {
  image: Image
  imageID: String
}

interface HasOptionalArticle {
  article: Article
  articleID: String
}

interface HasOptionalCrowdfunding {
  crowdfunding: CrowdfundingWithActiveGoal
  crowdfundingId: String
}

interface HasOptionalEvent {
  event: Event
  eventID: String
}

interface HasOptionalPage {
  page: Page
  pageID: String
}

interface HasOptionalPaywall {
  paywall: Paywall
  paywallId: String
}

interface HasOptionalPeerLc {
  peer: Peer
  peerId: String
}

interface HasOptionalPoll {
  poll: FullPoll
  pollId: String
}

interface HasPage {
  page: Page!
  pageID: String!
}

interface HasPageLc {
  page: Page!
  pageId: String!
}

interface HasPoll {
  poll: FullPoll!
  pollId: String!
}

interface HasSubscription {
  subscription: PublicSubscription!
  subscriptionId: String!
}

interface HasUserLc {
  user: User!
  userId: String!
}

type IFrameBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  height: Int
  sandbox: String
  styleCustom: String
  title: String
  type: BlockType!
  url: String
  width: Int
}

input IFrameBlockInput {
  blockStyle: String
  blockStyleName: String
  height: Int
  sandbox: String
  styleCustom: String
  title: String
  url: String
  width: Int
}

type Image {
  id: String!
}

type ImageBlock implements BaseBlock & HasImage {
  blockStyle: String
  blockStyleName: String
  caption: String
  image: Image
  imageID: String
  linkUrl: String
  type: BlockType!
}

input ImageBlockInput {
  blockStyle: String
  blockStyleName: String
  caption: String
  imageID: String
  linkUrl: String
}

type ImageGalleryBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  images: [ImageGalleryImage!]!
  type: BlockType!
}

input ImageGalleryBlockInput {
  blockStyle: String
  blockStyleName: String
  images: [ImageGalleryImageInput!]!
}

type ImageGalleryImage implements HasImage {
  caption: String
  image: Image
  imageID: String
}

input ImageGalleryImageInput {
  caption: String
  imageID: String
}

type ImageV2 {
  createdAt: DateTime!
  description: RichText
  extension: String!
  fileSize: Int!
  filename: String
  focalPoint: FocalPoint
  format: String!
  height: Int!
  id: String!
  license: String
  link: String
  mimeType: String!
  modifiedAt: DateTime!
  source: String
  tags: [String!]!
  title: String
  width: Int!
}

input ImportArticleOptions {
  importAuthors: Boolean
  importContentImages: Boolean
  importTags: Boolean
}

input ImportedEventFilter {
  from: String
  location: String
  name: String
  providers: [String]
  to: String
}

enum ImportedEventSort {
  CREATED_AT
  ENDS_AT
  MODIFIED_AT
  STARTS_AT
}

type ImportedEventsDocument {
  nodes: [EventFromSource!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type InstagramPostBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  postID: String
  type: BlockType!
}

input InstagramPostBlockInput {
  blockStyle: String
  blockStyleName: String
  postID: String
}

type ListicleBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  items: [ListicleItem!]!
  type: BlockType!
}

input ListicleBlockInput {
  blockStyle: String
  blockStyleName: String
  items: [ListicleItemInput!]!
}

type ListicleItem implements HasImage {
  image: Image
  imageID: String
  richText: RichText!
  title: String
}

input ListicleItemInput {
  imageID: String
  richText: RichText!
  title: String
}

enum LoginStatus {
  ALL
  LOGGED_IN
  LOGGED_OUT
  SUBSCRIBED
  UNSUBSCRIBED
}

type MailProviderModel {
  name: String!
}

type MailTemplateRef {
  id: String!
  name: String!
}

type MailTemplateWithUrlAndStatusModel {
  description: String
  externalMailTemplateId: String!
  id: String!
  name: String!
  remoteMissing: Boolean!
  status: String!
  url: String!
}

type MemberPlan {
  amountPerMonthMin: Int!
  amountPerMonthTarget: Int
  availablePaymentMethods: [AvailablePaymentMethod!]!
  confirmationPageId: String
  currency: Currency!
  description: RichText
  extendable: Boolean!
  failPageId: String
  id: String!
  image: Image
  maxCount: Int
  name: String!
  slug: String!
  successPageId: String
  tags: [String!]
}

type Mutation {
  """Creates an article."""
  createArticle(authorIds: [String!]!, blocks: [BlockContentInput!]!, breaking: Boolean!, canonicalUrl: String, disableComments: Boolean!, hidden: Boolean!, hideAuthor: Boolean!, imageID: String, lead: String, likes: Int, paywallId: String, preTitle: String, properties: [PropertyInput!]!, seoTitle: String, shared: Boolean!, slug: String, socialMediaAuthorIds: [String!]!, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Article!
  createBanner(input: CreateBannerInput!): Banner!

  """Creates a new block style."""
  createBlockStyle(blocks: [EditorBlockType!]!, name: String!): BlockStyle!

  "\n      Create a new consent.\n    "
  createConsent(defaultValue: Boolean!, name: String!, slug: String!): Consent!

  """Create a new Crowdfunding"""
  createCrowdfunding(input: CreateCrowdfundingInput!): Crowdfunding!

  """Creates a new event."""
  createEvent(description: RichText, endsAt: DateTime, imageId: String, lead: String, location: String, name: String!, startsAt: DateTime!, status: EventStatus! = Scheduled, tagIds: [String!]): Event!

  """Creates a new navigation."""
  createNavigation(key: String!, links: [NavigationLinkInput!]!, name: String!): Navigation!

  """Creates an page."""
  createPage(blocks: [BlockContentInput!]!, description: String, imageID: String, properties: [PropertyInput!]!, slug: String, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Page!

  """Creates a paywall."""
  createPaywall(active: Boolean!, anyMemberPlan: Boolean!, circumventDescription: RichText, description: RichText, memberPlanIds: [String!]! = [], name: String): Paywall!

  """Create a new subscription flow"""
  createSubscriptionFlow(autoRenewal: [Boolean!]!, memberPlanId: String!, paymentMethodIds: [String!]!, periodicities: [PaymentPeriodicity!]!): [SubscriptionFlowModel!]!

  """Create a subscription interval"""
  createSubscriptionInterval(daysAwayFromEnding: Int, event: SubscriptionEvent!, mailTemplateId: String, subscriptionFlowId: String!): [SubscriptionFlowModel!]!

  "\n      Creates a new userConsent based on input.\n      Returns created userConsent.\n    "
  createUserConsent(consentId: String!, userId: String!, value: Boolean!): UserConsent!

  """Deletes an article."""
  deleteArticle(id: String!): String!
  deleteBanner(id: String!): Boolean

  """Deletes an existing block style."""
  deleteBlockStyle(id: String!): BlockStyle!

  "\n      Deletes an existing consent.\n    "
  deleteConsent(id: String!): Consent!
  deleteCrowdfunding(id: String!): Boolean

  """Deletes an existing event."""
  deleteEvent(id: String!): Event!

  """Deletes an existing navigation."""
  deleteNavigation(id: String!): Navigation!

  """Deletes an page."""
  deletePage(id: String!): String!

  """Deletes a paywall."""
  deletePaywall(id: String!): Paywall!

  """Delete poll votes"""
  deletePollVotes(ids: [String!]!): DeletePollVotesResult!

  """Delete an existing subscription flow"""
  deleteSubscriptionFlow(id: String!): [SubscriptionFlowModel!]!

  """Delete an existing subscription interval"""
  deleteSubscriptionInterval(id: String!): [SubscriptionFlowModel!]!

  "\n      Delete an existing userConsent by id.\n      Returns deleted userConsent.\n    "
  deleteUserConsent(id: String!): UserConsent!

  """Dislikes an article."""
  dislikeArticle(id: String!): Article!

  """Duplicates an article."""
  duplicateArticle(id: String!): Article!

  """Duplicates an page."""
  duplicatePage(id: String!): Page!

  "\n      Creates and event based on data from importable events list and an id and provider.\n      Also, uploads an image to WePublish Image library.\n    "
  importEvent(id: String!, source: String!): String!

  """Imports an article from a peer as a draft."""
  importPeerArticle(articleId: String!, options: ImportArticleOptions! = {importAuthors: true, importContentImages: true, importTags: true}, peerId: String!): Article!

  """Likes an article."""
  likeArticle(id: String!): Article!

  """Publishes an article at the given time."""
  publishArticle(id: String!, publishedAt: DateTime!): Article!

  """Publishes an page at the given time."""
  publishPage(id: String!, publishedAt: DateTime!): Page!
  syncTemplates: Boolean

  """Sends a test email for the given event"""
  testSystemMail(event: UserEvent!): Boolean!

  """Unpublishes all revisions of an article."""
  unpublishArticle(id: String!): Article!

  """Unpublishes all revisions of an page."""
  unpublishPage(id: String!): Page!

  """Updates an article."""
  updateArticle(authorIds: [String!]!, blocks: [BlockContentInput!]!, breaking: Boolean!, canonicalUrl: String, disableComments: Boolean!, hidden: Boolean!, hideAuthor: Boolean!, id: String!, imageID: String, lead: String, likes: Int, paywallId: String, preTitle: String, properties: [PropertyInput!]!, seoTitle: String, shared: Boolean!, slug: String, socialMediaAuthorIds: [String!]!, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Article!
  updateBanner(input: UpdateBannerInput!): Banner!

  """Updates an existing block style."""
  updateBlockStyle(blocks: [EditorBlockType!], id: String!, name: String): BlockStyle!

  "\n      Updates an existing consent.\n    "
  updateConsent(defaultValue: Boolean, id: String!, name: String, slug: String): Consent!

  """Update a single crowdfunding"""
  updateCrowdfunding(input: UpdateCrowdfundingInput!): CrowdfundingWithActiveGoal!

  """Updates an existing event."""
  updateEvent(description: RichText, endsAt: DateTime, id: String!, imageId: String, lead: String, location: String, name: String, startsAt: DateTime, status: EventStatus = Scheduled, tagIds: [String!]): Event!

  """Updates an existing navigation."""
  updateNavigation(id: String!, key: String!, links: [NavigationLinkInput!]!, name: String!): Navigation!

  """Updates an page."""
  updatePage(blocks: [BlockContentInput!]!, description: String, id: String!, imageID: String, properties: [PropertyInput!]!, slug: String, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Page!

  """Updates a paywall."""
  updatePaywall(active: Boolean, anyMemberPlan: Boolean, circumventDescription: RichText, description: RichText, id: String!, memberPlanIds: [String!] = [], name: String): Paywall!

  """Updates an existing setting."""
  updateSetting(name: SettingName!, value: GraphQLSettingValueType!): Setting!

  """Update an existing subscription flow"""
  updateSubscriptionFlow(autoRenewal: [Boolean!], id: String!, paymentMethodIds: [String!], periodicities: [PaymentPeriodicity!]): [SubscriptionFlowModel!]!

  """Update an existing subscription interval"""
  updateSubscriptionInterval(daysAwayFromEnding: Int, id: String!, mailTemplateId: String): [SubscriptionFlowModel!]!

  """Updates an existing mail flow"""
  updateSystemMail(event: UserEvent!, mailTemplateId: String!): [SystemMailModel!]!

  "\n      Updates an existing userConsent based on input.\n      Returns updated userConsent.\n    "
  updateUserConsent(id: String!, value: Boolean!): UserConsent!
}

type Navigation {
  createdAt: DateTime!
  id: String!
  key: String!
  links: [BaseNavigationLink!]!
  modifiedAt: DateTime!
  name: String!
}

input NavigationLinkInput {
  articleID: String
  label: String!
  pageID: String
  type: String!
  url: String
}

enum NavigationLinkType {
  Article
  External
  Page
}

type NonDbProperty {
  key: String!
  public: Boolean!
  value: String!
}

type Page {
  createdAt: DateTime!
  draft: PageRevision
  id: String!
  latest: PageRevision!
  modifiedAt: DateTime!
  pending: PageRevision
  previewUrl: String!
  published: PageRevision
  publishedAt: DateTime
  slug: String
  tags: [Tag!]!
  url: String!
}

type PageCreatedAction implements BaseAction & HasPageLc {
  actionType: ActionType!
  date: DateTime!
  page: Page!
  pageId: String!
}

input PageFilter {
  description: String
  draft: Boolean
  pending: Boolean
  publicationDateFrom: DateFilter
  publicationDateTo: DateFilter
  published: Boolean
  tags: [String!]
  title: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PageModel {
  id: String!
}

input PageModelInput {
  id: String!
}

type PageNavigationLink implements BaseNavigationLink & HasPage {
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  page: Page!
  pageID: String!
  type: NavigationLinkType!
}

type PageRevision implements HasBlockContent {
  blocks: [BlockContent!]!
  createdAt: DateTime!
  description: String
  id: String!
  image: Image
  imageID: String
  properties: [Property!]!
  publishedAt: DateTime
  socialMediaDescription: String
  socialMediaImage: Image
  socialMediaImageID: String
  socialMediaTitle: String
  title: String
}

enum PageSort {
  CreatedAt
  ModifiedAt
  PublishedAt
}

type PageTeaser implements BaseTeaser & HasImage & HasOptionalPage {
  image: Image
  imageID: String
  lead: String
  page: Page
  pageID: String
  preTitle: String
  title: String
  type: String!
}

input PageTeaserInput {
  imageID: String
  lead: String
  pageID: String
  preTitle: String
  title: String
}

type PaginatedArticles {
  nodes: [Article!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedEvents {
  nodes: [Event!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedPages {
  nodes: [Page!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedPeerArticle {
  nodes: [PeerArticle!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedPollVotes {
  nodes: [PollVote!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaymentMethod {
  description: String!
  id: String!
  image: Image
  imageId: String
  name: String!
  paymentProviderID: String!
  slug: Slug!
}

enum PaymentPeriodicity {
  biannual
  monthly
  quarterly
  yearly
}

type Paywall {
  active: Boolean!
  anyMemberPlan: Boolean!
  circumventDescription: RichText
  createdAt: DateTime!
  description: RichText
  id: String!
  memberPlans: [MemberPlan!]!
  modifiedAt: DateTime!
  name: String
}

type Peer {
  id: String!
}

type PeerArticle implements HasOptionalPeerLc {
  createdAt: DateTime!
  id: String!
  latest: PeerArticleRevision!
  modifiedAt: DateTime!
  peer: Peer
  peerId: String
  publishedAt: DateTime!
  slug: String
  tags: [Tag!]!
  url: String!
}

input PeerArticleFilter {
  authors: [String!]
  body: String
  excludeIds: [String!]
  ids: [String!]
  lead: String
  peerId: String
  preTitle: String
  publicationDateFrom: DateFilter
  publicationDateTo: DateFilter
  tags: [String!]
  title: String
}

type PeerArticleRevision {
  authors: [Author!]!
  id: String!
  image: PeerImage
  lead: String
  preTitle: String
  seoTitle: String
  title: String
}

type PeerImage {
  id: String!
  license: String
  source: String
  url: String!
}

type PeriodicJob {
  createdAt: DateTime!
  date: DateTime!
  error: String
  executionTime: DateTime
  finishedWithError: DateTime
  id: String!
  modifiedAt: DateTime!
  successfullyFinished: DateTime
  tries: Float!
}

type Phrase {
  articles: PaginatedArticles!
  pages: PaginatedPages!
}

type PolisConversationBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  conversationID: String
  type: BlockType!
}

input PolisConversationBlockInput {
  blockStyle: String
  blockStyleName: String
  conversationID: String
}

type PollAnswerInVote {
  answer: String!
  id: String!
}

type PollBlock implements BaseBlock & HasOptionalPoll {
  blockStyle: String
  blockStyleName: String
  poll: FullPoll
  pollId: String
  type: BlockType!
}

input PollBlockInput {
  blockStyle: String
  blockStyleName: String
  pollId: String
}

type PollStartedAction implements BaseAction & HasPoll {
  actionType: ActionType!
  date: DateTime!
  poll: FullPoll!
  pollId: String!
}

type PollVote {
  answer: PollAnswerInVote!
  answerId: String!
  createdAt: DateTime!
  disabled: Boolean!
  fingerprint: String
  id: String!
  pollId: String!
  userId: String
}

input PollVoteFilter {
  answerIds: [String!]
  fingerprint: String
  from: DateTime
  pollId: String
  to: DateTime
  userId: String
}

enum PollVoteSort {
  CreatedAt
}

type Property {
  id: String!
  key: String!
  public: Boolean!
  value: String!
}

input PropertyInput {
  id: String
  key: String!
  public: Boolean!
  value: String!
}

type PublicSubscription {
  id: String!
}

type Query {
  """Returns latest actions"""
  actions: [Action!]!

  "\n      Returns all active subscribers.\n      Includes subscribers with a cancelled but not run out subscription.\n    "
  activeSubscribers: [DashboardSubscription!]!

  """Returns an article by id or slug."""
  article(id: String, slug: String): Article!

  """Returns a paginated list of articles based on the filters given."""
  articles(cursorId: String, filter: ArticleFilter, order: SortOrder = Descending, skip: Int = 0, sort: ArticleSort = PublishedAt, take: Int = 10): PaginatedArticles!
  banner(id: String!): Banner!
  banners(skip: Int!, take: Int!): [Banner!]!

  """Returns a list of block styles."""
  blockStyles: [BlockStyle!]!

  "\n      Returns a consent by id.\n    "
  consent(id: String!): Consent!

  "\n      Returns all consents.\n    "
  consents(filter: ConsentFilter): [Consent!]!

  """Get a single crowdfunding by id with calculated progress"""
  crowdfunding(id: String!): CrowdfundingWithActiveGoal!

  """Returns a paginated list of crowdfundings."""
  crowdfundings: [Crowdfunding!]!

  "\n      Returns daily stats in a given timeframe.\n    "
  dailySubscriptionStats(end: DateTime, memberPlanIds: [String!], start: DateTime!): [DailySubscriptionStats!]!

  """Returns a event by id."""
  event(id: String!): Event!

  "\n      Returns a list of Importable Event Providers\n    "
  eventProviders: [String!]!

  """Returns a paginated list of events based on the filters given."""
  events(cursorId: String, filter: EventFilter, order: SortOrder = Ascending, skip: Int = 0, sort: EventSort = StartsAt, take: Int = 10): PaginatedEvents!

  "\n      Returns the expected revenue for the time period given.\n      Excludes cancelled or manually set as paid invoices.\n    "
  expectedRevenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!

  """Returns an image by id."""
  getImage(id: String!): ImageV2!

  "\n      Returns the most viewed articles in descending order.\n    "
  hotAndTrending(start: DateTime, take: Int = 10): [Article!]!

  "\n      Returns a more detailed version of a single importable event, by id and source.\n    "
  importedEvent(filter: SingleEventFilter!): EventFromSource!

  "\n      Returns a list of imported events from external sources, transformed to match our model.\n    "
  importedEvents(filter: ImportedEventFilter, order: Int, skip: Int, sort: ImportedEventSort, take: Int): ImportedEventsDocument!

  "\n      Returns a list of external source ids of already imported events.\n    "
  importedEventsIds: [String!]!

  """Return all mail templates"""
  mailTemplates: [MailTemplateWithUrlAndStatusModel!]!

  """Returns a navigation by id."""
  navigation(id: String!): Navigation!

  """Returns a list of navigations."""
  navigations: [Navigation!]!

  "\n      Returns all new deactivations in a given timeframe.\n      This considers the time the deactivation was made, not when the subscription runs out.\n    "
  newDeactivations(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  "\n      Returns all new subscribers in a given timeframe.\n      Includes already deactivated ones.\n    "
  newSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  """Returns an page by id or slug."""
  page(id: String, slug: String): Page!

  """Returns a paginated list of pages based on the filters given."""
  pages(cursorId: String, filter: PageFilter, order: SortOrder = Descending, skip: Int = 0, sort: PageSort = PublishedAt, take: Int = 10): PaginatedPages!

  """Returns all payment methods"""
  paymentMethods: [PaymentMethod!]!

  """Returns an paywall by id."""
  paywall(id: String!): Paywall!

  """Returns a list of paywalls based on the filters given."""
  paywalls: [Paywall!]!

  """Returns a paginated list of peer articles based on the filters given."""
  peerArticles(filter: PeerArticleFilter, order: SortOrder = Descending, skip: Int = 0, sort: ArticleSort = PublishedAt, take: Int = 10): PaginatedPeerArticle!
  periodicJobLog(skip: Int, take: Int = 10): [PeriodicJob!]!

  """
  This query performs a fulltext search on titles and blocks of articles/phrases and returns all matching ones.
  """
  phrase(articleSort: ArticleSort! = PublishedAt, order: SortOrder! = Descending, pageSort: PageSort! = PublishedAt, query: String!, skip: Int! = 0, take: Int! = 10): Phrase!

  """Returns a paginated list of poll votes"""
  pollVotes(cursorId: String, filter: PollVoteFilter, order: SortOrder = Ascending, skip: Int = 0, sort: PollVoteSort = CreatedAt, take: Int = 10): PaginatedPollVotes!
  primaryBanner(documentId: String!, documentType: BannerDocumentType!, hasSubscription: Boolean!, loggedIn: Boolean!): Banner
  provider: MailProviderModel!

  "\n      Returns all renewing subscribers in a given timeframe.\n    "
  renewingSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  "\n      Returns the revenue generated for the time period given.\n      Only includes paid invoices that have not been manually paid.\n    "
  revenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!

  "\n      Returns a single setting by name.\n    "
  setting(name: String!): Setting!

  "\n      Returns a single setting by id.\n    "
  settingById(id: String!): Setting!

  "\n      Returns all settings.\n    "
  settings(filter: SettingFilter): [Setting!]!
  stats: Stats

  """Returns all subscription flows"""
  subscriptionFlows(defaultFlowOnly: Boolean!, memberPlanId: String): [SubscriptionFlowModel!]!

  """Returns all mail flows"""
  systemMails: [SystemMailModel!]!

  "\n      Returns a single userConsent by id.\n    "
  userConsent(id: String!): UserConsent!

  "\n      Returns a list of userConsents. Possible to filter.\n    "
  userConsents(name: String, slug: String, value: Boolean): [UserConsent!]!
  versionInformation: VersionInformation!
}

type QuoteBlock implements BaseBlock & HasImage {
  author: String
  blockStyle: String
  blockStyleName: String
  image: Image
  imageID: String
  quote: String
  type: BlockType!
}

input QuoteBlockInput {
  author: String
  blockStyle: String
  blockStyleName: String
  imageID: String
  quote: String
}

scalar RichText

type RichTextBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  richText: RichText!
  type: BlockType!
}

input RichTextBlockInput {
  blockStyle: String
  blockStyleName: String
  richText: RichText!
}

type Setting {
  id: String!
  name: SettingName!
  settingRestriction: SettingRestriction
  value: GraphQLSettingValueType
}

input SettingFilter {
  name: String
}

enum SettingName {
  ALLOW_COMMENT_EDITING
  ALLOW_GUEST_COMMENTING
  ALLOW_GUEST_COMMENT_RATING
  ALLOW_GUEST_POLL_VOTING
  COMMENT_CHAR_LIMIT
  MAIL_PROVIDER_NAME
  MAKE_ACTIVE_SUBSCRIBERS_API_PUBLIC
  MAKE_EXPECTED_REVENUE_API_PUBLIC
  MAKE_NEW_DEACTIVATIONS_API_PUBLIC
  MAKE_NEW_SUBSCRIBERS_API_PUBLIC
  MAKE_RENEWING_SUBSCRIBERS_API_PUBLIC
  MAKE_REVENUE_API_PUBLIC
  NEW_ARTICLE_PAYWALL
  NEW_ARTICLE_PEERING
  PEERING_TIMEOUT_MS
  RESET_PASSWORD_JWT_EXPIRES_MIN
  SEND_LOGIN_JWT_EXPIRES_MIN
  SHOW_PENDING_WHEN_NOT_PUBLISHED
}

type SettingRestriction {
  allowedValues: AllowedSettingVals
  inputLength: Int
  maxValue: Int
  minValue: Int
}

input SingleEventFilter {
  id: String!
  source: String!
}

scalar Slug

enum SortOrder {
  Ascending
  Descending
}

type SoundCloudTrackBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  trackID: String
  type: BlockType!
}

input SoundCloudTrackBlockInput {
  blockStyle: String
  blockStyleName: String
  trackID: String
}

type Stats {
  articlesCount: Int!
  authorsCount: Int!
  firstArticleDate: DateTime
}

type SubscribeBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
}

input SubscribeBlockInput {
  blockStyle: String
  blockStyleName: String
}

type SubscriptionCreatedAction implements BaseAction & HasSubscription {
  actionType: ActionType!
  date: DateTime!
  subscription: PublicSubscription!
  subscriptionId: String!
}

enum SubscriptionDeactivationReason {
  invoiceNotPaid
  none
  userReplacedSubscription
  userSelfDeactivated
}

enum SubscriptionEvent {
  CONFIRM_SUBSCRIPTION
  CUSTOM
  DEACTIVATION_BY_USER
  DEACTIVATION_UNPAID
  INVOICE_CREATION
  RENEWAL_FAILED
  RENEWAL_SUCCESS
  SUBSCRIBE
}

type SubscriptionFlowModel {
  autoRenewal: [Boolean!]!
  default: Boolean!
  id: String!
  intervals: [SubscriptionInterval!]!
  memberPlan: MemberPlan
  numberOfSubscriptions: Int!
  paymentMethods: [PaymentMethod!]!
  periodicities: [PaymentPeriodicity!]!
}

type SubscriptionInterval {
  daysAwayFromEnding: Int
  event: SubscriptionEvent!
  id: String!
  mailTemplate: MailTemplateRef
}

type SystemMailModel {
  event: UserEvent!
  mailTemplate: MailTemplateRef
}

type Tag {
  id: String!
}

union Teaser = ArticleTeaser | CustomTeaser | EventTeaser | PageTeaser

type TeaserGridBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  numColumns: Int!
  teasers: [Teaser]!
  type: BlockType!
}

input TeaserGridBlockInput {
  blockStyle: String
  blockStyleName: String
  numColumns: Int!
  teasers: [TeaserInput]!
}

type TeaserGridFlexBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  flexTeasers: [FlexTeaser!]!
  type: BlockType!
}

input TeaserGridFlexBlockInput {
  blockStyle: String
  blockStyleName: String
  flexTeasers: [FlexTeaserInput!]!
}

input TeaserInput {
  article: ArticleTeaserInput
  custom: CustomTeaserInput
  event: EventTeaserInput
  page: PageTeaserInput
}

type TeaserListBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  filter: TeaserListBlockFilter!
  skip: Int
  sort: TeaserListBlockSort
  take: Int
  teaserType: TeaserType!
  teasers: [Teaser]!
  title: String
  type: BlockType!
}

type TeaserListBlockFilter {
  tagObjects: [Tag!]!
  tags: [String!]
}

input TeaserListBlockFilterInput {
  tags: [String!] = []
}

input TeaserListBlockInput {
  blockStyle: String
  blockStyleName: String
  filter: TeaserListBlockFilterInput!
  skip: Int
  sort: TeaserListBlockSort
  take: Int
  teaserType: TeaserType!
  title: String
}

enum TeaserListBlockSort {
  HotAndTrending
  PublishedAt
  UpdatedAt
}

type TeaserSlot {
  teaser: Teaser
  type: TeaserSlotType!
}

input TeaserSlotInput {
  teaser: TeaserInput
  type: TeaserSlotType! = Autofill
}

enum TeaserSlotType {
  Autofill
  Manual
}

type TeaserSlotsAutofillConfig implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  enabled: Boolean!
  filter: TeaserListBlockFilter
  sort: TeaserListBlockSort
  teaserType: TeaserType
  type: BlockType!
}

input TeaserSlotsAutofillConfigInput {
  enabled: Boolean!
  filter: TeaserListBlockFilterInput
  sort: TeaserListBlockSort
  teaserType: TeaserType
}

type TeaserSlotsBlock implements BaseBlock {
  autofillConfig: TeaserSlotsAutofillConfig!
  autofillTeasers: [Teaser!]!
  blockStyle: String
  blockStyleName: String
  slots: [TeaserSlot!]!
  teasers: [Teaser]!
  title: String
  type: BlockType!
}

input TeaserSlotsBlockInput {
  autofillConfig: TeaserSlotsAutofillConfigInput!
  blockStyle: String
  blockStyleName: String
  slots: [TeaserSlotInput!]!
  title: String
}

enum TeaserType {
  Article
  Custom
  Event
  Page
}

type TikTokVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  userID: String
  videoID: String
}

input TikTokVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  userID: String
  videoID: String
}

type TitleBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  lead: String
  title: String
  type: BlockType!
}

input TitleBlockInput {
  blockStyle: String
  blockStyleName: String
  lead: String
  title: String
}

type TrackingPixel {
  error: String
  id: String!
  pixelUid: String
  trackingPixelMethod: TrackingPixelMethod!
  uri: String
}

type TrackingPixelMethod {
  id: String!
  trackingPixelProviderID: String!
  trackingPixelProviderType: TrackingPixelProviderType!
}

enum TrackingPixelProviderType {
  prolitteris
}

type TwitterTweetBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  tweetID: String
  type: BlockType!
  userID: String
}

input TwitterTweetBlockInput {
  blockStyle: String
  blockStyleName: String
  tweetID: String
  userID: String
}

type UnknownBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
}

input UpdateBannerInput {
  actions: [CreateBannerActionInput!]
  active: Boolean!
  cta: String
  delay: Int!
  html: String
  id: String!
  imageId: String
  showForLoginStatus: LoginStatus!
  showOnArticles: Boolean!
  showOnPages: [PageModelInput!]
  text: String!
  title: String!
}

input UpdateCrowdfundingInput {
  additionalRevenue: Float
  countSubscriptionsFrom: DateTime
  countSubscriptionsUntil: DateTime
  goals: [CreateCrowdfundingGoalInput!]
  id: String!
  memberPlans: [CreateCrowdfundingMemberPlan!]
  name: String!
}

type User {
  id: String!
}

type UserConsent {
  consent: Consent!
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  user: User!
  value: Boolean!
}

type UserCreatedAction implements BaseAction & HasUserLc {
  actionType: ActionType!
  date: DateTime!
  user: User!
  userId: String!
}

enum UserEvent {
  ACCOUNT_CREATION
  LOGIN_LINK
  PASSWORD_RESET
  TEST_MAIL
}

type VersionInformation {
  version: String!
}

type VimeoVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  videoID: String
}

input VimeoVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  videoID: String
}

type YouTubeVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  videoID: String
}

input YouTubeVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  videoID: String
}

scalar link__Import