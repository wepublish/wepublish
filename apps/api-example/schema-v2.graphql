# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

enum AIProviderType {
  V0
}

union Action = ArticleCreatedAction | AuthorCreatedAction | CommentCreatedAction | EventCreatedAction | PageCreatedAction | PollStartedAction | SubscriptionCreatedAction | UserCreatedAction

enum ActionType {
  ArticleCreated
  AuthorCreated
  CommentCreated
  EventCreated
  PageCreated
  PollStarted
  SubscriptionCreated
  UserCreated
}

type AllowedSettingVals {
  boolChoice: Boolean
  stringChoice: [String!]
}

type Article implements HasOptionalPaywall & HasOptionalPeerLc {
  createdAt: DateTime!
  disableComments: Boolean!
  draft: ArticleRevision
  hidden: Boolean!
  id: String!
  latest: ArticleRevision!
  likes: Int!
  modifiedAt: DateTime!
  paywall: Paywall
  paywallId: String
  peer: Peer
  peerArticleId: String
  peerId: String
  pending: ArticleRevision
  previewUrl: String!
  published: ArticleRevision
  publishedAt: DateTime
  shared: Boolean!
  slug: String
  tags: [Tag!]!
  trackingPixels: [TrackingPixel!]!
  url: String!
}

type ArticleCreatedAction implements BaseAction & HasArticleLc {
  actionType: ActionType!
  article: Article!
  articleId: String!
  date: DateTime!
}

input ArticleFilter {
  authors: [String!]
  body: String
  draft: Boolean
  excludeIds: [String!]
  ids: [String!]
  includeHidden: Boolean
  lead: String
  peerId: String
  pending: Boolean
  preTitle: String
  publicationDateFrom: DateFilter
  publicationDateTo: DateFilter
  published: Boolean
  shared: Boolean
  tags: [String!]
  tagsNotIn: [String!]
  title: String
}

type ArticleNavigationLink implements BaseNavigationLink & HasArticle {
  article: Article!
  articleID: String!
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  type: NavigationLinkType!
}

type ArticleRevision implements HasBlockContent {
  authors: [Author!]!
  blocks: [BlockContent!]!
  breaking: Boolean!
  canonicalUrl: String
  createdAt: DateTime!
  hideAuthor: Boolean!
  id: String!
  image: Image
  imageID: String
  lead: String
  preTitle: String
  properties: [Property!]!
  publishedAt: DateTime
  seoTitle: String
  socialMediaAuthors: [Author!]!
  socialMediaDescription: String
  socialMediaImage: Image
  socialMediaImageID: String
  socialMediaTitle: String
  title: String
}

enum ArticleSort {
  CreatedAt
  ModifiedAt
  PublishedAt
}

type ArticleTeaser implements BaseTeaser & HasImage & HasOptionalArticle {
  article: Article
  articleID: String
  image: Image
  imageID: String
  lead: String
  preTitle: String
  title: String
  type: String!
}

input ArticleTeaserInput {
  articleID: String
  imageID: String
  lead: String
  preTitle: String
  title: String
}

type Author implements HasImage & HasOptionalPeerLc {
  bio: RichText
  createdAt: DateTime!
  hideOnArticle: Boolean!
  hideOnTeam: Boolean!
  hideOnTeaser: Boolean!
  id: String!
  image: Image
  imageID: String
  jobTitle: String
  links: [AuthorLink!]
  modifiedAt: DateTime!
  name: String!
  peer: Peer
  peerId: String
  slug: Slug!
  tags: [Tag!]!
  url: String!
}

type AuthorCreatedAction implements BaseAction & HasAuthor {
  actionType: ActionType!
  author: Author!
  authorId: String!
  date: DateTime!
}

input AuthorFilter {
  hideOnTeam: Boolean
  name: String
  tagIds: [String!]
}

type AuthorLink {
  title: String!
  url: String!
}

input AuthorLinkInput {
  title: String!
  url: String!
}

"""Sorting options for authors"""
enum AuthorSort {
  CreatedAt
  ModifiedAt
  Name
}

type AvailablePaymentMethod {
  forceAutoRenewal: Boolean!
  paymentMethodIDs: [String!]!
  paymentMethods: [PaymentMethod!]!
  paymentPeriodicities: [PaymentPeriodicity!]!
}

input AvailablePaymentMethodInput {
  forceAutoRenewal: Boolean!
  paymentMethodIDs: [String!]!
  paymentPeriodicities: [PaymentPeriodicity!]!
}

type Banner {
  actions: [BannerAction!]
  active: Boolean!
  cta: String
  delay: Int!
  html: String
  id: String!
  image: Image
  imageId: String
  showForLoginStatus: LoginStatus!
  showOnArticles: Boolean!
  showOnPages: [PageModel!]
  text: String!
  title: String!
}

type BannerAction {
  id: String!
  label: String!
  role: BannerActionRole!
  style: String!
  url: String!
}

enum BannerActionRole {
  CANCEL
  OTHER
  PRIMARY
}

enum BannerDocumentType {
  ARTICLE
  PAGE
}

interface BaseAction {
  actionType: ActionType!
  date: DateTime!
}

interface BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
}

interface BaseCrowdfundingGoal {
  amount: Float!
  createdAt: DateTime!
  description: String
  id: String!
  modifiedAt: DateTime!
  title: String!
}

interface BaseNavigationLink {
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  type: NavigationLinkType!
}

interface BaseTeaser implements HasImage {
  image: Image
  imageID: String
  lead: String
  preTitle: String
  title: String
  type: String!
}

interface BaseToken {
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String!
}

interface BaseUser {
  active: Boolean!
  firstName: String
  flair: String
  id: String!
  image: Image
  name: String!
  properties: [Property!]!
  roleIDs: [String!]!
  userImageID: String
}

type BildwurfAdBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  zoneID: String
}

input BildwurfAdBlockInput {
  blockStyle: String
  blockStyleName: String
  zoneID: String
}

union BlockContent = BildwurfAdBlock | BreakBlock | CommentBlock | CrowdfundingBlock | EventBlock | FacebookPostBlock | FacebookVideoBlock | FlexBlock | HTMLBlock | IFrameBlock | ImageBlock | ImageGalleryBlock | InstagramPostBlock | ListicleBlock | PolisConversationBlock | PollBlock | QuoteBlock | RichTextBlock | SoundCloudTrackBlock | StreamableVideoBlock | SubscribeBlock | TeaserGridBlock | TeaserGridFlexBlock | TeaserListBlock | TeaserSlotsBlock | TikTokVideoBlock | TitleBlock | TwitterTweetBlock | UnknownBlock | VimeoVideoBlock | YouTubeVideoBlock

input BlockContentInput {
  bildwurfAd: BildwurfAdBlockInput
  comment: CommentBlockInput
  crowdfunding: CrowdfundingBlockInput
  embed: IFrameBlockInput
  event: EventBlockInput
  facebookPost: FacebookPostBlockInput
  facebookVideo: FacebookVideoBlockInput
  flexBlock: FlexBlockInput
  html: HTMLBlockInput
  image: ImageBlockInput
  imageGallery: ImageGalleryBlockInput
  instagramPost: InstagramPostBlockInput
  linkPageBreak: BreakBlockInput
  listicle: ListicleBlockInput
  polisConversation: PolisConversationBlockInput
  poll: PollBlockInput
  quote: QuoteBlockInput
  richText: RichTextBlockInput
  soundCloudTrack: SoundCloudTrackBlockInput
  streamableVideo: StreamableVideoBlockInput
  subscribe: SubscribeBlockInput
  teaserGrid: TeaserGridBlockInput
  teaserGridFlex: TeaserGridFlexBlockInput
  teaserList: TeaserListBlockInput
  teaserSlots: TeaserSlotsBlockInput
  tikTokVideo: TikTokVideoBlockInput
  title: TitleBlockInput
  twitterTweet: TwitterTweetBlockInput
  vimeoVideo: VimeoVideoBlockInput
  youTubeVideo: YouTubeVideoBlockInput
}

type BlockStyle {
  blocks: [EditorBlockType!]!
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String!
}

enum BlockType {
  BildwurfAd
  Comment
  Crowdfunding
  Embed
  Event
  FacebookPost
  FacebookVideo
  FlexBlock
  HTML
  Image
  ImageGallery
  InstagramPost
  LinkPageBreak
  Listicle
  PolisConversation
  Poll
  Quote
  RichText
  SoundCloudTrack
  StreamableVideo
  Subscribe
  TeaserGrid
  TeaserGridFlex
  TeaserList
  TeaserSlots
  TikTokVideo
  Title
  TwitterTweet
  VimeoVideo
  YouTubeVideo
}

type BlockWithAlignment implements HasOneBlockContent {
  alignment: FlexAlignment!
  block: BlockContent
}

input BlockWithAlignmentInput {
  alignment: FlexAlignmentInput!
  block: BlockContentInput
}

type BreakBlock implements BaseBlock & HasImage {
  blockStyle: String
  blockStyleName: String
  hideButton: Boolean
  image: Image
  imageID: String
  linkTarget: String
  linkText: String
  linkURL: String
  richText: RichText!
  text: String
  type: BlockType!
}

input BreakBlockInput {
  blockStyle: String
  blockStyleName: String
  hideButton: Boolean
  imageID: String
  linkTarget: String
  linkText: String
  linkURL: String
  richText: RichText!
  text: String
}

type CalculatedRating {
  answer: CommentRatingSystemAnswer!
  count: Int!
  mean: Float!
  total: Int!
}

enum CaptchaType {
  Algebraic
  CfTurnstile
}

type Challenge {
  challenge: String
  challengeID: String
  type: CaptchaType!
  validUntil: Date
}

input ChallengeInput {
  challengeID: String!
  challengeSolution: String!
}

enum ChallengeProviderType {
  TURNSTILE
}

type Chat {
  chatId: String!
  message: String!
}

"""A hexadecimal color value (#RRGGBB)"""
scalar Color

type Comment implements HasOptionalUser {
  authorType: CommentAuthorType!
  calculatedRatings: [CalculatedRating!]!
  children: [Comment!]!
  createdAt: DateTime!
  featured: Boolean
  guestUserImage: Image
  guestUserImageID: String
  guestUsername: String
  id: String!
  itemID: String!
  itemType: CommentItemType!
  lead: String
  modifiedAt: DateTime!
  overriddenRatings: [OverriddenRating!]!
  parentComment: Comment
  parentID: String
  rejectionReason: String
  source: String
  state: CommentState!
  tags: [Tag!]!
  text: RichText
  title: String
  url: String!
  user: User
  userID: String
  userRatings: [CommentRating!]!
}

enum CommentAuthorType {
  author
  guestUser
  team
  verifiedUser
}

type CommentBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  comments: [Comment!]!
  filter: CommentBlockFilter!
  type: BlockType!
}

type CommentBlockFilter {
  comments: [String!]
  item: String
  tags: [String!]
}

input CommentBlockFilterInput {
  comments: [String!] = []
  item: String
  tags: [String!] = []
}

input CommentBlockInput {
  blockStyle: String
  blockStyleName: String
  filter: CommentBlockFilterInput!
}

type CommentCreatedAction implements BaseAction & HasComment {
  actionType: ActionType!
  comment: Comment!
  commentId: String!
  date: DateTime!
}

input CommentInput {
  challenge: ChallengeInput
  guestUsername: String
  itemID: String!
  itemType: CommentItemType!
  parentID: String
  text: RichText!
  title: String
}

enum CommentItemType {
  article
  page
}

type CommentRating {
  answer: CommentRatingSystemAnswer!
  commentId: String!
  createdAt: DateTime!
  disabled: Boolean
  fingerprint: String
  id: String!
  modifiedAt: DateTime!
  userId: String
  value: Int!
}

type CommentRatingSystem {
  answers: [CommentRatingSystemAnswer!]!
  id: String!
  name: String
}

type CommentRatingSystemAnswer {
  answer: String
  id: String!
  ratingSystemId: String!
  type: RatingSystemType!
}

enum CommentSort {
  rating
}

enum CommentState {
  approved
  pendingApproval
  pendingUserChanges
  rejected
}

input CommentUpdateInput {
  id: String!
  lead: String
  text: RichText
  title: String
}

type Consent {
  createdAt: DateTime!
  defaultValue: Boolean!
  id: String!
  modifiedAt: DateTime!
  name: String!
  slug: String!
}

input ConsentFilter {
  defaultValue: Boolean
  name: String
  slug: String
}

input CreateBannerActionInput {
  label: String!
  role: BannerActionRole!
  style: String!
  url: String!
}

input CreateBannerInput {
  actions: [CreateBannerActionInput!]
  active: Boolean!
  cta: String
  delay: Int!
  html: String
  imageId: String
  showForLoginStatus: LoginStatus!
  showOnArticles: Boolean!
  showOnPages: [PageModelInput!]
  text: String!
  title: String!
}

input CreateCrowdfundingGoalInput {
  amount: Float!
  description: String
  title: String!
}

input CreateCrowdfundingInput {
  additionalRevenue: Float
  countSubscriptionsFrom: DateTime
  countSubscriptionsUntil: DateTime
  goalType: CrowdfundingGoalType!
  goals: [CreateCrowdfundingGoalInput!]
  memberPlans: [CreateCrowdfundingMemberPlan!]
  name: String!
}

input CreateCrowdfundingMemberPlan {
  id: String!
}

type Crowdfunding {
  activeGoal: CrowdfundingGoalWithProgress
  additionalRevenue: Float
  countSubscriptionsFrom: DateTime
  countSubscriptionsUntil: DateTime
  createdAt: DateTime!
  goalType: CrowdfundingGoalType!
  goals: [CrowdfundingGoal!]!
  id: String!
  memberPlans: [MemberPlan!]!
  modifiedAt: DateTime!
  name: String!
  revenue: Float
  subscriptions: Int
}

type CrowdfundingBlock implements BaseBlock & HasOptionalCrowdfunding {
  blockStyle: String
  blockStyleName: String
  crowdfunding: Crowdfunding
  crowdfundingId: String
  type: BlockType!
}

input CrowdfundingBlockInput {
  blockStyle: String
  blockStyleName: String
  crowdfundingId: String
}

type CrowdfundingGoal implements BaseCrowdfundingGoal {
  amount: Float!
  createdAt: DateTime!
  description: String
  id: String!
  modifiedAt: DateTime!
  title: String!
}

enum CrowdfundingGoalType {
  Revenue
  Subscription
}

type CrowdfundingGoalWithProgress implements BaseCrowdfundingGoal {
  amount: Float!
  createdAt: DateTime!
  description: String
  id: String!
  modifiedAt: DateTime!
  progress: Float
  title: String!
}

enum Currency {
  CHF
  EUR
}

type CustomTeaser implements BaseTeaser & HasImage {
  contentUrl: String
  image: Image
  imageID: String
  lead: String
  openInNewTab: Boolean
  preTitle: String
  properties: [NonDbProperty!]
  title: String
  type: String!
}

input CustomTeaserInput {
  contentUrl: String
  imageID: String
  lead: String
  openInNewTab: Boolean
  preTitle: String
  properties: [PropertyInput!] = []
  title: String
}

type DailyPredictedSubscriptionRenewalCount {
  high: Int!
  low: Int!
  perDayHighProbability: Int!
  perDayLowProbability: Int!
  total: Int!
}

type DailySubscriptionStats {
  createdSubscriptionCount: Int!
  createdSubscriptionUsers: [DailySubscriptionStatsUser!]!
  date: String!
  deactivatedSubscriptionCount: Int!
  deactivatedSubscriptionUsers: [DailySubscriptionStatsUser!]!
  endingSubscriptionCount: Int!
  endingSubscriptionUsers: [DailySubscriptionStatsUser!]!
  overdueSubscriptionCount: Int!
  overdueSubscriptionUsers: [DailySubscriptionStatsUser!]!
  predictedSubscriptionRenewalCount: DailyPredictedSubscriptionRenewalCount!
  predictedSubscriptionRenewalUsersHighProbability: [DailySubscriptionStatsUser!]!
  predictedSubscriptionRenewalUsersLowProbability: [DailySubscriptionStatsUser!]!
  renewedSubscriptionCount: Int!
  renewedSubscriptionUsers: [DailySubscriptionStatsUser!]!
  replacedSubscriptionCount: Int!
  replacedSubscriptionUsers: [DailySubscriptionStatsUser!]!
  totalActiveSubscriptionCount: Int!
}

type DailySubscriptionStatsUser {
  email: String!
  firstName: String
  id: String!
  name: String!
  subscriptionID: String
}

type DashboardInvoice {
  amount: Int!
  dueAt: DateTime!
  memberPlan: String
  paidAt: DateTime
}

type DashboardSubscription {
  deactivationDate: DateTime
  endsAt: DateTime
  memberPlan: String!
  monthlyAmount: Int!
  paymentPeriodicity: PaymentPeriodicity!
  reasonForDeactivation: SubscriptionDeactivationReason
  renewsAt: DateTime
  startsAt: DateTime!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

input DateFilter {
  comparison: DateFilterComparison!
  date: DateTime
}

enum DateFilterComparison {
  Equal
  GreaterThan
  GreaterThanOrEqual
  LowerThan
  LowerThanOrEqual
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type DeletePollVotesResult {
  count: Int!
}

enum EditorBlockType {
  Comment
  Crowdfunding
  Embed
  Event
  FlexBlock
  HTML
  Image
  ImageGallery
  LinkPageBreak
  Listicle
  Poll
  Quote
  RichText
  Subscribe
  TeaserGrid1
  TeaserGrid6
  TeaserGridFlex
  TeaserList
  TeaserSlots
  Title
}

type Event {
  createdAt: DateTime!
  description: RichText
  endsAt: DateTime
  externalSourceId: String
  externalSourceName: String
  id: String!
  image: Image
  imageId: String
  lead: String
  location: String
  modifiedAt: DateTime!
  name: String!
  startsAt: DateTime!
  status: EventStatus!
  tags: [Tag!]
  url: String!
}

type EventBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  events: [Event!]!
  filter: EventBlockFilter!
  type: BlockType!
}

type EventBlockFilter {
  events: [String!]
  tags: [String!]
}

input EventBlockFilterInput {
  events: [String!] = []
  tags: [String!] = []
}

input EventBlockInput {
  blockStyle: String
  blockStyleName: String
  filter: EventBlockFilterInput!
}

type EventCreatedAction implements BaseAction & HasEventLc {
  actionType: ActionType!
  date: DateTime!
  event: Event!
  eventId: String!
}

input EventFilter {
  from: DateTime
  location: String
  name: String
  tags: [String!]
  to: DateTime
  upcomingOnly: Boolean
}

type EventFromSource {
  createdAt: DateTime!
  description: RichText
  endsAt: DateTime
  externalSourceId: String
  externalSourceName: String
  id: String!
  imageUrl: String
  lead: String
  location: String
  modifiedAt: DateTime!
  name: String!
  startsAt: DateTime!
  status: EventStatus!
}

enum EventSort {
  CreatedAt
  EndsAt
  ModifiedAt
  StartsAt
}

enum EventStatus {
  Cancelled
  Postponed
  Rescheduled
  Scheduled
}

type EventTeaser implements BaseTeaser & HasImage & HasOptionalEvent {
  event: Event
  eventID: String
  image: Image
  imageID: String
  lead: String
  preTitle: String
  title: String
  type: String!
}

input EventTeaserInput {
  eventID: String
  imageID: String
  lead: String
  preTitle: String
  title: String
}

type ExternalNavigationLink implements BaseNavigationLink {
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  type: NavigationLinkType!
  url: String
}

type FacebookPostBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  postID: String
  type: BlockType!
  userID: String
}

input FacebookPostBlockInput {
  blockStyle: String
  blockStyleName: String
  postID: String
  userID: String
}

type FacebookVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  userID: String
  videoID: String
}

input FacebookVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  userID: String
  videoID: String
}

type FlexAlignment {
  h: Int!
  i: String!
  static: Boolean
  w: Int!
  x: Int!
  y: Int!
}

input FlexAlignmentInput {
  h: Int!
  i: String!
  static: Boolean
  w: Int!
  x: Int!
  y: Int!
}

type FlexBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  blocks: [BlockWithAlignment!]!
  type: BlockType!
}

input FlexBlockInput {
  blockStyle: String
  blockStyleName: String
  blocks: [BlockWithAlignmentInput!]!
}

type FlexTeaser {
  alignment: FlexAlignment!
  teaser: Teaser
}

input FlexTeaserInput {
  alignment: FlexAlignmentInput!
  teaser: TeaserInput
}

type FocalPoint {
  x: Float!
  y: Float!
}

input FocalPointInput {
  x: Float!
  y: Float!
}

type FullPoll {
  answers: [PollAnswerWithVoteCount!]!
  closedAt: DateTime
  externalVoteSources: [PollExternalVoteSource!]!
  id: String!
  infoText: RichText
  opensAt: DateTime!
  question: String
}

"""Setting Value"""
scalar GraphQLSettingValueType

type HTMLBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  html: String
  type: BlockType!
}

input HTMLBlockInput {
  blockStyle: String
  blockStyleName: String
  html: String
}

interface HasArticle {
  article: Article!
  articleID: String!
}

interface HasArticleLc {
  article: Article!
  articleId: String!
}

interface HasAuthor {
  author: Author!
  authorId: String!
}

interface HasBlockContent {
  blocks: [BlockContent!]!
}

interface HasComment {
  comment: Comment!
  commentId: String!
}

interface HasEventLc {
  event: Event!
  eventId: String!
}

interface HasImage {
  image: Image
  imageID: String
}

interface HasImageLc {
  image: Image
  imageId: String
}

interface HasOneBlockContent {
  block: BlockContent
}

interface HasOptionalArticle {
  article: Article
  articleID: String
}

interface HasOptionalCrowdfunding {
  crowdfunding: Crowdfunding
  crowdfundingId: String
}

interface HasOptionalEvent {
  event: Event
  eventID: String
}

interface HasOptionalPage {
  page: Page
  pageID: String
}

interface HasOptionalPaywall {
  paywall: Paywall
  paywallId: String
}

interface HasOptionalPeerLc {
  peer: Peer
  peerId: String
}

interface HasOptionalPoll {
  poll: FullPoll
  pollId: String
}

interface HasOptionalSubscription {
  subscription: PublicSubscription
  subscriptionID: String
}

interface HasOptionalUser {
  user: User
  userID: String
}

interface HasPage {
  page: Page!
  pageID: String!
}

interface HasPageLc {
  page: Page!
  pageId: String!
}

interface HasPaymentMethod {
  paymentMethod: PaymentMethod!
  paymentMethodID: String!
}

interface HasPoll {
  poll: FullPoll!
  pollId: String!
}

interface HasSubscriptionLc {
  subscription: PublicSubscription!
  subscriptionId: String!
}

interface HasUser {
  user: User!
  userID: String!
}

interface HasUserLc {
  user: User!
  userId: String!
}

type IFrameBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  height: Int
  sandbox: String
  styleCustom: String
  title: String
  type: BlockType!
  url: String
  width: Int
}

input IFrameBlockInput {
  blockStyle: String
  blockStyleName: String
  height: Int
  sandbox: String
  styleCustom: String
  title: String
  url: String
  width: Int
}

type Image implements HasOptionalPeerLc {
  createdAt: DateTime!
  description: String
  extension: String!
  fileSize: Int!
  filename: String
  focalPoint: FocalPoint
  format: String!
  height: Int!
  id: String!
  license: String
  link: String
  mimeType: String!
  modifiedAt: DateTime!
  peer: Peer
  peerId: String
  source: String
  tags: [String!]!
  title: String
  transformURL(input: ImageTransformation): String
  url: String!
  width: Int!
}

type ImageBlock implements BaseBlock & HasImage {
  blockStyle: String
  blockStyleName: String
  caption: String
  image: Image
  imageID: String
  linkUrl: String
  type: BlockType!
}

input ImageBlockInput {
  blockStyle: String
  blockStyleName: String
  caption: String
  imageID: String
  linkUrl: String
}

input ImageFilter {
  tags: [String!]
  title: String
}

type ImageGalleryBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  images: [ImageGalleryImage!]!
  type: BlockType!
}

input ImageGalleryBlockInput {
  blockStyle: String
  blockStyleName: String
  images: [ImageGalleryImageInput!]!
}

type ImageGalleryImage implements HasImage {
  caption: String
  image: Image
  imageID: String
}

input ImageGalleryImageInput {
  caption: String
  imageID: String
}

enum ImageRotation {
  Auto
  Rotate0
  Rotate90
  Rotate180
  Rotate270
}

enum ImageSort {
  CreatedAt
  ModifiedAt
}

input ImageTransformation {
  blur: Boolean
  grayscale: Boolean
  height: Int
  negate: Boolean
  rotation: ImageRotation
  sharpen: Boolean
  width: Int
}

input ImportArticleOptions {
  importAuthors: Boolean
  importContentImages: Boolean
  importTags: Boolean
}

input ImportedEventFilter {
  from: String
  location: String
  name: String
  providers: [String]
  to: String
}

enum ImportedEventSort {
  CREATED_AT
  ENDS_AT
  MODIFIED_AT
  STARTS_AT
}

type ImportedEventsDocument {
  nodes: [EventFromSource!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type InstagramPostBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  postID: String
  type: BlockType!
}

input InstagramPostBlockInput {
  blockStyle: String
  blockStyleName: String
  postID: String
}

type Invoice implements HasOptionalSubscription {
  canceledAt: DateTime
  createdAt: DateTime!
  description: String
  dueAt: DateTime!
  id: String!
  items: [InvoiceItem!]!
  mail: String!
  modifiedAt: DateTime!
  paidAt: DateTime
  subscription: PublicSubscription
  subscriptionID: String
  total: Int!
}

type InvoiceItem {
  amount: Int!
  createdAt: DateTime!
  description: String
  modifiedAt: DateTime!
  name: String!
  quantity: Int!
  total: Int!
}

type ListicleBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  items: [ListicleItem!]!
  type: BlockType!
}

input ListicleBlockInput {
  blockStyle: String
  blockStyleName: String
  items: [ListicleItemInput!]!
}

type ListicleItem implements HasImage {
  image: Image
  imageID: String
  richText: RichText!
  title: String
}

input ListicleItemInput {
  imageID: String
  richText: RichText!
  title: String
}

enum LoginStatus {
  ALL
  LOGGED_IN
  LOGGED_OUT
  SUBSCRIBED
  UNSUBSCRIBED
}

type MailProviderModel {
  name: String!
}

enum MailProviderType {
  MAILCHIMP
  MAILGUN
  SLACK
}

type MailTemplateRef {
  id: String!
  name: String!
}

type MailTemplateWithUrlAndStatusModel {
  description: String
  externalMailTemplateId: String!
  id: String!
  name: String!
  remoteMissing: Boolean!
  status: String!
  url: String!
}

type MemberPlan implements HasImage {
  active: Boolean!
  amountPerMonthMax: Int
  amountPerMonthMin: Int!
  amountPerMonthTarget: Int
  availablePaymentMethods: [AvailablePaymentMethod!]!
  confirmationPage: Page
  confirmationPageId: String
  currency: Currency!
  description: RichText
  extendable: Boolean!
  externalReward: String
  failPage: Page
  failPageId: String
  id: String!
  image: Image
  imageID: String
  maxCount: Int
  migrateToTargetPaymentMethod: PaymentMethod
  migrateToTargetPaymentMethodID: String
  name: String!
  productType: ProductType!
  shortDescription: RichText
  slug: String!
  successPage: Page
  successPageId: String
  tags: [String!]
}

type MemberPlanConnection {
  nodes: [MemberPlan!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input MemberPlanFilter {
  active: Boolean
  name: String
  productType: ProductType
  tags: [String!]
}

enum MemberPlanSort {
  CreatedAt
  ModifiedAt
}

type Mutation {
  """Create a new comment"""
  addComment(input: CommentInput!): Comment!

  """
  This mutation allows to update the user's subscription by taking an input of type UserSubscription and throws an error if the user doesn't already have a subscription. Updating user subscriptions will set deactivation to null
  """
  cancelUserSubscription(id: String!): PublicSubscription

  """Creates an article."""
  createArticle(authorIds: [String!]!, blocks: [BlockContentInput!]!, breaking: Boolean!, canonicalUrl: String, disableComments: Boolean!, hidden: Boolean!, hideAuthor: Boolean!, imageID: String, lead: String, likes: Int, paywallId: String, preTitle: String, properties: [PropertyInput!]!, seoTitle: String, shared: Boolean!, slug: String, socialMediaAuthorIds: [String!]!, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Article!

  """Creates a new author."""
  createAuthor(bio: RichText, hideOnArticle: Boolean!, hideOnTeam: Boolean!, hideOnTeaser: Boolean!, imageID: String, jobTitle: String, links: [AuthorLinkInput!]!, name: String!, slug: Slug!, tagIds: [String!]!): Author!
  createBanner(input: CreateBannerInput!): Banner!

  """Creates a new block style."""
  createBlockStyle(blocks: [EditorBlockType!]!, name: String!): BlockStyle!

  "\n      Create a new consent.\n    "
  createConsent(defaultValue: Boolean!, name: String!, slug: String!): Consent!

  """Create a new crowdfunding"""
  createCrowdfunding(input: CreateCrowdfundingInput!): Crowdfunding!

  """Creates a new event."""
  createEvent(description: RichText, endsAt: DateTime, imageId: String, lead: String, location: String, name: String!, startsAt: DateTime!, status: EventStatus! = Scheduled, tagIds: [String!]): Event!

  """Creates a new memberplan."""
  createMemberPlan(active: Boolean!, amountPerMonthMax: Int, amountPerMonthMin: Int!, amountPerMonthTarget: Int, availablePaymentMethods: [AvailablePaymentMethodInput!]!, confirmationPageId: String, currency: Currency!, description: RichText, extendable: Boolean!, externalReward: String, failPageId: String, imageID: String, maxCount: Int, migrateToTargetPaymentMethodID: String, name: String!, productType: ProductType!, shortDescription: RichText, slug: String!, successPageId: String, tags: [String!]): MemberPlan!

  """Creates a new navigation."""
  createNavigation(key: String!, links: [NavigationLinkInput!]!, name: String!): Navigation!

  """Creates an page."""
  createPage(blocks: [BlockContentInput!]!, description: String, hidden: Boolean!, imageID: String, properties: [PropertyInput!]!, slug: String, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Page!

  """
  This mutation allows to create payment by taking an input of type PaymentFromInvoiceInput.
  """
  createPaymentFromInvoice(input: PaymentFromInvoiceInput!): Payment

  """This mutation allows to create payment by referencing a subscription."""
  createPaymentFromSubscription(failureURL: String, subscriptionId: String, successURL: String): Payment

  """Creates a new payment method."""
  createPaymentMethod(active: Boolean!, description: String!, gracePeriod: Int!, imageId: String, name: String!, paymentProviderID: String!, slug: Slug!): PaymentMethod!

  """Creates a paywall."""
  createPaywall(active: Boolean!, alternativeSubscribeUrl: String, anyMemberPlan: Boolean!, bypassTokens: [String!]!, circumventDescription: RichText, description: RichText, fadeout: Boolean!, hideContentAfter: Int!, memberPlanIds: [String!]!, name: String, upgradeCircumventDescription: RichText, upgradeDescription: RichText): Paywall!

  """Creates a new peer."""
  createPeer(hostURL: String!, information: RichText, isDisabled: Boolean, name: String!, slug: String!, token: String!): Peer!

  """Creates a rating system answer."""
  createRatingSystemAnswer(answer: String, ratingSystemId: String!, type: RatingSystemType!): CommentRatingSystemAnswer!
  createSession(email: String!, password: String!): SessionWithToken!
  createSessionWithJWT(jwt: String!): SessionWithToken!

  """Allows authenticated users to create additional subscriptions"""
  createSubscription(autoRenew: Boolean!, deactivateSubscriptionId: String, failureURL: String, memberPlanID: String, memberPlanSlug: Slug, monthlyAmount: Int!, paymentMethodID: String, paymentMethodSlug: Slug, paymentPeriodicity: PaymentPeriodicity!, subscriptionProperties: [PropertyInput!], successURL: String): Payment!

  """Create a new subscription flow"""
  createSubscriptionFlow(autoRenewal: [Boolean!]!, memberPlanId: String!, paymentMethodIds: [String!]!, periodicities: [PaymentPeriodicity!]!): [SubscriptionFlowModel!]!

  """Create a subscription interval"""
  createSubscriptionInterval(daysAwayFromEnding: Int, event: SubscriptionEvent!, mailTemplateId: String, subscriptionFlowId: String!): [SubscriptionFlowModel!]!

  """
  Allows guests and authenticated users to create additional subscriptions
  """
  createSubscriptionWithConfirmation(autoRenew: Boolean!, memberPlanID: String, memberPlanSlug: Slug, monthlyAmount: Int!, paymentMethodID: String, paymentMethodSlug: Slug, paymentPeriodicity: PaymentPeriodicity!, subscriptionProperties: [PropertyInput!], userId: String): Boolean!

  """Creates a new tag."""
  createTag(description: RichText, main: Boolean! = false, tag: String, type: TagType!): Tag!

  """Creates a token and returns it's secret once."""
  createToken(name: String!): TokenWithSecret!

  "\n      Creates a new userConsent based on input.\n      Returns created userConsent.\n    "
  createUserConsent(consentId: String!, userId: String!, value: Boolean!): UserConsent!

  """Creates a new userrole."""
  createUserRole(description: String, name: String!, permissionIDs: [String!]!): UserRole!

  """Deletes an article."""
  deleteArticle(id: String!): String!

  """Deletes an existing author."""
  deleteAuthor(id: String!): Author!
  deleteBanner(id: String!): Boolean

  """Deletes an existing block style."""
  deleteBlockStyle(id: String!): BlockStyle!

  "\n      Deletes an existing consent.\n    "
  deleteConsent(id: String!): Consent!
  deleteCrowdfunding(id: String!): Boolean

  """Deletes an existing event."""
  deleteEvent(id: String!): Event!

  """Deletes an existing image."""
  deleteImage(id: String!): Image!

  """Deletes an existing memberplan."""
  deleteMemberPlan(id: String!): MemberPlan!

  """Deletes an existing navigation."""
  deleteNavigation(id: String!): Navigation!

  """Deletes an page."""
  deletePage(id: String!): String!

  """Deletes an existing payment method."""
  deletePaymentMethod(id: String!): PaymentMethod!

  """Deletes a paywall."""
  deletePaywall(id: String!): Paywall!

  """Deletes an existing peer."""
  deletePeer(id: String!): Peer!

  """Delete poll votes"""
  deletePollVotes(ids: [String!]!): DeletePollVotesResult!

  """Deletes a rating system answer."""
  deleteRatingSystemAnswer(id: String!): CommentRatingSystemAnswer!

  """Delete an existing subscription flow"""
  deleteSubscriptionFlow(id: String!): [SubscriptionFlowModel!]!

  """Delete an existing subscription interval"""
  deleteSubscriptionInterval(id: String!): [SubscriptionFlowModel!]!

  """Deletes an existing tag."""
  deleteTag(id: String!): Tag!

  """Deletes a token."""
  deleteToken(id: String!): Token!

  "\n      Delete an existing userConsent by id.\n      Returns deleted userConsent.\n    "
  deleteUserConsent(id: String!): UserConsent!

  """Deletes an existing userrole."""
  deleteUserRole(id: String!): UserRole!

  """Dislikes an article."""
  dislikeArticle(id: String!): Article!

  """Duplicates an article."""
  duplicateArticle(id: String!): Article!

  """Duplicates an page."""
  duplicatePage(id: String!): Page!

  """Allows authenticated users to extend existing subscriptions"""
  extendSubscription(failureURL: String, subscriptionId: String!, successURL: String): Payment!

  "\n      Creates and event based on data from importable events list and an id and provider.\n      Also, uploads an image to WePublish Image library.\n    "
  importEvent(id: String!, source: String!): String!

  """Imports an article from a peer as a draft."""
  importPeerArticle(articleId: String!, options: ImportArticleOptions! = {importAuthors: true, importContentImages: true, importTags: true}, peerId: String!): Article!

  """Likes an article."""
  likeArticle(id: String!): Article!

  """Publishes an article at the given time."""
  publishArticle(id: String!, publishedAt: DateTime!): Article!

  """Publishes an page at the given time."""
  publishPage(id: String!, publishedAt: DateTime!): Page!

  """
  This mutation allows to rate a comment. Supports logged in and anonymous
  """
  rateComment(answerId: String!, commentId: String!, value: Int!): Comment!

  """
  This mutation registers a new member by providing name, email, and other required information.
  """
  registerMember(address: UserAddressInput, birthday: DateTime, challengeAnswer: ChallengeInput!, email: String!, firstName: String, name: String!, password: String): Registration!

  """This mutation revokes and deletes the active session."""
  revokeActiveSession: Boolean!

  """
  This mutation sends a login link to the email if the user exists. Method will always return email address
  """
  sendWebsiteLogin(email: String!): String!
  syncTemplates: Boolean

  """Sends a test email for the given event"""
  testSystemMail(event: UserEvent!): Boolean!

  """Unpublishes all revisions of an article."""
  unpublishArticle(id: String!): Article!

  """Unpublishes all revisions of an page."""
  unpublishPage(id: String!): Page!

  """Updates an existing AI provider setting."""
  updateAISetting(apiKey: String, id: String!, name: String, systemPrompt: String): SettingAIProvider!

  """Updates an article."""
  updateArticle(authorIds: [String!]!, blocks: [BlockContentInput!]!, breaking: Boolean!, canonicalUrl: String, disableComments: Boolean!, hidden: Boolean!, hideAuthor: Boolean!, id: String!, imageID: String, lead: String, likes: Int, paywallId: String, preTitle: String, properties: [PropertyInput!]!, seoTitle: String, shared: Boolean!, slug: String, socialMediaAuthorIds: [String!]!, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Article!

  """Updates an existing author."""
  updateAuthor(bio: RichText, hideOnArticle: Boolean, hideOnTeam: Boolean, hideOnTeaser: Boolean, id: String!, imageID: String, jobTitle: String, links: [AuthorLinkInput!], name: String, slug: Slug, tagIds: [String!]): Author!
  updateBanner(input: UpdateBannerInput!): Banner!

  """Updates an existing block style."""
  updateBlockStyle(blocks: [EditorBlockType!], id: String!, name: String): BlockStyle!

  """Updates an existing challenge provider setting."""
  updateChallengeProviderSetting(id: String!, name: String, secret: String, siteKey: String): SettingChallengeProvider!

  """Update an existing comment"""
  updateComment(input: CommentUpdateInput!): Comment!

  "\n      Updates an existing consent.\n    "
  updateConsent(defaultValue: Boolean, id: String!, name: String, slug: String): Consent!

  """Updates a single crowdfunding"""
  updateCrowdfunding(input: UpdateCrowdfundingInput!): Crowdfunding!

  """Updates an existing event."""
  updateEvent(description: RichText, endsAt: DateTime, id: String!, imageId: String, lead: String, location: String, name: String, startsAt: DateTime, status: EventStatus = Scheduled, tagIds: [String!]): Event!

  """Updates an existing image."""
  updateImage(description: String, filename: String, focalPoint: FocalPointInput, id: String!, license: String, link: String, source: String, tags: [String!], title: String): Image!

  """Updates an existing mail provider setting."""
  updateMailProviderSetting(apiKey: String, fromAddress: String, id: String!, mailchimp_baseURL: String, mailgun_baseDomain: String, mailgun_mailDomain: String, name: String, replyToAddress: String, slack_webhookURL: String, webhookEndpointSecret: String): SettingMailProvider!

  """Updates an existing memberplan."""
  updateMemberPlan(active: Boolean, amountPerMonthMax: Int, amountPerMonthMin: Int, amountPerMonthTarget: Int, availablePaymentMethods: [AvailablePaymentMethodInput!], confirmationPageId: String, currency: Currency, description: RichText, extendable: Boolean, externalReward: String, failPageId: String, id: String!, imageID: String, maxCount: Int, migrateToTargetPaymentMethodID: String, name: String, productType: ProductType, shortDescription: RichText, slug: String, successPageId: String, tags: [String!]): MemberPlan!

  """Updates an existing navigation."""
  updateNavigation(id: String!, key: String!, links: [NavigationLinkInput!]!, name: String!): Navigation!

  """Updates an page."""
  updatePage(blocks: [BlockContentInput!]!, description: String, hidden: Boolean!, id: String!, imageID: String, properties: [PropertyInput!]!, slug: String, socialMediaDescription: String, socialMediaImageID: String, socialMediaTitle: String, tagIds: [String!]!, title: String): Page!

  """
  This mutation allows to update the user's password by entering the new password. The repeated new password gives an error if the passwords don't match or if the user is not authenticated.
  """
  updatePassword(password: String!, passwordRepeated: String!): SensitiveDataUser!

  """Updates an existing payment method."""
  updatePaymentMethod(active: Boolean, description: String, gracePeriod: Int, id: String!, imageId: String, name: String, paymentProviderID: String, slug: Slug): PaymentMethod!

  """This mutation allows to update the Payment Provider Customers"""
  updatePaymentProviderCustomers(input: [PaymentProviderCustomerInput!]!): [PaymentProviderCustomer!]!

  """Updates an existing payment provider setting."""
  updatePaymentProviderSetting(apiKey: String, bexio_accountId: Float, bexio_countryId: Float, bexio_invoiceMailBodyNewMembership: String, bexio_invoiceMailBodyRenewalMembership: String, bexio_invoiceMailSubjectNewMembership: String, bexio_invoiceMailSubjectRenewalMembership: String, bexio_invoiceTemplateNewMembership: String, bexio_invoiceTemplateRenewalMembership: String, bexio_invoiceTitleNewMembership: String, bexio_invoiceTitleRenewalMembership: String, bexio_markInvoiceAsOpen: Boolean, bexio_taxId: Float, bexio_unitId: Float, bexio_userId: Float, id: String!, mollie_apiBaseUrl: String, mollie_methods: [PaymentMethodMollie!], name: String, offSessionPayments: Boolean, payrexx_instancename: String, payrexx_pm: [PayrexxPM!], payrexx_psp: [PayrexxPSP!], payrexx_vatrate: String, stripe_methods: [StripePaymentMethod!], webhookEndpointSecret: String): SettingPaymentProvider!

  """Updates a paywall."""
  updatePaywall(active: Boolean, alternativeSubscribeUrl: String, anyMemberPlan: Boolean, bypassTokens: [String!], circumventDescription: RichText, description: RichText, fadeout: Boolean, hideContentAfter: Int, id: String!, memberPlanIds: [String!], name: String, upgradeCircumventDescription: RichText, upgradeDescription: RichText): Paywall!

  """Updates an existing peer."""
  updatePeer(hostURL: String, id: String!, information: RichText, isDisabled: Boolean, name: String, slug: String, token: String): Peer!

  """Update the comment rating system."""
  updateRatingSystem(answers: [UpdateCommentRatingSystemAnswerInput!], id: String!, name: String): CommentRatingSystem!

  """Updates an existing setting."""
  updateSetting(name: SettingName!, value: GraphQLSettingValueType!): Setting!

  """Update an existing subscription flow"""
  updateSubscriptionFlow(autoRenewal: [Boolean!], id: String!, paymentMethodIds: [String!], periodicities: [PaymentPeriodicity!]): [SubscriptionFlowModel!]!

  """Update an existing subscription interval"""
  updateSubscriptionInterval(daysAwayFromEnding: Int, id: String!, mailTemplateId: String): [SubscriptionFlowModel!]!

  """Updates an existing mail flow"""
  updateSystemMail(event: UserEvent!, mailTemplateId: String!): [SystemMailModel!]!

  """Updates an existing tag."""
  updateTag(description: RichText, id: String!, main: Boolean = false, tag: String, type: TagType): Tag!

  """Updates an existing tracking pixel setting."""
  updateTrackingPixelSetting(id: String!, name: String, prolitteris_memberNr: String, prolitteris_onlyPaidContentAccess: Boolean, prolitteris_password: String, prolitteris_publisherInternalKeyDomain: String, prolitteris_usePublisherInternalKey: Boolean, prolitteris_username: String): SettingTrackingPixel!

  """
  This mutation allows to update the user's data by taking an input of type UserInput.
  """
  updateUser(input: UserInput!): SensitiveDataUser

  "\n      Updates an existing userConsent based on input.\n      Returns updated userConsent.\n    "
  updateUserConsent(id: String!, value: Boolean!): UserConsent!

  """Updates an existing userrole."""
  updateUserRole(description: String, id: String!, name: String, permissionIDs: [String!]): UserRole!

  """
  This mutation allows to update the user's subscription by taking an input of type UserSubscription and throws an error if the user doesn't already have a subscription. Updating user subscriptions will set deactivation to null
  """
  updateUserSubscription(id: String!, input: UserSubscriptionInput!): PublicSubscription

  """"""
  upgradeSubscription(failureURL: String, memberPlanId: String!, monthlyAmount: Int!, paymentMethodId: String!, subscriptionId: String!, successURL: String): Payment!

  """Uploads a new image."""
  uploadImage(description: String, file: Upload!, filename: String, focalPoint: FocalPointInput, license: String, link: String, source: String, tags: [String!]!, title: String): Image!

  """This mutation allows to upload and update the user's profile image."""
  uploadUserProfileImage(description: String, file: Upload!, filename: String, focalPoint: FocalPointInput, license: String, link: String, source: String, tags: [String!]!, title: String): SensitiveDataUser

  """
  This mutation allows to vote on a poll (or update one's decision). Supports logged in and anonymous
  """
  voteOnPoll(answerId: String!): PollVote
}

type Navigation {
  createdAt: DateTime!
  id: String!
  key: String!
  links: [BaseNavigationLink!]!
  modifiedAt: DateTime!
  name: String!
}

input NavigationLinkInput {
  articleID: String
  label: String!
  pageID: String
  type: String!
  url: String
}

enum NavigationLinkType {
  Article
  External
  Page
}

type NonDbProperty {
  key: String!
  public: Boolean!
  value: String!
}

type OverriddenRating {
  answerId: String!
  value: Int
}

type Page {
  createdAt: DateTime!
  draft: PageRevision
  hidden: Boolean!
  id: String!
  latest: PageRevision!
  modifiedAt: DateTime!
  pending: PageRevision
  previewUrl: String!
  published: PageRevision
  publishedAt: DateTime
  slug: String
  tags: [Tag!]!
  url: String!
}

type PageCreatedAction implements BaseAction & HasPageLc {
  actionType: ActionType!
  date: DateTime!
  page: Page!
  pageId: String!
}

input PageFilter {
  description: String
  draft: Boolean
  includeHidden: Boolean
  pending: Boolean
  publicationDateFrom: DateFilter
  publicationDateTo: DateFilter
  published: Boolean
  tags: [String!]
  title: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PageModel {
  id: String!
}

input PageModelInput {
  id: String!
}

type PageNavigationLink implements BaseNavigationLink & HasPage {
  createdAt: DateTime!
  id: String!
  label: String!
  modifiedAt: DateTime!
  page: Page!
  pageID: String!
  type: NavigationLinkType!
}

type PageRevision implements HasBlockContent {
  blocks: [BlockContent!]!
  createdAt: DateTime!
  description: String
  id: String!
  image: Image
  imageID: String
  properties: [Property!]!
  publishedAt: DateTime
  socialMediaDescription: String
  socialMediaImage: Image
  socialMediaImageID: String
  socialMediaTitle: String
  title: String
}

enum PageSort {
  CreatedAt
  ModifiedAt
  PublishedAt
}

type PageTeaser implements BaseTeaser & HasImage & HasOptionalPage {
  image: Image
  imageID: String
  lead: String
  page: Page
  pageID: String
  preTitle: String
  title: String
  type: String!
}

input PageTeaserInput {
  imageID: String
  lead: String
  pageID: String
  preTitle: String
  title: String
}

type PaginatedArticles {
  nodes: [Article!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedAuthors {
  nodes: [Author!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedEvents {
  nodes: [Event!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedImages {
  nodes: [Image!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedPages {
  nodes: [Page!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedPeerArticle {
  nodes: [PeerArticle!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedPollVotes {
  nodes: [PollVote!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedUserRoles {
  nodes: [UserRole!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Payment implements HasPaymentMethod {
  id: String!
  intentSecret: String!
  paymentMethod: PaymentMethod!
  paymentMethodID: String!
  state: PaymentState!
}

input PaymentFromInvoiceInput {
  failureURL: String
  invoiceID: String!
  paymentMethodID: String
  paymentMethodSlug: Slug
  successURL: String
}

type PaymentMethod implements HasImageLc {
  active: Boolean!
  createdAt: DateTime!
  description: String!
  gracePeriod: Int!
  id: String!
  image: Image
  imageId: String
  modifiedAt: DateTime!
  name: String!
  paymentProvider: PaymentProvider
  paymentProviderID: String!
  slug: Slug!
}

enum PaymentMethodMollie {
  ALMA
  APPLEPAY
  BACS
  BANCOMATPAY
  BANCONTACT
  BANKTRANSFER
  BELFIUS
  BILLIE
  BLIK
  CREDITCARD
  DIRECTDEBIT
  EPS
  GIFTCARD
  IDEAL
  IN3
  KBC
  KLARNA
  KLARNAPAYLATER
  KLARNAPAYNOW
  KLARNASLICEIT
  MYBANK
  PAYPAL
  PAYSAFECARD
  PRZELEWY24
  RIVERTY
  SATISPAY
  TRUSTLY
  TWINT
  VOUCHER
}

enum PaymentPeriodicity {
  biannual
  biennial
  lifetime
  monthly
  quarterly
  yearly
}

type PaymentProvider {
  id: String!
  name: String!
}

type PaymentProviderCustomer {
  customerID: String!
  paymentProviderID: String!
}

input PaymentProviderCustomerInput {
  customerID: String!
  paymentProviderID: String!
}

enum PaymentProviderType {
  BEXIO
  MOLLIE
  NO_CHARGE
  PAYREXX
  PAYREXX_SUBSCRIPTION
  STRIPE
  STRIPE_CHECKOUT
}

enum PaymentState {
  canceled
  created
  declined
  paid
  processing
  requiresUserAction
  submitted
}

enum PayrexxPM {
  ALIPAY
  AMAZON_PAY
  AMERICAN_EXPRESS
  APPLE_PAY
  BANCONTACT
  BANK_TRANSFER
  CARTES_BANCAIRES
  CRYPTO
  DINERS_CLUB
  DISCOVER
  EPS
  GIROPAY
  GOOGLE_PAY
  IDEAL
  INVOICE
  JCB
  KLARNA
  MAESTRO
  MASTERCARD
  PAYPAL
  PAY_BY_BANK
  POST_FINANCE_PAY
  POWERPAY
  PREPAYMENT
  SAMSUNG_PAY
  SEPA_DIRECT_DEBIT
  SWISSCOM_PAY
  TWINT
  UNIONPAY
  VERD_CASH
  VISA
  V_PAY
  WECHAT_PAY
}

enum PayrexxPSP {
  AMAZON_PAY
  BARZAHLEN_VIACASH
  BRAINTREE
  CCAVENUE
  CEMBRAPAY
  CLEARHAUS_ACQUIRING
  COINBASE
  CONCARDIS_BASIC
  CONCARDIS_PAYENGINE
  CONCARDIS_PAY_ENGINE
  DATATRANS
  GIROPAY
  INVOICE
  KLARNA
  MOLLIE
  OGONE_ALIAS_GATEWAY
  OGONE_BASIC
  PAYONE
  PAYPAL
  PAYREXX_PAY
  PAYREXX_PAYMENTS_BY_STRIPE
  PAYREXX_PAY_PLUS
  PAYSAFECASH
  POINTS_PAY
  POSTFINANCE_ALIAS_GATEWAY
  POSTFINANCE_CHECKOUT
  POSTFINANCE_ECOMMERCE
  POWERPAY
  REKA
  SAFERPAY
  SKRILL
  STRIPE
  SWISSBILLING
  TWINT
  UTRUST
  VIVEUM
  VORKASSE
  VRPAY
  WIRPAY
  WORLDPAY
}

type Paywall {
  active: Boolean!
  alternativeSubscribeUrl: String
  anyMemberPlan: Boolean!
  bypasses: [PaywallBypass!]!
  circumventDescription: RichText
  createdAt: DateTime!
  description: RichText
  fadeout: Boolean!
  hideContentAfter: Int!
  id: String!
  memberPlans: [MemberPlan!]!
  modifiedAt: DateTime!
  name: String
  upgradeCircumventDescription: RichText
  upgradeDescription: RichText
}

type PaywallBypass {
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  paywallId: String!
  token: String!
}

type Peer {
  createdAt: DateTime!
  hostURL: String!
  id: String!
  information: RichText
  isDisabled: Boolean
  modifiedAt: DateTime!
  name: String!
  profile: RemotePeerProfile
  slug: String!
  token: String!
}

type PeerArticle implements HasOptionalPeerLc {
  createdAt: DateTime!
  id: String!
  latest: PeerArticleRevision!
  modifiedAt: DateTime!
  peer: Peer
  peerId: String
  publishedAt: DateTime!
  slug: String
  url: String!
}

input PeerArticleFilter {
  authors: [String!]
  body: String
  excludeIds: [String!]
  ids: [String!]
  lead: String
  peerId: String
  preTitle: String
  publicationDateFrom: DateFilter
  publicationDateTo: DateFilter
  tags: [String!]
  title: String
}

type PeerArticleRevision {
  id: String!
  image: PeerImage
  lead: String
  preTitle: String
  seoTitle: String
  title: String
}

type PeerImage {
  createdAt: DateTime!
  description: String
  extension: String!
  fileSize: Int!
  filename: String
  focalPoint: FocalPoint
  format: String!
  height: Int!
  id: String!
  l: String
  lSquare: String
  license: String
  link: String
  m: String
  mSquare: String
  mimeType: String!
  modifiedAt: DateTime!
  peer: Peer
  peerId: String
  s: String
  sSquare: String
  source: String
  tags: [String!]!
  title: String
  url: String!
  width: Int!
  xl: String
  xlSquare: String
  xs: String
  xsSquare: String
  xxl: String
  xxlSquare: String
  xxs: String
  xxsSquare: String
}

type PeerProfile {
  callToActionImage: Image
  callToActionImageID: String
  callToActionImageURL: String
  callToActionText: RichText!
  callToActionURL: String!
  hostURL: String!
  logo: Image
  logoID: String
  name: String!
  squareLogo: Image
  squareLogoId: String
  themeColor: Color!
  themeFontColor: Color!
  websiteURL: String!
}

type PeriodicJob {
  createdAt: DateTime!
  date: DateTime!
  error: String
  executionTime: DateTime
  finishedWithError: DateTime
  id: String!
  modifiedAt: DateTime!
  successfullyFinished: DateTime
  tries: Float!
}

type Permission {
  deprecated: Boolean!
  description: String!
  id: String!
}

type Phrase {
  articles: PaginatedArticles!
  pages: PaginatedPages!
}

type PolisConversationBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  conversationID: String
  type: BlockType!
}

input PolisConversationBlockInput {
  blockStyle: String
  blockStyleName: String
  conversationID: String
}

type PollAnswerInVote {
  answer: String!
  id: String!
}

type PollAnswerWithVoteCount {
  answer: String
  id: String!
  pollId: String!
  votes: Int!
}

type PollBlock implements BaseBlock & HasOptionalPoll {
  blockStyle: String
  blockStyleName: String
  poll: FullPoll
  pollId: String
  type: BlockType!
}

input PollBlockInput {
  blockStyle: String
  blockStyleName: String
  pollId: String
}

type PollExternalVote {
  amount: VoteValue!
  answerId: String!
  id: String!
}

type PollExternalVoteSource {
  id: String!
  source: String
  voteAmounts: [PollExternalVote!]!
}

type PollStartedAction implements BaseAction & HasPoll {
  actionType: ActionType!
  date: DateTime!
  poll: FullPoll!
  pollId: String!
}

type PollVote {
  answer: PollAnswerInVote!
  answerId: String!
  createdAt: DateTime!
  disabled: Boolean!
  fingerprint: String
  id: String!
  pollId: String!
  userId: String
}

input PollVoteFilter {
  answerIds: [String!]
  fingerprint: String
  from: DateTime
  pollId: String
  to: DateTime
  userId: String
}

enum PollVoteSort {
  CreatedAt
}

enum ProductType {
  Donation
  Subscription
}

type Property {
  id: String!
  key: String!
  public: Boolean!
  value: String!
}

input PropertyInput {
  id: String
  key: String!
  public: Boolean!
  value: String!
}

type PublicSubscription implements HasPaymentMethod & HasUser {
  autoRenew: Boolean!
  canExtend: Boolean!
  deactivation: SubscriptionDeactivation
  extendable: Boolean!
  externalReward: String
  id: String!
  isActive: Boolean!
  memberPlan: MemberPlan!
  monthlyAmount: Int!
  paidUntil: DateTime
  paymentMethod: PaymentMethod!
  paymentMethodID: String!
  paymentPeriodicity: PaymentPeriodicity!
  properties: [Property!]!
  startsAt: DateTime!
  url: String!
  user: User!
  userID: String!
}

type Query {
  """Returns latest actions"""
  actions: [Action!]!

  "\n      Returns all active subscribers.\n      Includes subscribers with a cancelled but not run out subscription.\n    "
  activeSubscribers: [DashboardSubscription!]!

  """Returns a single AI provider setting by id."""
  aiSetting(id: String!): SettingAIProvider!

  """Returns all AI provider settings."""
  aiSettings(filter: SettingAIProviderFilter): [SettingAIProvider!]!

  """Returns an article by id or slug."""
  article(id: String, slug: String): Article!

  """Returns a paginated list of articles based on the filters given."""
  articles(cursorId: String, filter: ArticleFilter, order: SortOrder = Descending, skip: Int = 0, sort: ArticleSort = PublishedAt, take: Int = 10): PaginatedArticles!

  """Get an author by ID or slug"""
  author(id: String, slug: Slug): Author

  """Get a paginated list of authors with optional filtering and sorting"""
  authors(cursor: String, filter: AuthorFilter, order: SortOrder = Descending, skip: Int, sort: AuthorSort = ModifiedAt, take: Int): PaginatedAuthors!
  banner(id: String!): Banner!
  banners(skip: Int!, take: Int!): [Banner!]!

  """Returns a list of block styles."""
  blockStyles: [BlockStyle!]!

  """
  This query generates a challenge which can be used to access protected endpoints.
  """
  challenge: Challenge!

  """Returns a single challenge provider setting by id."""
  challengeProviderSetting(id: String!): SettingChallengeProvider!

  """Returns all challenge provider settings."""
  challengeProviderSettings(filter: SettingChallengeProviderFilter): [SettingChallengeProvider!]!

  """
  Check the status of an invoice and update with information from the payment provider
  """
  checkInvoiceStatus(id: String!): Invoice

  """This query returns the comments of an item."""
  comments(itemId: String!, order: SortOrder = Descending, sort: CommentSort): [Comment!]!

  "\n      Returns a consent by id.\n    "
  consent(id: String!): Consent!

  "\n      Returns all consents.\n    "
  consents(filter: ConsentFilter): [Consent!]!

  """Get a single crowdfunding by id"""
  crowdfunding(id: String!): Crowdfunding!

  """Returns a list of crowdfundings."""
  crowdfundings: [Crowdfunding!]!

  "\n      Returns daily stats in a given timeframe.\n    "
  dailySubscriptionStats(end: DateTime, memberPlanIds: [String!], start: DateTime!): [DailySubscriptionStats!]!

  """Returns a event by id."""
  event(id: String!): Event!

  "\n      Returns a list of Importable Event Providers\n    "
  eventProviders: [String!]!

  """Returns a paginated list of events based on the filters given."""
  events(cursorId: String, filter: EventFilter, order: SortOrder = Ascending, skip: Int = 0, sort: EventSort = StartsAt, take: Int = 10): PaginatedEvents!

  "\n      Returns the expected revenue for the time period given.\n      Excludes cancelled or manually set as paid invoices.\n    "
  expectedRevenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!

  "\n      Returns the most viewed articles in descending order.\n    "
  hotAndTrending(start: DateTime, take: Int = 10): [Article!]!

  """Returns a image by id."""
  image(id: String!): Image!

  """Returns a paginated list of images based on the filters given."""
  images(cursorId: String, filter: ImageFilter, order: SortOrder = Descending, skip: Int = 0, sort: ImageSort = ModifiedAt, take: Int = 10): PaginatedImages!

  "\n      Returns a more detailed version of a single importable event, by id and source.\n    "
  importedEvent(filter: SingleEventFilter!): EventFromSource!

  "\n      Returns a list of imported events from external sources, transformed to match our model.\n    "
  importedEvents(filter: ImportedEventFilter, order: Int, skip: Int, sort: ImportedEventSort, take: Int): ImportedEventsDocument!

  "\n      Returns a list of external source ids of already imported events.\n    "
  importedEventsIds: [String!]!

  """Get all invoices for the authenticated user"""
  invoices: [Invoice!]!

  """Returns a single mail provider setting by id."""
  mailProviderSetting(id: String!): SettingMailProvider!

  """Returns all mail provider settings."""
  mailProviderSettings(filter: SettingMailProviderFilter): [SettingMailProvider!]!

  """Return all mail templates"""
  mailTemplates: [MailTemplateWithUrlAndStatusModel!]!

  """This query returns the user."""
  me: SensitiveDataUser

  """Returns a memberplan by id or slug."""
  memberPlan(id: String, slug: Slug): MemberPlan!

  """Returns a paginated list of memberplans based on the filters given."""
  memberPlans(cursorId: String, filter: MemberPlanFilter, order: SortOrder = Ascending, skip: Int = 0, sort: MemberPlanSort = ModifiedAt, take: Int = 10): MemberPlanConnection!

  """Returns a navigation by id."""
  navigation(id: String!): Navigation!

  """Returns a list of navigations."""
  navigations: [Navigation!]!

  "\n      Returns all new deactivations in a given timeframe.\n      This considers the time the deactivation was made, not when the subscription runs out.\n    "
  newDeactivations(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  "\n      Returns all new subscribers in a given timeframe.\n      Includes already deactivated ones.\n    "
  newSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  """Returns an page by id or slug."""
  page(id: String, slug: String): Page!

  """Returns a paginated list of pages based on the filters given."""
  pages(cursorId: String, filter: PageFilter, order: SortOrder = Descending, skip: Int = 0, sort: PageSort = PublishedAt, take: Int = 10): PaginatedPages!

  """Returns a payment method by id"""
  paymentMethod(id: String!): PaymentMethod!

  """Returns all payment methods"""
  paymentMethods: [PaymentMethod!]!

  """Returns a single payment provider setting by id."""
  paymentProviderSetting(id: String!): SettingPaymentProvider!

  """Returns all payment provider settings."""
  paymentProviderSettings(filter: SettingPaymentProviderFilter): [SettingPaymentProvider!]!

  """Returns all payment providers"""
  paymentProviders: [PaymentProvider!]!

  """Returns an paywall by id."""
  paywall(id: String!): Paywall!

  """Returns a list of paywalls based on the filters given."""
  paywalls: [Paywall!]!

  """
  This query takes either the ID or the slug and returns the peer profile.
  """
  peer(id: String, slug: String): Peer

  """Returns a paginated list of peer articles based on the filters given."""
  peerArticles(filter: PeerArticleFilter, order: SortOrder = Descending, skip: Int = 0, sort: ArticleSort = PublishedAt, take: Int = 10): PaginatedPeerArticle!

  """This query returns the peer profile."""
  peerProfile: PeerProfile!

  """Returns a list of all peers."""
  peers: [Peer!]!
  periodicJobLog(skip: Int, take: Int = 10): [PeriodicJob!]!

  """Returns a list of all permissions."""
  permissions: [Permission!]!

  """
  This query performs a fulltext search on titles and blocks of articles/phrases and returns all matching ones.
  """
  phrase(articleSort: ArticleSort! = PublishedAt, order: SortOrder! = Descending, pageSort: PageSort! = PublishedAt, query: String!, skip: Int! = 0, take: Int! = 10): Phrase!
  poll(id: String!): FullPoll!

  """Returns a paginated list of poll votes"""
  pollVotes(cursorId: String, filter: PollVoteFilter, order: SortOrder = Ascending, skip: Int = 0, sort: PollVoteSort = CreatedAt, take: Int = 10): PaginatedPollVotes!
  primaryBanner(documentId: String!, documentType: BannerDocumentType!, hasSubscription: Boolean!, loggedIn: Boolean!): Banner
  promptHTML(chatId: String, query: String!): Chat!
  provider: MailProviderModel!

  """This query returns the comment rating system."""
  ratingSystem: CommentRatingSystem!

  "\n      Returns all renewing subscribers in a given timeframe.\n    "
  renewingSubscribers(end: DateTime, start: DateTime!): [DashboardSubscription!]!

  "\n      Returns the revenue generated for the time period given.\n      Only includes paid invoices that have not been manually paid.\n    "
  revenue(end: DateTime, start: DateTime!): [DashboardInvoice!]!

  "\n      Returns a single setting by name.\n    "
  setting(name: String!): Setting!

  "\n      Returns a single setting by id.\n    "
  settingById(id: String!): Setting!

  "\n      Returns all settings.\n    "
  settings(filter: SettingFilter): [Setting!]!
  stats: Stats

  """Returns all subscription flows"""
  subscriptionFlows(defaultFlowOnly: Boolean!, memberPlanId: String): [SubscriptionFlowModel!]!

  """This query returns the subscriptions of the authenticated user."""
  subscriptions: [PublicSubscription!]!

  """Returns all mail flows"""
  systemMails: [SystemMailModel!]!

  """Returns an tag by id or tag."""
  tag(id: String, tag: String, type: TagType): Tag!

  """This query returns a list of tags"""
  tags(
    """Cursor for pagination"""
    cursor: String

    """Filter for tags"""
    filter: TagFilter

    """Sort order"""
    order: SortOrder = Descending

    """Number of items to skip"""
    skip: Int! = 0

    """Field to sort by"""
    sort: TagSort! = CreatedAt

    """Number of items to fetch"""
    take: Int! = 10
  ): TagConnection!

  """Returns a list of all tokens."""
  tokens: [Token!]!

  """Returns a single tracking pixel setting by id."""
  trackingPixelSetting(id: String!): SettingTrackingPixel!

  """Returns all tracking pixel settings."""
  trackingPixelSettings(filter: SettingTrackingPixelFilter): [SettingTrackingPixel!]!

  """"""
  upgradeSubscriptionInfo(memberPlanId: String!, subscriptionId: String!): UpgradeSubscription!

  "\n      Returns a single userConsent by id.\n    "
  userConsent(id: String!): UserConsent!

  "\n      Returns a list of userConsents. Possible to filter.\n    "
  userConsents(name: String, slug: String, value: Boolean): [UserConsent!]!
  userPollVote(pollId: String!): String

  """Returns a userrole by id."""
  userRole(id: String!): UserRole!

  """Returns a paginated list of userroles based on the filters given."""
  userRoles(cursorId: String, filter: UserRoleFilter, order: SortOrder = Ascending, skip: Int = 0, sort: UserRoleSort = CreatedAt, take: Int = 10): PaginatedUserRoles!
  versionInformation: VersionInformation!
}

type QuoteBlock implements BaseBlock & HasImage {
  author: String
  blockStyle: String
  blockStyleName: String
  image: Image
  imageID: String
  quote: String
  type: BlockType!
}

input QuoteBlockInput {
  author: String
  blockStyle: String
  blockStyleName: String
  imageID: String
  quote: String
}

enum RatingSystemType {
  star
}

type Registration {
  session: SessionWithTokenWithoutUser!
  user: SensitiveDataUser!
}

type RemotePeerProfile {
  callToActionImage: PeerImage
  callToActionImageID: String
  callToActionImageURL: String
  callToActionText: RichText!
  callToActionURL: String!
  hostURL: String!
  logo: PeerImage
  logoID: String
  name: String!
  squareLogo: PeerImage
  squareLogoId: String
  themeColor: Color!
  themeFontColor: Color!
  websiteURL: String!
}

scalar RichText

type RichTextBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  richText: RichText!
  type: BlockType!
}

input RichTextBlockInput {
  blockStyle: String
  blockStyleName: String
  richText: RichText!
}

type SensitiveDataUser implements BaseUser {
  active: Boolean!
  address: UserAddress
  birthday: DateTime
  email: String!
  firstName: String
  flair: String
  id: String!
  image: Image
  name: String!
  paymentProviderCustomers: [PaymentProviderCustomer!]
  permissions: [String!]!
  properties: [Property!]!
  roleIDs: [String!]!
  userImageID: String
}

type SessionWithToken {
  createdAt: DateTime!
  expiresAt: DateTime!
  token: String!
  user: SensitiveDataUser!
}

type SessionWithTokenWithoutUser {
  createdAt: DateTime!
  expiresAt: DateTime!
  token: String!
}

type Setting {
  id: String!
  name: SettingName!
  settingRestriction: SettingRestriction
  value: GraphQLSettingValueType
}

type SettingAIProvider {
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String
  systemPrompt: String
  type: AIProviderType!
}

input SettingAIProviderFilter {
  id: String
  name: String
  type: AIProviderType
}

type SettingChallengeProvider {
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String
  type: ChallengeProviderType!
}

input SettingChallengeProviderFilter {
  id: String
  name: String
  type: ChallengeProviderType
}

input SettingFilter {
  name: String
}

type SettingMailProvider {
  createdAt: DateTime!
  fromAddress: String
  id: String!
  mailchimp_baseURL: String
  mailgun_baseDomain: String
  mailgun_mailDomain: String
  modifiedAt: DateTime!
  name: String
  replyToAddress: String
  slack_webhookURL: String
  type: MailProviderType!
  webhookEndpointSecret: String
}

input SettingMailProviderFilter {
  id: String
  name: String
  type: MailProviderType
}

enum SettingName {
  ALLOW_COMMENT_EDITING
  ALLOW_GUEST_COMMENTING
  ALLOW_GUEST_COMMENT_RATING
  ALLOW_GUEST_POLL_VOTING
  COMMENT_CHAR_LIMIT
  MAIL_PROVIDER_NAME
  MAKE_ACTIVE_SUBSCRIBERS_API_PUBLIC
  MAKE_EXPECTED_REVENUE_API_PUBLIC
  MAKE_NEW_DEACTIVATIONS_API_PUBLIC
  MAKE_NEW_SUBSCRIBERS_API_PUBLIC
  MAKE_RENEWING_SUBSCRIBERS_API_PUBLIC
  MAKE_REVENUE_API_PUBLIC
  NEW_ARTICLE_PAYWALL
  NEW_ARTICLE_PEERING
  PEERING_TIMEOUT_MS
  RESET_PASSWORD_JWT_EXPIRES_MIN
  SEND_LOGIN_JWT_EXPIRES_MIN
  SHOW_PENDING_WHEN_NOT_PUBLISHED
}

type SettingPaymentProvider {
  bexio_accountId: Float
  bexio_countryId: Float
  bexio_invoiceMailBodyNewMembership: String
  bexio_invoiceMailBodyRenewalMembership: String
  bexio_invoiceMailSubjectNewMembership: String
  bexio_invoiceMailSubjectRenewalMembership: String
  bexio_invoiceTemplateNewMembership: String
  bexio_invoiceTemplateRenewalMembership: String
  bexio_invoiceTitleNewMembership: String
  bexio_invoiceTitleRenewalMembership: String
  bexio_markInvoiceAsOpen: Boolean
  bexio_taxId: Float
  bexio_unitId: Float
  bexio_userId: Float
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  mollie_apiBaseUrl: String
  mollie_methods: [PaymentMethodMollie!]
  name: String
  offSessionPayments: Boolean
  payrexx_instancename: String
  payrexx_pm: [PayrexxPM!]
  payrexx_psp: [PayrexxPSP!]
  payrexx_vatrate: String
  stripe_methods: [StripePaymentMethod!]
  type: PaymentProviderType!
  webhookEndpointSecret: String
}

input SettingPaymentProviderFilter {
  id: String
  name: String
  type: PaymentProviderType
}

type SettingRestriction {
  allowedValues: AllowedSettingVals
  inputLength: Int
  maxValue: Int
  minValue: Int
}

type SettingTrackingPixel {
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String
  prolitteris_memberNr: String
  prolitteris_onlyPaidContentAccess: Boolean
  prolitteris_publisherInternalKeyDomain: String
  prolitteris_usePublisherInternalKey: Boolean
  prolitteris_username: String
  type: TrackingPixelProviderType!
}

input SettingTrackingPixelFilter {
  id: String
  name: String
  type: TrackingPixelProviderType
}

input SingleEventFilter {
  id: String!
  source: String!
}

scalar Slug

enum SortOrder {
  Ascending
  Descending
}

type SoundCloudTrackBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  trackID: String
  type: BlockType!
}

input SoundCloudTrackBlockInput {
  blockStyle: String
  blockStyleName: String
  trackID: String
}

type Stats {
  articlesCount: Int!
  authorsCount: Int!
  firstArticleDate: DateTime
}

type StreamableVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  videoID: String
}

input StreamableVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  videoID: String
}

enum StripePaymentMethod {
  ACSS_DEBIT
  AFTERPAY_CLEARPAY
  ALIPAY
  AU_BECS_DEBIT
  BACS_DEBIT
  BANCONTACT
  BOLETO
  CARD
  EPS
  FPX
  GIROPAY
  GRABPAY
  IDEAL
  KLARNA
  KONBINI
  OXXO
  P24
  PAYNOW
  SEPA_DEBIT
  SOFORT
  US_BANK_ACCOUNT
  WECHAT_PAY
}

type SubscribeBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  fields: [SubscribeBlockField!]!
  memberPlanIds: [String!]
  memberPlans: [MemberPlan!]!
  type: BlockType!
}

enum SubscribeBlockField {
  Address
  Birthday
  EmailRepeated
  FirstName
  Password
  PasswordRepeated
}

input SubscribeBlockInput {
  blockStyle: String
  blockStyleName: String
  fields: [SubscribeBlockField!]! = [FirstName, Password, PasswordRepeated, Address]
  memberPlanIds: [String!]
}

type SubscriptionCreatedAction implements BaseAction & HasSubscriptionLc {
  actionType: ActionType!
  date: DateTime!
  subscription: PublicSubscription!
  subscriptionId: String!
}

type SubscriptionDeactivation {
  date: DateTime!
  reason: SubscriptionDeactivationReason!
}

enum SubscriptionDeactivationReason {
  invoiceNotPaid
  none
  userReplacedSubscription
  userSelfDeactivated
}

enum SubscriptionEvent {
  CONFIRM_SUBSCRIPTION
  CUSTOM
  DEACTIVATION_BY_USER
  DEACTIVATION_UNPAID
  INVOICE_CREATION
  RENEWAL_FAILED
  RENEWAL_SUCCESS
  SUBSCRIBE
}

type SubscriptionFlowModel {
  autoRenewal: [Boolean!]!
  default: Boolean!
  id: String!
  intervals: [SubscriptionInterval!]!
  memberPlan: MemberPlan
  numberOfSubscriptions: Int!
  paymentMethods: [PaymentMethod!]!
  periodicities: [PaymentPeriodicity!]!
}

type SubscriptionInterval {
  daysAwayFromEnding: Int
  event: SubscriptionEvent!
  id: String!
  mailTemplate: MailTemplateRef
}

type SystemMailModel {
  event: UserEvent!
  mailTemplate: MailTemplateRef
}

type Tag {
  description: RichText
  id: String!
  main: Boolean!
  tag: String
  type: TagType!
  url: String!
}

type TagConnection {
  nodes: [Tag!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TagFilter {
  tag: String
  tags: [String!]
  type: TagType
}

enum TagSort {
  CreatedAt
  ModifiedAt
  Tag
}

"""Type of tag."""
enum TagType {
  Article
  Author
  Comment
  Event
  Page
}

union Teaser = ArticleTeaser | CustomTeaser | EventTeaser | PageTeaser

type TeaserGridBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  numColumns: Int!
  teasers: [Teaser]!
  type: BlockType!
}

input TeaserGridBlockInput {
  blockStyle: String
  blockStyleName: String
  numColumns: Int!
  teasers: [TeaserInput]!
}

type TeaserGridFlexBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  flexTeasers: [FlexTeaser!]!
  type: BlockType!
}

input TeaserGridFlexBlockInput {
  blockStyle: String
  blockStyleName: String
  flexTeasers: [FlexTeaserInput!]!
}

input TeaserInput {
  article: ArticleTeaserInput
  custom: CustomTeaserInput
  event: EventTeaserInput
  page: PageTeaserInput
}

type TeaserListBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  filter: TeaserListBlockFilter!
  skip: Int
  sort: TeaserListBlockSort
  take: Int
  teaserType: TeaserType!
  teasers: [Teaser]!
  title: String
  type: BlockType!
}

type TeaserListBlockFilter {
  tagObjects: [Tag!]!
  tags: [String!]
}

input TeaserListBlockFilterInput {
  tags: [String!] = []
}

input TeaserListBlockInput {
  blockStyle: String
  blockStyleName: String
  filter: TeaserListBlockFilterInput!
  skip: Int
  sort: TeaserListBlockSort
  take: Int
  teaserType: TeaserType!
  title: String
}

enum TeaserListBlockSort {
  HotAndTrending
  PublishedAt
  UpdatedAt
}

type TeaserSlot {
  teaser: Teaser
  type: TeaserSlotType!
}

input TeaserSlotInput {
  teaser: TeaserInput
  type: TeaserSlotType! = Autofill
}

enum TeaserSlotType {
  Autofill
  Manual
}

type TeaserSlotsAutofillConfig implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  enabled: Boolean!
  filter: TeaserListBlockFilter
  sort: TeaserListBlockSort
  teaserType: TeaserType
  type: BlockType!
}

input TeaserSlotsAutofillConfigInput {
  enabled: Boolean!
  filter: TeaserListBlockFilterInput
  sort: TeaserListBlockSort
  teaserType: TeaserType
}

type TeaserSlotsBlock implements BaseBlock {
  autofillConfig: TeaserSlotsAutofillConfig!
  autofillTeasers: [Teaser!]!
  blockStyle: String
  blockStyleName: String
  slots: [TeaserSlot!]!
  teasers: [Teaser]!
  title: String
  type: BlockType!
}

input TeaserSlotsBlockInput {
  autofillConfig: TeaserSlotsAutofillConfigInput!
  blockStyle: String
  blockStyleName: String
  slots: [TeaserSlotInput!]!
  title: String
}

enum TeaserType {
  Article
  Custom
  Event
  Page
}

type TikTokVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  userID: String
  videoID: String
}

input TikTokVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  userID: String
  videoID: String
}

type TitleBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  lead: String
  preTitle: String
  title: String
  type: BlockType!
}

input TitleBlockInput {
  blockStyle: String
  blockStyleName: String
  lead: String
  preTitle: String
  title: String
}

type Token implements BaseToken {
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String!
}

type TokenWithSecret implements BaseToken {
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  name: String!
  token: String!
}

type TrackingPixel {
  error: String
  id: String!
  pixelUid: String
  trackingPixelMethod: TrackingPixelMethod!
  uri: String
}

type TrackingPixelMethod {
  id: String!
  trackingPixelProviderID: String!
  trackingPixelProviderType: TrackingPixelProviderType!
}

enum TrackingPixelProviderType {
  prolitteris
}

type TwitterTweetBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  tweetID: String
  type: BlockType!
  userID: String
}

input TwitterTweetBlockInput {
  blockStyle: String
  blockStyleName: String
  tweetID: String
  userID: String
}

type UnknownBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
}

input UpdateBannerInput {
  actions: [CreateBannerActionInput!]
  active: Boolean!
  cta: String
  delay: Int!
  html: String
  id: String!
  imageId: String
  showForLoginStatus: LoginStatus!
  showOnArticles: Boolean!
  showOnPages: [PageModelInput!]
  text: String!
  title: String!
}

input UpdateCommentRatingSystemAnswerInput {
  answer: String
  id: String!
  type: RatingSystemType
}

input UpdateCrowdfundingInput {
  additionalRevenue: Float
  countSubscriptionsFrom: DateTime
  countSubscriptionsUntil: DateTime
  goalType: CrowdfundingGoalType
  goals: [CreateCrowdfundingGoalInput!]
  id: String!
  memberPlans: [CreateCrowdfundingMemberPlan!]
  name: String
}

type UpgradeSubscription {
  discountAmount: Float!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User implements BaseUser {
  active: Boolean!
  firstName: String
  flair: String
  id: String!
  image: Image
  name: String!
  properties: [Property!]!
  roleIDs: [String!]!
  userImageID: String
}

type UserAddress {
  city: String
  company: String
  country: String
  streetAddress: String
  streetAddress2: String
  streetAddress2Number: String
  streetAddressNumber: String
  zipCode: String
}

input UserAddressInput {
  city: String
  company: String
  country: String
  streetAddress: String
  streetAddress2: String
  streetAddress2Number: String
  streetAddressNumber: String
  zipCode: String
}

type UserConsent {
  consent: Consent!
  createdAt: DateTime!
  id: String!
  modifiedAt: DateTime!
  user: User!
  value: Boolean!
}

type UserCreatedAction implements BaseAction & HasUserLc {
  actionType: ActionType!
  date: DateTime!
  user: User!
  userId: String!
}

enum UserEvent {
  ACCOUNT_CREATION
  LOGIN_LINK
  PASSWORD_RESET
  TEST_MAIL
}

input UserInput {
  address: UserAddressInput
  birthday: DateTime
  email: String!
  firstName: String
  flair: String
  name: String!
}

type UserRole {
  createdAt: DateTime!
  description: String
  id: String!
  modifiedAt: DateTime!
  name: String!
  permissionIDs: [String!]!
  permissions: [Permission!]!
  systemRole: Boolean!
}

input UserRoleFilter {
  name: String
}

enum UserRoleSort {
  CreatedAt
  ModifiedAt
}

input UserSubscriptionInput {
  autoRenew: Boolean!
  id: String!
  memberPlanID: String!
  monthlyAmount: Int!
  paymentMethodID: String!
  paymentPeriodicity: PaymentPeriodicity!
}

type VersionInformation {
  version: String!
}

type VimeoVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  videoID: String
}

input VimeoVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  videoID: String
}

"""A valid vote value"""
scalar VoteValue

type YouTubeVideoBlock implements BaseBlock {
  blockStyle: String
  blockStyleName: String
  type: BlockType!
  videoID: String
}

input YouTubeVideoBlockInput {
  blockStyle: String
  blockStyleName: String
  videoID: String
}