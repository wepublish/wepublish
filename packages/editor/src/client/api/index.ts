// THIS FILE IS AUTOGENERATED, EDIT WITH CAUTION
import {Node} from 'slate'
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  DateTime: string;
  /** A hexidecimal color value. */
  Color: string;
  RichText: Node[];
  Slug: string;
  /** The `Upload` scalar type represents a file upload. */
  Upload: File;
};

export type Article = {
  __typename?: 'Article';
  id: Scalars['ID'];
  shared: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  draft?: Maybe<ArticleRevision>;
  published?: Maybe<ArticleRevision>;
  pending?: Maybe<ArticleRevision>;
  latest: ArticleRevision;
};

export type ArticleConnection = {
  __typename?: 'ArticleConnection';
  nodes: Array<Article>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ArticleFilter = {
  title?: Maybe<Scalars['String']>;
  draft?: Maybe<Scalars['Boolean']>;
  published?: Maybe<Scalars['Boolean']>;
  pending?: Maybe<Scalars['Boolean']>;
  authors?: Maybe<Array<Scalars['ID']>>;
  tags?: Maybe<Array<Scalars['String']>>;
};

export type ArticleInput = {
  slug: Scalars['Slug'];
  preTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  lead?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  properties: Array<PropertiesInput>;
  imageID?: Maybe<Scalars['ID']>;
  authorIDs: Array<Scalars['ID']>;
  shared: Scalars['Boolean'];
  breaking: Scalars['Boolean'];
  hideAuthor: Scalars['Boolean'];
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaAuthorIDs: Array<Scalars['ID']>;
  socialMediaImageID?: Maybe<Scalars['ID']>;
  blocks: Array<BlockInput>;
};

export type ArticleNavigationLink = BaseNavigationLink & {
  __typename?: 'ArticleNavigationLink';
  label: Scalars['String'];
  article?: Maybe<Article>;
};

export type ArticleNavigationLinkInput = {
  label: Scalars['String'];
  articleID: Scalars['ID'];
};

export type ArticleRevision = {
  __typename?: 'ArticleRevision';
  revision: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
  hideAuthor: Scalars['Boolean'];
  preTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  lead?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  tags: Array<Scalars['String']>;
  properties: Array<Properties>;
  image?: Maybe<Image>;
  authors: Array<Maybe<Author>>;
  breaking: Scalars['Boolean'];
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaAuthors: Array<Author>;
  socialMediaImage?: Maybe<Image>;
  blocks: Array<Block>;
};

export enum ArticleSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT',
  PublishAt = 'PUBLISH_AT',
  PublishedAt = 'PUBLISHED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type ArticleTeaser = {
  __typename?: 'ArticleTeaser';
  style: TeaserStyle;
  image?: Maybe<Image>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  article?: Maybe<Article>;
};

export type ArticleTeaserInput = {
  style: TeaserStyle;
  imageID?: Maybe<Scalars['ID']>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  articleID: Scalars['ID'];
};

export type Author = {
  __typename?: 'Author';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['Slug'];
  url: Scalars['String'];
  links?: Maybe<Array<AuthorLink>>;
  bio?: Maybe<Scalars['RichText']>;
  image?: Maybe<Image>;
};

export type AuthorConnection = {
  __typename?: 'AuthorConnection';
  nodes: Array<Author>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type AuthorFilter = {
  name?: Maybe<Scalars['String']>;
};

export type AuthorInput = {
  name: Scalars['String'];
  slug: Scalars['Slug'];
  links?: Maybe<Array<AuthorLinkInput>>;
  bio?: Maybe<Scalars['RichText']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type AuthorLink = {
  __typename?: 'AuthorLink';
  title: Scalars['String'];
  url: Scalars['String'];
};

export type AuthorLinkInput = {
  title: Scalars['String'];
  url: Scalars['String'];
};

export enum AuthorSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export type AuthProvider = {
  __typename?: 'AuthProvider';
  name: Scalars['String'];
  url: Scalars['String'];
};

export type BaseNavigationLink = {
  label: Scalars['String'];
};

export type Block = RichTextBlock | ImageBlock | ImageGalleryBlock | ListicleBlock | FacebookPostBlock | FacebookVideoBlock | InstagramPostBlock | TwitterTweetBlock | VimeoVideoBlock | YouTubeVideoBlock | SoundCloudTrackBlock | EmbedBlock | LinkPageBreakBlock | TitleBlock | QuoteBlock | TeaserGridBlock;

export type BlockInput = {
  richText?: Maybe<RichTextBlockInput>;
  image?: Maybe<ImageBlockInput>;
  imageGallery?: Maybe<ImageGalleryBlockInput>;
  listicle?: Maybe<ListicleBlockInput>;
  title?: Maybe<TitleBlockInput>;
  quote?: Maybe<QuoteBlockInput>;
  facebookPost?: Maybe<FacebookPostBlockInput>;
  facebookVideo?: Maybe<FacebookVideoBlockInput>;
  instagramPost?: Maybe<InstagramPostBlockInput>;
  twitterTweet?: Maybe<TwitterTweetBlockInput>;
  vimeoVideo?: Maybe<VimeoVideoBlockInput>;
  youTubeVideo?: Maybe<YouTubeVideoBlockInput>;
  soundCloudTrack?: Maybe<SoundCloudTrackBlockInput>;
  embed?: Maybe<EmbedBlockInput>;
  linkPageBreak?: Maybe<LinkPageBreakBlockInput>;
  teaserGrid?: Maybe<TeaserGridBlockInput>;
};


export type Comment = {
  __typename?: 'Comment';
  id: Scalars['ID'];
  userID: User;
  authorType: CommentAuthorType;
  itemID: Scalars['ID'];
  itemType: CommentItemType;
  parentID?: Maybe<Scalars['ID']>;
  revisions: Array<CommentRevision>;
  state: CommentState;
  rejectionReason?: Maybe<CommentRejectionReason>;
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
};

export enum CommentAuthorType {
  Author = 'Author',
  Team = 'Team',
  VerifiedUser = 'VerifiedUser'
}

export type CommentConnection = {
  __typename?: 'CommentConnection';
  nodes: Array<Comment>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type CommentFilter = {
  state?: Maybe<CommentState>;
};

export enum CommentItemType {
  Article = 'Article',
  Page = 'Page'
}

export enum CommentRejectionReason {
  Misconduct = 'Misconduct',
  Spam = 'Spam'
}

export type CommentRevision = {
  __typename?: 'CommentRevision';
  text: Scalars['RichText'];
  createdAt: Scalars['DateTime'];
};

export enum CommentState {
  Approved = 'Approved',
  PendingApproval = 'PendingApproval',
  PendingUserChanges = 'PendingUserChanges',
  Rejected = 'Rejected'
}

export type CreatedToken = {
  __typename?: 'CreatedToken';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  token: Scalars['String'];
};

export type CreatePeerInput = {
  name: Scalars['String'];
  slug: Scalars['String'];
  hostURL: Scalars['String'];
  token: Scalars['String'];
};


export type EmbedBlock = {
  __typename?: 'EmbedBlock';
  url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  styleCustom?: Maybe<Scalars['String']>;
};

export type EmbedBlockInput = {
  url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  styleCustom?: Maybe<Scalars['String']>;
};

export type ExternalNavigationLink = BaseNavigationLink & {
  __typename?: 'ExternalNavigationLink';
  label: Scalars['String'];
  url: Scalars['String'];
};

export type ExternalNavigationLinkInput = {
  label: Scalars['String'];
  url: Scalars['String'];
};

export type FacebookPostBlock = {
  __typename?: 'FacebookPostBlock';
  userID: Scalars['String'];
  postID: Scalars['String'];
};

export type FacebookPostBlockInput = {
  userID: Scalars['String'];
  postID: Scalars['String'];
};

export type FacebookVideoBlock = {
  __typename?: 'FacebookVideoBlock';
  userID: Scalars['String'];
  videoID: Scalars['String'];
};

export type FacebookVideoBlockInput = {
  userID: Scalars['String'];
  videoID: Scalars['String'];
};

export type GalleryImageEdge = {
  __typename?: 'GalleryImageEdge';
  caption?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
};

export type GalleryImageEdgeInput = {
  caption?: Maybe<Scalars['String']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type Image = {
  __typename?: 'Image';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  filename?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  license?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  extension: Scalars['String'];
  mimeType: Scalars['String'];
  format: Scalars['String'];
  width: Scalars['Int'];
  height: Scalars['Int'];
  focalPoint?: Maybe<Point>;
  url?: Maybe<Scalars['String']>;
  transformURL?: Maybe<Scalars['String']>;
};


export type ImageTransformUrlArgs = {
  input?: Maybe<ImageTransformation>;
};

export type ImageBlock = {
  __typename?: 'ImageBlock';
  image?: Maybe<Image>;
  caption?: Maybe<Scalars['String']>;
};

export type ImageBlockInput = {
  caption?: Maybe<Scalars['String']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type ImageConnection = {
  __typename?: 'ImageConnection';
  nodes: Array<Image>;
  totalCount: Scalars['Int'];
  pageInfo: PageInfo;
};

export type ImageFilter = {
  title?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
};

export type ImageGalleryBlock = {
  __typename?: 'ImageGalleryBlock';
  images: Array<GalleryImageEdge>;
};

export type ImageGalleryBlockInput = {
  images?: Maybe<Array<Maybe<GalleryImageEdgeInput>>>;
};

export enum ImageOutput {
  Png = 'PNG',
  Jpeg = 'JPEG',
  Webp = 'WEBP'
}

export enum ImageRotation {
  Auto = 'AUTO',
  Rotate_0 = 'ROTATE_0',
  Rotate_90 = 'ROTATE_90',
  Rotate_180 = 'ROTATE_180',
  Rotate_270 = 'ROTATE_270'
}

export enum ImageSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export type ImageTransformation = {
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  rotation?: Maybe<ImageRotation>;
  quality?: Maybe<Scalars['Float']>;
  output?: Maybe<ImageOutput>;
};

export type InputPoint = {
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type InstagramPostBlock = {
  __typename?: 'InstagramPostBlock';
  postID: Scalars['String'];
};

export type InstagramPostBlockInput = {
  postID: Scalars['String'];
};

export type LinkPageBreakBlock = {
  __typename?: 'LinkPageBreakBlock';
  text?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
  linkURL?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  linkTarget?: Maybe<Scalars['String']>;
  hideButton: Scalars['Boolean'];
  styleOption?: Maybe<Scalars['String']>;
  layoutOption?: Maybe<Scalars['String']>;
  templateOption?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
};

export type LinkPageBreakBlockInput = {
  text?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
  linkURL?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  linkTarget?: Maybe<Scalars['String']>;
  hideButton: Scalars['Boolean'];
  styleOption?: Maybe<Scalars['String']>;
  templateOption?: Maybe<Scalars['String']>;
  layoutOption?: Maybe<Scalars['String']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type ListicleBlock = {
  __typename?: 'ListicleBlock';
  items: Array<ListicleItem>;
};

export type ListicleBlockInput = {
  items?: Maybe<Array<Maybe<ListicleItemInput>>>;
};

export type ListicleItem = {
  __typename?: 'ListicleItem';
  title: Scalars['String'];
  image?: Maybe<Image>;
  richText: Scalars['RichText'];
};

export type ListicleItemInput = {
  title: Scalars['String'];
  imageID?: Maybe<Scalars['ID']>;
  richText: Scalars['RichText'];
};

export type Mutation = {
  __typename?: 'Mutation';
  updatePeerProfile: PeerProfile;
  createPeer: Peer;
  updatePeer: Peer;
  deletePeer?: Maybe<Scalars['ID']>;
  createSession: SessionWithToken;
  createSessionWithJWT: SessionWithToken;
  createSessionWithOAuth2Code: SessionWithToken;
  revokeSession: Scalars['Boolean'];
  revokeActiveSession: Scalars['Boolean'];
  sessions: Array<Session>;
  sendJWTLogin: Scalars['String'];
  createToken: CreatedToken;
  deleteToken?: Maybe<Scalars['String']>;
  createUser?: Maybe<User>;
  updateUser?: Maybe<User>;
  resetUserPassword?: Maybe<User>;
  deleteUser?: Maybe<Scalars['String']>;
  createUserRole?: Maybe<UserRole>;
  updateUserRole?: Maybe<UserRole>;
  deleteUserRole?: Maybe<Scalars['String']>;
  createNavigation?: Maybe<Navigation>;
  updateNavigation?: Maybe<Navigation>;
  deleteNavigation?: Maybe<Scalars['ID']>;
  createAuthor?: Maybe<Author>;
  updateAuthor?: Maybe<Author>;
  deleteAuthor?: Maybe<Scalars['ID']>;
  uploadImage?: Maybe<Image>;
  updateImage?: Maybe<Image>;
  deleteImage?: Maybe<Scalars['Boolean']>;
  createArticle: Article;
  updateArticle?: Maybe<Article>;
  deleteArticle?: Maybe<Scalars['Boolean']>;
  publishArticle?: Maybe<Article>;
  unpublishArticle?: Maybe<Article>;
  createPage: Page;
  updatePage?: Maybe<Page>;
  deletePage?: Maybe<Scalars['Boolean']>;
  publishPage?: Maybe<Page>;
  unpublishPage?: Maybe<Page>;
};


export type MutationUpdatePeerProfileArgs = {
  input: PeerProfileInput;
};


export type MutationCreatePeerArgs = {
  input: CreatePeerInput;
};


export type MutationUpdatePeerArgs = {
  id: Scalars['ID'];
  input: UpdatePeerInput;
};


export type MutationDeletePeerArgs = {
  id: Scalars['ID'];
};


export type MutationCreateSessionArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};


export type MutationCreateSessionWithJwtArgs = {
  jwt: Scalars['String'];
};


export type MutationCreateSessionWithOAuth2CodeArgs = {
  name: Scalars['String'];
  code: Scalars['String'];
  redirectUri: Scalars['String'];
};


export type MutationRevokeSessionArgs = {
  id: Scalars['ID'];
};


export type MutationSendJwtLoginArgs = {
  url: Scalars['String'];
  email: Scalars['String'];
};


export type MutationCreateTokenArgs = {
  input: TokenInput;
};


export type MutationDeleteTokenArgs = {
  id: Scalars['ID'];
};


export type MutationCreateUserArgs = {
  input: UserInput;
  password: Scalars['String'];
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID'];
  input: UserInput;
};


export type MutationResetUserPasswordArgs = {
  id: Scalars['ID'];
  password: Scalars['String'];
  sendMail?: Maybe<Scalars['Boolean']>;
};


export type MutationDeleteUserArgs = {
  id: Scalars['ID'];
};


export type MutationCreateUserRoleArgs = {
  input: UserRoleInput;
};


export type MutationUpdateUserRoleArgs = {
  id: Scalars['ID'];
  input: UserRoleInput;
};


export type MutationDeleteUserRoleArgs = {
  id: Scalars['ID'];
};


export type MutationCreateNavigationArgs = {
  input: NavigationInput;
};


export type MutationUpdateNavigationArgs = {
  id: Scalars['ID'];
  input: NavigationInput;
};


export type MutationDeleteNavigationArgs = {
  id: Scalars['ID'];
};


export type MutationCreateAuthorArgs = {
  input: AuthorInput;
};


export type MutationUpdateAuthorArgs = {
  id: Scalars['ID'];
  input: AuthorInput;
};


export type MutationDeleteAuthorArgs = {
  id: Scalars['ID'];
};


export type MutationUploadImageArgs = {
  input: UploadImageInput;
};


export type MutationUpdateImageArgs = {
  id: Scalars['ID'];
  input: UpdateImageInput;
};


export type MutationDeleteImageArgs = {
  id: Scalars['ID'];
};


export type MutationCreateArticleArgs = {
  input: ArticleInput;
};


export type MutationUpdateArticleArgs = {
  id: Scalars['ID'];
  input: ArticleInput;
};


export type MutationDeleteArticleArgs = {
  id: Scalars['ID'];
};


export type MutationPublishArticleArgs = {
  id: Scalars['ID'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type MutationUnpublishArticleArgs = {
  id: Scalars['ID'];
};


export type MutationCreatePageArgs = {
  input: PageInput;
};


export type MutationUpdatePageArgs = {
  id: Scalars['ID'];
  input: PageInput;
};


export type MutationDeletePageArgs = {
  id: Scalars['ID'];
};


export type MutationPublishPageArgs = {
  id: Scalars['ID'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type MutationUnpublishPageArgs = {
  id: Scalars['ID'];
};

export type Navigation = {
  __typename?: 'Navigation';
  id: Scalars['ID'];
  key: Scalars['String'];
  name: Scalars['String'];
  links: Array<NavigationLink>;
};

export type NavigationInput = {
  key: Scalars['String'];
  name: Scalars['String'];
  links: Array<NavigationLinkInput>;
};

export type NavigationLink = PageNavigationLink | ArticleNavigationLink | ExternalNavigationLink;

export type NavigationLinkInput = {
  page?: Maybe<PageNavigationLinkInput>;
  article?: Maybe<ArticleNavigationLinkInput>;
  external?: Maybe<ExternalNavigationLinkInput>;
};

export type Page = {
  __typename?: 'Page';
  id: Scalars['ID'];
  shared: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  draft?: Maybe<PageRevision>;
  published?: Maybe<PageRevision>;
  pending?: Maybe<PageRevision>;
  latest: PageRevision;
};

export type PageConnection = {
  __typename?: 'PageConnection';
  nodes: Array<Page>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PageFilter = {
  title?: Maybe<Scalars['String']>;
  draft?: Maybe<Scalars['Boolean']>;
  published?: Maybe<Scalars['Boolean']>;
  pending?: Maybe<Scalars['Boolean']>;
  tags?: Maybe<Array<Scalars['String']>>;
};

export type PageInfo = {
  __typename?: 'PageInfo';
  startCursor?: Maybe<Scalars['String']>;
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
};

export type PageInput = {
  slug: Scalars['Slug'];
  title: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  properties: Array<PropertiesInput>;
  imageID?: Maybe<Scalars['ID']>;
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaImageID?: Maybe<Scalars['ID']>;
  blocks: Array<BlockInput>;
};

export type PageNavigationLink = BaseNavigationLink & {
  __typename?: 'PageNavigationLink';
  label: Scalars['String'];
  page?: Maybe<Page>;
};

export type PageNavigationLinkInput = {
  label: Scalars['String'];
  pageID: Scalars['ID'];
};

export type PageRevision = {
  __typename?: 'PageRevision';
  revision: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
  slug: Scalars['Slug'];
  title: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  properties: Array<Properties>;
  image?: Maybe<Image>;
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaImage?: Maybe<Image>;
  blocks: Array<Block>;
};

export enum PageSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT',
  PublishAt = 'PUBLISH_AT',
  PublishedAt = 'PUBLISHED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type PageTeaser = {
  __typename?: 'PageTeaser';
  style: TeaserStyle;
  image?: Maybe<Image>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  page?: Maybe<Page>;
};

export type PageTeaserInput = {
  style: TeaserStyle;
  imageID?: Maybe<Scalars['ID']>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  pageID: Scalars['ID'];
};

export type Peer = {
  __typename?: 'Peer';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['String'];
  hostURL: Scalars['String'];
  profile?: Maybe<PeerProfile>;
};

export type PeerArticle = {
  __typename?: 'PeerArticle';
  peer: Peer;
  article: Article;
};

export type PeerArticleConnection = {
  __typename?: 'PeerArticleConnection';
  nodes: Array<PeerArticle>;
  pageInfo: UnidirectionalPageInfo;
  totalCount: Scalars['Int'];
};

export type PeerArticleTeaser = {
  __typename?: 'PeerArticleTeaser';
  style: TeaserStyle;
  image?: Maybe<Image>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  peer?: Maybe<Peer>;
  articleID: Scalars['ID'];
  article?: Maybe<Article>;
};

export type PeerArticleTeaserInput = {
  style: TeaserStyle;
  imageID?: Maybe<Scalars['ID']>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  peerID: Scalars['ID'];
  articleID: Scalars['ID'];
};

export type PeerProfile = {
  __typename?: 'PeerProfile';
  name: Scalars['String'];
  logo?: Maybe<Image>;
  themeColor: Scalars['Color'];
  hostURL: Scalars['String'];
  websiteURL: Scalars['String'];
  callToActionText: Scalars['RichText'];
  callToActionURL: Scalars['String'];
};

export type PeerProfileInput = {
  name: Scalars['String'];
  logoID?: Maybe<Scalars['ID']>;
  themeColor: Scalars['Color'];
  callToActionText: Scalars['RichText'];
  callToActionURL: Scalars['String'];
};

export type Permission = {
  __typename?: 'Permission';
  id: Scalars['String'];
  description: Scalars['String'];
  deprecated: Scalars['Boolean'];
};

export type Point = {
  __typename?: 'Point';
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type Properties = {
  __typename?: 'Properties';
  key: Scalars['String'];
  value: Scalars['String'];
  public: Scalars['Boolean'];
};

export type PropertiesInput = {
  key: Scalars['String'];
  value: Scalars['String'];
  public: Scalars['Boolean'];
};

export type Query = {
  __typename?: 'Query';
  peerProfile: PeerProfile;
  peers?: Maybe<Array<Peer>>;
  peer?: Maybe<Peer>;
  me?: Maybe<User>;
  sessions: Array<Session>;
  authProviders: Array<AuthProvider>;
  user?: Maybe<User>;
  users: UserConnection;
  userRole?: Maybe<UserRole>;
  userRoles: UserRoleConnection;
  permissions?: Maybe<Array<Permission>>;
  tokens: Array<Token>;
  navigation?: Maybe<Navigation>;
  navigations: Array<Navigation>;
  author?: Maybe<Author>;
  authors: AuthorConnection;
  image?: Maybe<Image>;
  images: ImageConnection;
  comments: CommentConnection;
  article?: Maybe<Article>;
  articles: ArticleConnection;
  peerArticle?: Maybe<Article>;
  peerArticles: PeerArticleConnection;
  page?: Maybe<Page>;
  pages: PageConnection;
};


export type QueryPeerArgs = {
  id: Scalars['ID'];
};


export type QueryAuthProvidersArgs = {
  redirectUri?: Maybe<Scalars['String']>;
};


export type QueryUserArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryUsersArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<UserFilter>;
  sort?: Maybe<UserSort>;
  order?: Maybe<SortOrder>;
};


export type QueryUserRoleArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryUserRolesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<UserRoleFilter>;
  sort?: Maybe<UserRoleSort>;
  order?: Maybe<SortOrder>;
};


export type QueryNavigationArgs = {
  id?: Maybe<Scalars['ID']>;
  key?: Maybe<Scalars['ID']>;
};


export type QueryAuthorArgs = {
  id?: Maybe<Scalars['ID']>;
  slug?: Maybe<Scalars['Slug']>;
};


export type QueryAuthorsArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<AuthorFilter>;
  sort?: Maybe<AuthorSort>;
  order?: Maybe<SortOrder>;
};


export type QueryImageArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryImagesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<ImageFilter>;
  sort?: Maybe<ImageSort>;
  order?: Maybe<SortOrder>;
};


export type QueryCommentsArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<CommentFilter>;
  sort?: Maybe<ImageSort>;
  order?: Maybe<SortOrder>;
};


export type QueryArticleArgs = {
  id: Scalars['ID'];
};


export type QueryArticlesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};


export type QueryPeerArticleArgs = {
  peerID: Scalars['ID'];
  id: Scalars['ID'];
};


export type QueryPeerArticlesArgs = {
  after?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};


export type QueryPageArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryPagesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<PageFilter>;
  sort?: Maybe<PageSort>;
  order?: Maybe<SortOrder>;
};

export type QuoteBlock = {
  __typename?: 'QuoteBlock';
  quote?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
};

export type QuoteBlockInput = {
  quote?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
};


export type RichTextBlock = {
  __typename?: 'RichTextBlock';
  richText: Scalars['RichText'];
};

export type RichTextBlockInput = {
  richText: Scalars['RichText'];
};

export type Session = {
  __typename?: 'Session';
  id: Scalars['ID'];
  user: User;
  createdAt: Scalars['DateTime'];
  expiresAt: Scalars['DateTime'];
};

export type SessionWithToken = {
  __typename?: 'SessionWithToken';
  id: Scalars['ID'];
  user: User;
  token: Scalars['String'];
  createdAt: Scalars['DateTime'];
  expiresAt: Scalars['DateTime'];
};


export enum SortOrder {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

export type SoundCloudTrackBlock = {
  __typename?: 'SoundCloudTrackBlock';
  trackID: Scalars['String'];
};

export type SoundCloudTrackBlockInput = {
  trackID: Scalars['String'];
};

export type Teaser = ArticleTeaser | PeerArticleTeaser | PageTeaser;

export type TeaserGridBlock = {
  __typename?: 'TeaserGridBlock';
  teasers: Array<Maybe<Teaser>>;
  numColumns: Scalars['Int'];
};

export type TeaserGridBlockInput = {
  teasers: Array<Maybe<TeaserInput>>;
  numColumns: Scalars['Int'];
};

export type TeaserInput = {
  article?: Maybe<ArticleTeaserInput>;
  peerArticle?: Maybe<PeerArticleTeaserInput>;
  page?: Maybe<PageTeaserInput>;
};

export enum TeaserStyle {
  Default = 'DEFAULT',
  Light = 'LIGHT',
  Text = 'TEXT'
}

export type TitleBlock = {
  __typename?: 'TitleBlock';
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
};

export type TitleBlockInput = {
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
};

export type Token = {
  __typename?: 'Token';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
};

export type TokenInput = {
  name: Scalars['String'];
};

export type TwitterTweetBlock = {
  __typename?: 'TwitterTweetBlock';
  userID: Scalars['String'];
  tweetID: Scalars['String'];
};

export type TwitterTweetBlockInput = {
  userID: Scalars['String'];
  tweetID: Scalars['String'];
};

export type UnidirectionalPageInfo = {
  __typename?: 'UnidirectionalPageInfo';
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
};

export type UpdateImageInput = {
  filename?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  source?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  license?: Maybe<Scalars['String']>;
  focalPoint?: Maybe<InputPoint>;
};

export type UpdatePeerInput = {
  name: Scalars['String'];
  slug: Scalars['String'];
  hostURL: Scalars['String'];
  token?: Maybe<Scalars['String']>;
};


export type UploadImageInput = {
  file: Scalars['Upload'];
  filename?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  source?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  license?: Maybe<Scalars['String']>;
  focalPoint?: Maybe<InputPoint>;
};

export type User = {
  __typename?: 'User';
  id: Scalars['String'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  email: Scalars['String'];
  roles: Array<UserRole>;
};

export type UserConnection = {
  __typename?: 'UserConnection';
  nodes: Array<User>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserFilter = {
  name?: Maybe<Scalars['String']>;
};

export type UserInput = {
  name: Scalars['String'];
  email: Scalars['String'];
  roleIDs?: Maybe<Array<Scalars['String']>>;
};

export type UserRole = {
  __typename?: 'UserRole';
  id: Scalars['String'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  systemRole: Scalars['Boolean'];
  permissions: Array<Permission>;
};

export type UserRoleConnection = {
  __typename?: 'UserRoleConnection';
  nodes: Array<UserRole>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserRoleFilter = {
  name?: Maybe<Scalars['String']>;
};

export type UserRoleInput = {
  name: Scalars['String'];
  description: Scalars['String'];
  permissionIDs?: Maybe<Array<Scalars['String']>>;
};

export enum UserRoleSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export enum UserSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export type VimeoVideoBlock = {
  __typename?: 'VimeoVideoBlock';
  videoID: Scalars['String'];
};

export type VimeoVideoBlockInput = {
  videoID: Scalars['String'];
};

export type YouTubeVideoBlock = {
  __typename?: 'YouTubeVideoBlock';
  videoID: Scalars['String'];
};

export type YouTubeVideoBlockInput = {
  videoID: Scalars['String'];
};

export type MutationArticleFragment = (
  { __typename?: 'Article' }
  & Pick<Article, 'id'>
  & { draft?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishAt' | 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  ) }
);

export type ArticleRefFragment = (
  { __typename?: 'Article' }
  & Pick<Article, 'id' | 'createdAt' | 'modifiedAt'>
  & { draft?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision' | 'preTitle' | 'title' | 'lead'>
    & { image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  ) }
);

export type ArticleListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
}>;


export type ArticleListQuery = (
  { __typename?: 'Query' }
  & { articles: (
    { __typename?: 'ArticleConnection' }
    & Pick<ArticleConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'Article' }
      & ArticleRefFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type PeerArticleListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
}>;


export type PeerArticleListQuery = (
  { __typename?: 'Query' }
  & { peerArticles: (
    { __typename?: 'PeerArticleConnection' }
    & Pick<PeerArticleConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'PeerArticle' }
      & { peer: (
        { __typename?: 'Peer' }
        & PeerWithProfileFragment
      ), article: (
        { __typename?: 'Article' }
        & ArticleRefFragment
      ) }
    )>, pageInfo: (
      { __typename?: 'UnidirectionalPageInfo' }
      & Pick<UnidirectionalPageInfo, 'endCursor' | 'hasNextPage'>
    ) }
  ) }
);

export type CreateArticleMutationVariables = Exact<{
  input: ArticleInput;
}>;


export type CreateArticleMutation = (
  { __typename?: 'Mutation' }
  & { createArticle: (
    { __typename?: 'Article' }
    & MutationArticleFragment
  ) }
);

export type UpdateArticleMutationVariables = Exact<{
  id: Scalars['ID'];
  input: ArticleInput;
}>;


export type UpdateArticleMutation = (
  { __typename?: 'Mutation' }
  & { updateArticle?: Maybe<(
    { __typename?: 'Article' }
    & MutationArticleFragment
  )> }
);

export type PublishArticleMutationVariables = Exact<{
  id: Scalars['ID'];
  publishAt: Scalars['DateTime'];
  publishedAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
}>;


export type PublishArticleMutation = (
  { __typename?: 'Mutation' }
  & { publishArticle?: Maybe<(
    { __typename?: 'Article' }
    & MutationArticleFragment
  )> }
);

export type UnpublishArticleMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UnpublishArticleMutation = (
  { __typename?: 'Mutation' }
  & { unpublishArticle?: Maybe<(
    { __typename?: 'Article' }
    & MutationArticleFragment
  )> }
);

export type DeleteArticleMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteArticleMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteArticle'>
);

export type ArticleQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ArticleQuery = (
  { __typename?: 'Query' }
  & { article?: Maybe<(
    { __typename?: 'Article' }
    & Pick<Article, 'id' | 'shared'>
    & { pending?: Maybe<(
      { __typename?: 'ArticleRevision' }
      & Pick<ArticleRevision, 'publishAt'>
    )>, published?: Maybe<(
      { __typename?: 'ArticleRevision' }
      & Pick<ArticleRevision, 'publishedAt' | 'updatedAt'>
    )>, latest: (
      { __typename?: 'ArticleRevision' }
      & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision' | 'slug' | 'preTitle' | 'title' | 'lead' | 'tags' | 'hideAuthor' | 'breaking' | 'socialMediaTitle' | 'socialMediaDescription'>
      & { image?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, properties: Array<(
        { __typename?: 'Properties' }
        & Pick<Properties, 'key' | 'value' | 'public'>
      )>, authors: Array<Maybe<(
        { __typename?: 'Author' }
        & AuthorRefFragment
      )>>, socialMediaAuthors: Array<(
        { __typename?: 'Author' }
        & AuthorRefFragment
      )>, socialMediaImage?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, blocks: Array<(
        { __typename?: 'RichTextBlock' }
        & FullBlock_RichTextBlock_Fragment
      ) | (
        { __typename?: 'ImageBlock' }
        & FullBlock_ImageBlock_Fragment
      ) | (
        { __typename?: 'ImageGalleryBlock' }
        & FullBlock_ImageGalleryBlock_Fragment
      ) | (
        { __typename?: 'ListicleBlock' }
        & FullBlock_ListicleBlock_Fragment
      ) | (
        { __typename?: 'FacebookPostBlock' }
        & FullBlock_FacebookPostBlock_Fragment
      ) | (
        { __typename?: 'FacebookVideoBlock' }
        & FullBlock_FacebookVideoBlock_Fragment
      ) | (
        { __typename?: 'InstagramPostBlock' }
        & FullBlock_InstagramPostBlock_Fragment
      ) | (
        { __typename?: 'TwitterTweetBlock' }
        & FullBlock_TwitterTweetBlock_Fragment
      ) | (
        { __typename?: 'VimeoVideoBlock' }
        & FullBlock_VimeoVideoBlock_Fragment
      ) | (
        { __typename?: 'YouTubeVideoBlock' }
        & FullBlock_YouTubeVideoBlock_Fragment
      ) | (
        { __typename?: 'SoundCloudTrackBlock' }
        & FullBlock_SoundCloudTrackBlock_Fragment
      ) | (
        { __typename?: 'EmbedBlock' }
        & FullBlock_EmbedBlock_Fragment
      ) | (
        { __typename?: 'LinkPageBreakBlock' }
        & FullBlock_LinkPageBreakBlock_Fragment
      ) | (
        { __typename?: 'TitleBlock' }
        & FullBlock_TitleBlock_Fragment
      ) | (
        { __typename?: 'QuoteBlock' }
        & FullBlock_QuoteBlock_Fragment
      ) | (
        { __typename?: 'TeaserGridBlock' }
        & FullBlock_TeaserGridBlock_Fragment
      )> }
    ) }
  )> }
);

export type CreateSessionMutationVariables = Exact<{
  email: Scalars['String'];
  password: Scalars['String'];
}>;


export type CreateSessionMutation = (
  { __typename?: 'Mutation' }
  & { createSession: (
    { __typename?: 'SessionWithToken' }
    & Pick<SessionWithToken, 'token'>
    & { user: (
      { __typename?: 'User' }
      & Pick<User, 'email'>
      & { roles: Array<(
        { __typename?: 'UserRole' }
        & FullUserRoleFragment
      )> }
    ) }
  ) }
);

export type GetAuthProvidersQueryVariables = Exact<{
  redirectUri: Scalars['String'];
}>;


export type GetAuthProvidersQuery = (
  { __typename?: 'Query' }
  & { authProviders: Array<(
    { __typename?: 'AuthProvider' }
    & Pick<AuthProvider, 'name' | 'url'>
  )> }
);

export type CreateSessionWithOAuth2CodeMutationVariables = Exact<{
  redirectUri: Scalars['String'];
  name: Scalars['String'];
  code: Scalars['String'];
}>;


export type CreateSessionWithOAuth2CodeMutation = (
  { __typename?: 'Mutation' }
  & { createSessionWithOAuth2Code: (
    { __typename?: 'SessionWithToken' }
    & Pick<SessionWithToken, 'token'>
    & { user: (
      { __typename?: 'User' }
      & Pick<User, 'email'>
      & { roles: Array<(
        { __typename?: 'UserRole' }
        & FullUserRoleFragment
      )> }
    ) }
  ) }
);

export type CreateSessionWithJwtMutationVariables = Exact<{
  jwt: Scalars['String'];
}>;


export type CreateSessionWithJwtMutation = (
  { __typename?: 'Mutation' }
  & { createSessionWithJWT: (
    { __typename?: 'SessionWithToken' }
    & Pick<SessionWithToken, 'token'>
    & { user: (
      { __typename?: 'User' }
      & Pick<User, 'email'>
      & { roles: Array<(
        { __typename?: 'UserRole' }
        & FullUserRoleFragment
      )> }
    ) }
  ) }
);

export type AuthorRefFragment = (
  { __typename?: 'Author' }
  & Pick<Author, 'id' | 'name'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

export type FullAuthorFragment = (
  { __typename?: 'Author' }
  & Pick<Author, 'slug' | 'bio'>
  & { links?: Maybe<Array<(
    { __typename?: 'AuthorLink' }
    & Pick<AuthorLink, 'title' | 'url'>
  )>> }
  & AuthorRefFragment
);

export type AuthorListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type AuthorListQuery = (
  { __typename?: 'Query' }
  & { authors: (
    { __typename?: 'AuthorConnection' }
    & Pick<AuthorConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'Author' }
      & FullAuthorFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type AuthorQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type AuthorQuery = (
  { __typename?: 'Query' }
  & { author?: Maybe<(
    { __typename?: 'Author' }
    & FullAuthorFragment
  )> }
);

export type CreateAuthorMutationVariables = Exact<{
  input: AuthorInput;
}>;


export type CreateAuthorMutation = (
  { __typename?: 'Mutation' }
  & { createAuthor?: Maybe<(
    { __typename?: 'Author' }
    & FullAuthorFragment
  )> }
);

export type UpdateAuthorMutationVariables = Exact<{
  id: Scalars['ID'];
  input: AuthorInput;
}>;


export type UpdateAuthorMutation = (
  { __typename?: 'Mutation' }
  & { updateAuthor?: Maybe<(
    { __typename?: 'Author' }
    & FullAuthorFragment
  )> }
);

export type DeleteAuthorMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteAuthorMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteAuthor'>
);

type FullTeaser_ArticleTeaser_Fragment = (
  { __typename?: 'ArticleTeaser' }
  & Pick<ArticleTeaser, 'style' | 'preTitle' | 'title' | 'lead'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )>, article?: Maybe<(
    { __typename?: 'Article' }
    & ArticleRefFragment
  )> }
);

type FullTeaser_PeerArticleTeaser_Fragment = (
  { __typename?: 'PeerArticleTeaser' }
  & Pick<PeerArticleTeaser, 'style' | 'preTitle' | 'title' | 'lead' | 'articleID'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )>, peer?: Maybe<(
    { __typename?: 'Peer' }
    & PeerWithProfileFragment
  )>, article?: Maybe<(
    { __typename?: 'Article' }
    & ArticleRefFragment
  )> }
);

type FullTeaser_PageTeaser_Fragment = (
  { __typename?: 'PageTeaser' }
  & Pick<PageTeaser, 'style' | 'preTitle' | 'title' | 'lead'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )>, page?: Maybe<(
    { __typename?: 'Page' }
    & PageRefFragment
  )> }
);

export type FullTeaserFragment = FullTeaser_ArticleTeaser_Fragment | FullTeaser_PeerArticleTeaser_Fragment | FullTeaser_PageTeaser_Fragment;

type FullBlock_RichTextBlock_Fragment = (
  { __typename: 'RichTextBlock' }
  & Pick<RichTextBlock, 'richText'>
);

type FullBlock_ImageBlock_Fragment = (
  { __typename: 'ImageBlock' }
  & Pick<ImageBlock, 'caption'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

type FullBlock_ImageGalleryBlock_Fragment = (
  { __typename: 'ImageGalleryBlock' }
  & { images: Array<(
    { __typename?: 'GalleryImageEdge' }
    & Pick<GalleryImageEdge, 'caption'>
    & { image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  )> }
);

type FullBlock_ListicleBlock_Fragment = (
  { __typename: 'ListicleBlock' }
  & { items: Array<(
    { __typename?: 'ListicleItem' }
    & Pick<ListicleItem, 'title' | 'richText'>
    & { image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  )> }
);

type FullBlock_FacebookPostBlock_Fragment = (
  { __typename: 'FacebookPostBlock' }
  & Pick<FacebookPostBlock, 'userID' | 'postID'>
);

type FullBlock_FacebookVideoBlock_Fragment = (
  { __typename: 'FacebookVideoBlock' }
  & Pick<FacebookVideoBlock, 'userID' | 'videoID'>
);

type FullBlock_InstagramPostBlock_Fragment = (
  { __typename: 'InstagramPostBlock' }
  & Pick<InstagramPostBlock, 'postID'>
);

type FullBlock_TwitterTweetBlock_Fragment = (
  { __typename: 'TwitterTweetBlock' }
  & Pick<TwitterTweetBlock, 'userID' | 'tweetID'>
);

type FullBlock_VimeoVideoBlock_Fragment = (
  { __typename: 'VimeoVideoBlock' }
  & Pick<VimeoVideoBlock, 'videoID'>
);

type FullBlock_YouTubeVideoBlock_Fragment = (
  { __typename: 'YouTubeVideoBlock' }
  & Pick<YouTubeVideoBlock, 'videoID'>
);

type FullBlock_SoundCloudTrackBlock_Fragment = (
  { __typename: 'SoundCloudTrackBlock' }
  & Pick<SoundCloudTrackBlock, 'trackID'>
);

type FullBlock_EmbedBlock_Fragment = (
  { __typename: 'EmbedBlock' }
  & Pick<EmbedBlock, 'url' | 'title' | 'width' | 'height' | 'styleCustom'>
);

type FullBlock_LinkPageBreakBlock_Fragment = (
  { __typename: 'LinkPageBreakBlock' }
  & Pick<LinkPageBreakBlock, 'text' | 'linkText' | 'linkURL' | 'styleOption' | 'richText' | 'linkTarget' | 'hideButton' | 'templateOption' | 'layoutOption'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

type FullBlock_TitleBlock_Fragment = (
  { __typename: 'TitleBlock' }
  & Pick<TitleBlock, 'title' | 'lead'>
);

type FullBlock_QuoteBlock_Fragment = (
  { __typename: 'QuoteBlock' }
  & Pick<QuoteBlock, 'quote' | 'author'>
);

type FullBlock_TeaserGridBlock_Fragment = (
  { __typename: 'TeaserGridBlock' }
  & Pick<TeaserGridBlock, 'numColumns'>
  & { teasers: Array<Maybe<(
    { __typename?: 'ArticleTeaser' }
    & FullTeaser_ArticleTeaser_Fragment
  ) | (
    { __typename?: 'PeerArticleTeaser' }
    & FullTeaser_PeerArticleTeaser_Fragment
  ) | (
    { __typename?: 'PageTeaser' }
    & FullTeaser_PageTeaser_Fragment
  )>> }
);

export type FullBlockFragment = FullBlock_RichTextBlock_Fragment | FullBlock_ImageBlock_Fragment | FullBlock_ImageGalleryBlock_Fragment | FullBlock_ListicleBlock_Fragment | FullBlock_FacebookPostBlock_Fragment | FullBlock_FacebookVideoBlock_Fragment | FullBlock_InstagramPostBlock_Fragment | FullBlock_TwitterTweetBlock_Fragment | FullBlock_VimeoVideoBlock_Fragment | FullBlock_YouTubeVideoBlock_Fragment | FullBlock_SoundCloudTrackBlock_Fragment | FullBlock_EmbedBlock_Fragment | FullBlock_LinkPageBreakBlock_Fragment | FullBlock_TitleBlock_Fragment | FullBlock_QuoteBlock_Fragment | FullBlock_TeaserGridBlock_Fragment;

export type ImageUrLsFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'url'>
  & { largeURL: Image['transformURL'], mediumURL: Image['transformURL'], thumbURL: Image['transformURL'], squareURL: Image['transformURL'], previewURL: Image['transformURL'], column1URL: Image['transformURL'], column6URL: Image['transformURL'] }
);

export type ImageRefFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id' | 'filename' | 'extension' | 'title' | 'description' | 'width' | 'height'>
  & ImageUrLsFragment
);

export type FullImageFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id' | 'createdAt' | 'modifiedAt' | 'filename' | 'extension' | 'width' | 'height' | 'fileSize' | 'description' | 'tags' | 'author' | 'source' | 'license'>
  & { focalPoint?: Maybe<(
    { __typename?: 'Point' }
    & Pick<Point, 'x' | 'y'>
  )> }
  & ImageRefFragment
);

export type ImageListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type ImageListQuery = (
  { __typename?: 'Query' }
  & { images: (
    { __typename?: 'ImageConnection' }
    & { nodes: Array<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type ImageQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ImageQuery = (
  { __typename?: 'Query' }
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & FullImageFragment
  )> }
);

export type UploadImageMutationVariables = Exact<{
  input: UploadImageInput;
}>;


export type UploadImageMutation = (
  { __typename?: 'Mutation' }
  & { uploadImage?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

export type UpdateImageMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UpdateImageInput;
}>;


export type UpdateImageMutation = (
  { __typename?: 'Mutation' }
  & { updateImage?: Maybe<(
    { __typename?: 'Image' }
    & FullImageFragment
  )> }
);

export type DeleteImageMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteImageMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteImage'>
);

export type FullNavigationFragment = (
  { __typename?: 'Navigation' }
  & Pick<Navigation, 'id' | 'key' | 'name'>
  & { links: Array<(
    { __typename: 'PageNavigationLink' }
    & Pick<PageNavigationLink, 'label'>
    & { page?: Maybe<(
      { __typename?: 'Page' }
      & PageRefFragment
    )> }
  ) | (
    { __typename: 'ArticleNavigationLink' }
    & Pick<ArticleNavigationLink, 'label'>
    & { article?: Maybe<(
      { __typename?: 'Article' }
      & ArticleRefFragment
    )> }
  ) | (
    { __typename: 'ExternalNavigationLink' }
    & Pick<ExternalNavigationLink, 'label' | 'url'>
  )> }
);

export type NavigationListQueryVariables = Exact<{ [key: string]: never; }>;


export type NavigationListQuery = (
  { __typename?: 'Query' }
  & { navigations: Array<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type NavigationQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type NavigationQuery = (
  { __typename?: 'Query' }
  & { navigation?: Maybe<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type CreateNavigationMutationVariables = Exact<{
  input: NavigationInput;
}>;


export type CreateNavigationMutation = (
  { __typename?: 'Mutation' }
  & { createNavigation?: Maybe<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type UpdateNavigationMutationVariables = Exact<{
  id: Scalars['ID'];
  input: NavigationInput;
}>;


export type UpdateNavigationMutation = (
  { __typename?: 'Mutation' }
  & { updateNavigation?: Maybe<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type DeleteNavigationMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteNavigationMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteNavigation'>
);

export type MutationPageFragment = (
  { __typename?: 'Page' }
  & Pick<Page, 'id'>
  & { draft?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishAt' | 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  ) }
);

export type PageRefFragment = (
  { __typename?: 'Page' }
  & Pick<Page, 'id' | 'createdAt' | 'modifiedAt'>
  & { draft?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision' | 'title' | 'description'>
    & { image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  ) }
);

export type PageListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
}>;


export type PageListQuery = (
  { __typename?: 'Query' }
  & { pages: (
    { __typename?: 'PageConnection' }
    & Pick<PageConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'Page' }
      & PageRefFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type CreatePageMutationVariables = Exact<{
  input: PageInput;
}>;


export type CreatePageMutation = (
  { __typename?: 'Mutation' }
  & { createPage: (
    { __typename?: 'Page' }
    & MutationPageFragment
  ) }
);

export type UpdatePageMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PageInput;
}>;


export type UpdatePageMutation = (
  { __typename?: 'Mutation' }
  & { updatePage?: Maybe<(
    { __typename?: 'Page' }
    & MutationPageFragment
  )> }
);

export type PublishPageMutationVariables = Exact<{
  id: Scalars['ID'];
  publishAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
}>;


export type PublishPageMutation = (
  { __typename?: 'Mutation' }
  & { publishPage?: Maybe<(
    { __typename?: 'Page' }
    & MutationPageFragment
  )> }
);

export type UnpublishPageMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UnpublishPageMutation = (
  { __typename?: 'Mutation' }
  & { unpublishPage?: Maybe<(
    { __typename?: 'Page' }
    & MutationPageFragment
  )> }
);

export type DeletePageMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeletePageMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deletePage'>
);

export type PageQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PageQuery = (
  { __typename?: 'Query' }
  & { page?: Maybe<(
    { __typename?: 'Page' }
    & Pick<Page, 'id'>
    & { pending?: Maybe<(
      { __typename?: 'PageRevision' }
      & Pick<PageRevision, 'publishAt'>
    )>, published?: Maybe<(
      { __typename?: 'PageRevision' }
      & Pick<PageRevision, 'publishedAt' | 'updatedAt'>
    )>, latest: (
      { __typename?: 'PageRevision' }
      & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'slug' | 'title' | 'description' | 'tags' | 'socialMediaTitle' | 'socialMediaDescription'>
      & { image?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, properties: Array<(
        { __typename?: 'Properties' }
        & Pick<Properties, 'key' | 'value' | 'public'>
      )>, socialMediaImage?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, blocks: Array<(
        { __typename?: 'RichTextBlock' }
        & FullBlock_RichTextBlock_Fragment
      ) | (
        { __typename?: 'ImageBlock' }
        & FullBlock_ImageBlock_Fragment
      ) | (
        { __typename?: 'ImageGalleryBlock' }
        & FullBlock_ImageGalleryBlock_Fragment
      ) | (
        { __typename?: 'ListicleBlock' }
        & FullBlock_ListicleBlock_Fragment
      ) | (
        { __typename?: 'FacebookPostBlock' }
        & FullBlock_FacebookPostBlock_Fragment
      ) | (
        { __typename?: 'FacebookVideoBlock' }
        & FullBlock_FacebookVideoBlock_Fragment
      ) | (
        { __typename?: 'InstagramPostBlock' }
        & FullBlock_InstagramPostBlock_Fragment
      ) | (
        { __typename?: 'TwitterTweetBlock' }
        & FullBlock_TwitterTweetBlock_Fragment
      ) | (
        { __typename?: 'VimeoVideoBlock' }
        & FullBlock_VimeoVideoBlock_Fragment
      ) | (
        { __typename?: 'YouTubeVideoBlock' }
        & FullBlock_YouTubeVideoBlock_Fragment
      ) | (
        { __typename?: 'SoundCloudTrackBlock' }
        & FullBlock_SoundCloudTrackBlock_Fragment
      ) | (
        { __typename?: 'EmbedBlock' }
        & FullBlock_EmbedBlock_Fragment
      ) | (
        { __typename?: 'LinkPageBreakBlock' }
        & FullBlock_LinkPageBreakBlock_Fragment
      ) | (
        { __typename?: 'TitleBlock' }
        & FullBlock_TitleBlock_Fragment
      ) | (
        { __typename?: 'QuoteBlock' }
        & FullBlock_QuoteBlock_Fragment
      ) | (
        { __typename?: 'TeaserGridBlock' }
        & FullBlock_TeaserGridBlock_Fragment
      )> }
    ) }
  )> }
);

export type FullPeerProfileFragment = (
  { __typename?: 'PeerProfile' }
  & Pick<PeerProfile, 'name' | 'hostURL' | 'themeColor' | 'callToActionText' | 'callToActionURL'>
  & { logo?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

export type PeerRefFragment = (
  { __typename?: 'Peer' }
  & Pick<Peer, 'id' | 'name' | 'slug' | 'hostURL'>
);

export type PeerWithProfileFragment = (
  { __typename?: 'Peer' }
  & { profile?: Maybe<(
    { __typename?: 'PeerProfile' }
    & FullPeerProfileFragment
  )> }
  & PeerRefFragment
);

export type PeerProfileQueryVariables = Exact<{ [key: string]: never; }>;


export type PeerProfileQuery = (
  { __typename?: 'Query' }
  & { peerProfile: (
    { __typename?: 'PeerProfile' }
    & FullPeerProfileFragment
  ) }
);

export type UpdatePeerProfileMutationVariables = Exact<{
  input: PeerProfileInput;
}>;


export type UpdatePeerProfileMutation = (
  { __typename?: 'Mutation' }
  & { updatePeerProfile: (
    { __typename?: 'PeerProfile' }
    & FullPeerProfileFragment
  ) }
);

export type PeerListQueryVariables = Exact<{ [key: string]: never; }>;


export type PeerListQuery = (
  { __typename?: 'Query' }
  & { peers?: Maybe<Array<(
    { __typename?: 'Peer' }
    & PeerWithProfileFragment
  )>> }
);

export type PeerQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PeerQuery = (
  { __typename?: 'Query' }
  & { peer?: Maybe<(
    { __typename?: 'Peer' }
    & PeerRefFragment
  )> }
);

export type CreatePeerMutationVariables = Exact<{
  input: CreatePeerInput;
}>;


export type CreatePeerMutation = (
  { __typename?: 'Mutation' }
  & { createPeer: (
    { __typename?: 'Peer' }
    & PeerRefFragment
  ) }
);

export type UpdatePeerMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UpdatePeerInput;
}>;


export type UpdatePeerMutation = (
  { __typename?: 'Mutation' }
  & { updatePeer: (
    { __typename?: 'Peer' }
    & PeerRefFragment
  ) }
);

export type DeletePeerMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeletePeerMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deletePeer'>
);

export type TokenRefFragment = (
  { __typename?: 'Token' }
  & Pick<Token, 'id' | 'name'>
);

export type TokenListQueryVariables = Exact<{ [key: string]: never; }>;


export type TokenListQuery = (
  { __typename?: 'Query' }
  & { tokens: Array<(
    { __typename?: 'Token' }
    & TokenRefFragment
  )> }
);

export type CreateTokenMutationVariables = Exact<{
  input: TokenInput;
}>;


export type CreateTokenMutation = (
  { __typename?: 'Mutation' }
  & { createToken: (
    { __typename?: 'CreatedToken' }
    & Pick<CreatedToken, 'id' | 'name' | 'token'>
  ) }
);

export type DeleteTokenMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteTokenMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteToken'>
);

export type FullUserFragment = (
  { __typename?: 'User' }
  & Pick<User, 'id' | 'name' | 'email'>
  & { roles: Array<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )> }
);

export type UserListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type UserListQuery = (
  { __typename?: 'Query' }
  & { users: (
    { __typename?: 'UserConnection' }
    & Pick<UserConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'User' }
      & FullUserFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type UserQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UserQuery = (
  { __typename?: 'Query' }
  & { user?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type CreateUserMutationVariables = Exact<{
  input: UserInput;
  password: Scalars['String'];
}>;


export type CreateUserMutation = (
  { __typename?: 'Mutation' }
  & { createUser?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type UpdateUserMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UserInput;
}>;


export type UpdateUserMutation = (
  { __typename?: 'Mutation' }
  & { updateUser?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type ResetUserPasswordMutationVariables = Exact<{
  id: Scalars['ID'];
  password: Scalars['String'];
}>;


export type ResetUserPasswordMutation = (
  { __typename?: 'Mutation' }
  & { resetUserPassword?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type DeleteUserMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteUserMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteUser'>
);

export type FullPermissionFragment = (
  { __typename?: 'Permission' }
  & Pick<Permission, 'id' | 'description' | 'deprecated'>
);

export type FullUserRoleFragment = (
  { __typename?: 'UserRole' }
  & Pick<UserRole, 'id' | 'name' | 'description' | 'systemRole'>
  & { permissions: Array<(
    { __typename?: 'Permission' }
    & FullPermissionFragment
  )> }
);

export type UserRoleListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type UserRoleListQuery = (
  { __typename?: 'Query' }
  & { userRoles: (
    { __typename?: 'UserRoleConnection' }
    & Pick<UserRoleConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'UserRole' }
      & FullUserRoleFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type PermissionListQueryVariables = Exact<{ [key: string]: never; }>;


export type PermissionListQuery = (
  { __typename?: 'Query' }
  & { permissions?: Maybe<Array<(
    { __typename?: 'Permission' }
    & FullPermissionFragment
  )>> }
);

export type UserRoleQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UserRoleQuery = (
  { __typename?: 'Query' }
  & { userRole?: Maybe<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )> }
);

export type CreateUserRoleMutationVariables = Exact<{
  input: UserRoleInput;
}>;


export type CreateUserRoleMutation = (
  { __typename?: 'Mutation' }
  & { createUserRole?: Maybe<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )> }
);

export type UpdateUserRoleMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UserRoleInput;
}>;


export type UpdateUserRoleMutation = (
  { __typename?: 'Mutation' }
  & { updateUserRole?: Maybe<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )> }
);

export type DeleteUserRoleMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteUserRoleMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteUserRole'>
);

export const MutationArticleFragmentDoc = gql`
    fragment MutationArticle on Article {
  id
  draft {
    publishedAt
    updatedAt
    revision
  }
  pending {
    publishAt
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
  }
}
    `;
export const ImageUrLsFragmentDoc = gql`
    fragment ImageURLs on Image {
  url
  largeURL: transformURL(input: {width: 500})
  mediumURL: transformURL(input: {width: 300})
  thumbURL: transformURL(input: {width: 280, height: 200})
  squareURL: transformURL(input: {width: 100, height: 100})
  previewURL: transformURL(input: {width: 400, height: 200})
  column1URL: transformURL(input: {width: 800, height: 300})
  column6URL: transformURL(input: {width: 260, height: 300})
}
    `;
export const ImageRefFragmentDoc = gql`
    fragment ImageRef on Image {
  id
  filename
  extension
  title
  description
  width
  height
  ...ImageURLs
}
    ${ImageUrLsFragmentDoc}`;
export const AuthorRefFragmentDoc = gql`
    fragment AuthorRef on Author {
  id
  name
  image {
    ...ImageRef
  }
}
    ${ImageRefFragmentDoc}`;
export const FullAuthorFragmentDoc = gql`
    fragment FullAuthor on Author {
  slug
  links {
    title
    url
  }
  bio
  ...AuthorRef
}
    ${AuthorRefFragmentDoc}`;
export const ArticleRefFragmentDoc = gql`
    fragment ArticleRef on Article {
  id
  createdAt
  modifiedAt
  draft {
    revision
  }
  pending {
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
    preTitle
    title
    lead
    image {
      ...ImageRef
    }
  }
}
    ${ImageRefFragmentDoc}`;
export const PeerRefFragmentDoc = gql`
    fragment PeerRef on Peer {
  id
  name
  slug
  hostURL
}
    `;
export const FullPeerProfileFragmentDoc = gql`
    fragment FullPeerProfile on PeerProfile {
  name
  hostURL
  themeColor
  logo {
    ...ImageRef
  }
  callToActionText
  callToActionURL
}
    ${ImageRefFragmentDoc}`;
export const PeerWithProfileFragmentDoc = gql`
    fragment PeerWithProfile on Peer {
  ...PeerRef
  profile {
    ...FullPeerProfile
  }
}
    ${PeerRefFragmentDoc}
${FullPeerProfileFragmentDoc}`;
export const PageRefFragmentDoc = gql`
    fragment PageRef on Page {
  id
  createdAt
  modifiedAt
  draft {
    revision
  }
  pending {
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
    title
    description
    image {
      ...ImageRef
    }
  }
}
    ${ImageRefFragmentDoc}`;
export const FullTeaserFragmentDoc = gql`
    fragment FullTeaser on Teaser {
  ... on ArticleTeaser {
    style
    image {
      ...ImageRef
    }
    preTitle
    title
    lead
    article {
      ...ArticleRef
    }
  }
  ... on PeerArticleTeaser {
    style
    image {
      ...ImageRef
    }
    preTitle
    title
    lead
    peer {
      ...PeerWithProfile
    }
    articleID
    article {
      ...ArticleRef
    }
  }
  ... on PageTeaser {
    style
    image {
      ...ImageRef
    }
    preTitle
    title
    lead
    page {
      ...PageRef
    }
  }
}
    ${ImageRefFragmentDoc}
${ArticleRefFragmentDoc}
${PeerWithProfileFragmentDoc}
${PageRefFragmentDoc}`;
export const FullBlockFragmentDoc = gql`
    fragment FullBlock on Block {
  __typename
  ... on TitleBlock {
    title
    lead
  }
  ... on RichTextBlock {
    richText
  }
  ... on QuoteBlock {
    quote
    author
  }
  ... on LinkPageBreakBlock {
    text
    linkText
    linkURL
    styleOption
    richText
    linkTarget
    hideButton
    templateOption
    layoutOption
    image {
      ...ImageRef
    }
  }
  ... on ImageBlock {
    caption
    image {
      ...ImageRef
    }
  }
  ... on ImageGalleryBlock {
    images {
      caption
      image {
        ...ImageRef
      }
    }
  }
  ... on ListicleBlock {
    items {
      title
      image {
        ...ImageRef
      }
      richText
    }
  }
  ... on FacebookPostBlock {
    userID
    postID
  }
  ... on FacebookVideoBlock {
    userID
    videoID
  }
  ... on InstagramPostBlock {
    postID
  }
  ... on TwitterTweetBlock {
    userID
    tweetID
  }
  ... on VimeoVideoBlock {
    videoID
  }
  ... on YouTubeVideoBlock {
    videoID
  }
  ... on SoundCloudTrackBlock {
    trackID
  }
  ... on EmbedBlock {
    url
    title
    width
    height
    styleCustom
  }
  ... on TeaserGridBlock {
    teasers {
      ...FullTeaser
    }
    numColumns
  }
}
    ${ImageRefFragmentDoc}
${FullTeaserFragmentDoc}`;
export const FullImageFragmentDoc = gql`
    fragment FullImage on Image {
  id
  createdAt
  modifiedAt
  filename
  extension
  width
  height
  fileSize
  description
  tags
  author
  source
  license
  focalPoint {
    x
    y
  }
  ...ImageRef
}
    ${ImageRefFragmentDoc}`;
export const FullNavigationFragmentDoc = gql`
    fragment FullNavigation on Navigation {
  id
  key
  name
  links {
    __typename
    ... on PageNavigationLink {
      label
      page {
        ...PageRef
      }
    }
    ... on ArticleNavigationLink {
      label
      article {
        ...ArticleRef
      }
    }
    ... on ExternalNavigationLink {
      label
      url
    }
  }
}
    ${PageRefFragmentDoc}
${ArticleRefFragmentDoc}`;
export const MutationPageFragmentDoc = gql`
    fragment MutationPage on Page {
  id
  draft {
    publishedAt
    updatedAt
    revision
  }
  pending {
    publishAt
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
  }
}
    `;
export const TokenRefFragmentDoc = gql`
    fragment TokenRef on Token {
  id
  name
}
    `;
export const FullPermissionFragmentDoc = gql`
    fragment FullPermission on Permission {
  id
  description
  deprecated
}
    `;
export const FullUserRoleFragmentDoc = gql`
    fragment FullUserRole on UserRole {
  id
  name
  description
  systemRole
  permissions {
    ...FullPermission
  }
}
    ${FullPermissionFragmentDoc}`;
export const FullUserFragmentDoc = gql`
    fragment FullUser on User {
  id
  name
  email
  roles {
    ...FullUserRole
  }
}
    ${FullUserRoleFragmentDoc}`;
export const ArticleListDocument = gql`
    query ArticleList($filter: String, $after: ID, $first: Int) {
  articles(first: $first, after: $after, filter: {title: $filter}) {
    nodes {
      ...ArticleRef
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${ArticleRefFragmentDoc}`;

/**
 * __useArticleListQuery__
 *
 * To run a query within a React component, call `useArticleListQuery` and pass it any options that fit your needs.
 * When your component renders, `useArticleListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArticleListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *   },
 * });
 */
export function useArticleListQuery(baseOptions?: Apollo.QueryHookOptions<ArticleListQuery, ArticleListQueryVariables>) {
        return Apollo.useQuery<ArticleListQuery, ArticleListQueryVariables>(ArticleListDocument, baseOptions);
      }
export function useArticleListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ArticleListQuery, ArticleListQueryVariables>) {
          return Apollo.useLazyQuery<ArticleListQuery, ArticleListQueryVariables>(ArticleListDocument, baseOptions);
        }
export type ArticleListQueryHookResult = ReturnType<typeof useArticleListQuery>;
export type ArticleListLazyQueryHookResult = ReturnType<typeof useArticleListLazyQuery>;
export type ArticleListQueryResult = Apollo.QueryResult<ArticleListQuery, ArticleListQueryVariables>;
export const PeerArticleListDocument = gql`
    query PeerArticleList($filter: String, $after: ID, $first: Int) {
  peerArticles(first: $first, after: $after, filter: {title: $filter}) {
    nodes {
      peer {
        ...PeerWithProfile
      }
      article {
        ...ArticleRef
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
    totalCount
  }
}
    ${PeerWithProfileFragmentDoc}
${ArticleRefFragmentDoc}`;

/**
 * __usePeerArticleListQuery__
 *
 * To run a query within a React component, call `usePeerArticleListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerArticleListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerArticleListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *   },
 * });
 */
export function usePeerArticleListQuery(baseOptions?: Apollo.QueryHookOptions<PeerArticleListQuery, PeerArticleListQueryVariables>) {
        return Apollo.useQuery<PeerArticleListQuery, PeerArticleListQueryVariables>(PeerArticleListDocument, baseOptions);
      }
export function usePeerArticleListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerArticleListQuery, PeerArticleListQueryVariables>) {
          return Apollo.useLazyQuery<PeerArticleListQuery, PeerArticleListQueryVariables>(PeerArticleListDocument, baseOptions);
        }
export type PeerArticleListQueryHookResult = ReturnType<typeof usePeerArticleListQuery>;
export type PeerArticleListLazyQueryHookResult = ReturnType<typeof usePeerArticleListLazyQuery>;
export type PeerArticleListQueryResult = Apollo.QueryResult<PeerArticleListQuery, PeerArticleListQueryVariables>;
export const CreateArticleDocument = gql`
    mutation CreateArticle($input: ArticleInput!) {
  createArticle(input: $input) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type CreateArticleMutationFn = Apollo.MutationFunction<CreateArticleMutation, CreateArticleMutationVariables>;

/**
 * __useCreateArticleMutation__
 *
 * To run a mutation, you first call `useCreateArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createArticleMutation, { data, loading, error }] = useCreateArticleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateArticleMutation(baseOptions?: Apollo.MutationHookOptions<CreateArticleMutation, CreateArticleMutationVariables>) {
        return Apollo.useMutation<CreateArticleMutation, CreateArticleMutationVariables>(CreateArticleDocument, baseOptions);
      }
export type CreateArticleMutationHookResult = ReturnType<typeof useCreateArticleMutation>;
export type CreateArticleMutationResult = Apollo.MutationResult<CreateArticleMutation>;
export type CreateArticleMutationOptions = Apollo.BaseMutationOptions<CreateArticleMutation, CreateArticleMutationVariables>;
export const UpdateArticleDocument = gql`
    mutation UpdateArticle($id: ID!, $input: ArticleInput!) {
  updateArticle(id: $id, input: $input) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type UpdateArticleMutationFn = Apollo.MutationFunction<UpdateArticleMutation, UpdateArticleMutationVariables>;

/**
 * __useUpdateArticleMutation__
 *
 * To run a mutation, you first call `useUpdateArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateArticleMutation, { data, loading, error }] = useUpdateArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateArticleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateArticleMutation, UpdateArticleMutationVariables>) {
        return Apollo.useMutation<UpdateArticleMutation, UpdateArticleMutationVariables>(UpdateArticleDocument, baseOptions);
      }
export type UpdateArticleMutationHookResult = ReturnType<typeof useUpdateArticleMutation>;
export type UpdateArticleMutationResult = Apollo.MutationResult<UpdateArticleMutation>;
export type UpdateArticleMutationOptions = Apollo.BaseMutationOptions<UpdateArticleMutation, UpdateArticleMutationVariables>;
export const PublishArticleDocument = gql`
    mutation PublishArticle($id: ID!, $publishAt: DateTime!, $publishedAt: DateTime!, $updatedAt: DateTime!) {
  publishArticle(id: $id, publishAt: $publishAt, publishedAt: $publishedAt, updatedAt: $updatedAt) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type PublishArticleMutationFn = Apollo.MutationFunction<PublishArticleMutation, PublishArticleMutationVariables>;

/**
 * __usePublishArticleMutation__
 *
 * To run a mutation, you first call `usePublishArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePublishArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [publishArticleMutation, { data, loading, error }] = usePublishArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      publishAt: // value for 'publishAt'
 *      publishedAt: // value for 'publishedAt'
 *      updatedAt: // value for 'updatedAt'
 *   },
 * });
 */
export function usePublishArticleMutation(baseOptions?: Apollo.MutationHookOptions<PublishArticleMutation, PublishArticleMutationVariables>) {
        return Apollo.useMutation<PublishArticleMutation, PublishArticleMutationVariables>(PublishArticleDocument, baseOptions);
      }
export type PublishArticleMutationHookResult = ReturnType<typeof usePublishArticleMutation>;
export type PublishArticleMutationResult = Apollo.MutationResult<PublishArticleMutation>;
export type PublishArticleMutationOptions = Apollo.BaseMutationOptions<PublishArticleMutation, PublishArticleMutationVariables>;
export const UnpublishArticleDocument = gql`
    mutation UnpublishArticle($id: ID!) {
  unpublishArticle(id: $id) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type UnpublishArticleMutationFn = Apollo.MutationFunction<UnpublishArticleMutation, UnpublishArticleMutationVariables>;

/**
 * __useUnpublishArticleMutation__
 *
 * To run a mutation, you first call `useUnpublishArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpublishArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpublishArticleMutation, { data, loading, error }] = useUnpublishArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnpublishArticleMutation(baseOptions?: Apollo.MutationHookOptions<UnpublishArticleMutation, UnpublishArticleMutationVariables>) {
        return Apollo.useMutation<UnpublishArticleMutation, UnpublishArticleMutationVariables>(UnpublishArticleDocument, baseOptions);
      }
export type UnpublishArticleMutationHookResult = ReturnType<typeof useUnpublishArticleMutation>;
export type UnpublishArticleMutationResult = Apollo.MutationResult<UnpublishArticleMutation>;
export type UnpublishArticleMutationOptions = Apollo.BaseMutationOptions<UnpublishArticleMutation, UnpublishArticleMutationVariables>;
export const DeleteArticleDocument = gql`
    mutation DeleteArticle($id: ID!) {
  deleteArticle(id: $id)
}
    `;
export type DeleteArticleMutationFn = Apollo.MutationFunction<DeleteArticleMutation, DeleteArticleMutationVariables>;

/**
 * __useDeleteArticleMutation__
 *
 * To run a mutation, you first call `useDeleteArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteArticleMutation, { data, loading, error }] = useDeleteArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteArticleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteArticleMutation, DeleteArticleMutationVariables>) {
        return Apollo.useMutation<DeleteArticleMutation, DeleteArticleMutationVariables>(DeleteArticleDocument, baseOptions);
      }
export type DeleteArticleMutationHookResult = ReturnType<typeof useDeleteArticleMutation>;
export type DeleteArticleMutationResult = Apollo.MutationResult<DeleteArticleMutation>;
export type DeleteArticleMutationOptions = Apollo.BaseMutationOptions<DeleteArticleMutation, DeleteArticleMutationVariables>;
export const ArticleDocument = gql`
    query Article($id: ID!) {
  article(id: $id) {
    id
    shared
    pending {
      publishAt
    }
    published {
      publishedAt
      updatedAt
    }
    latest {
      publishedAt
      updatedAt
      revision
      slug
      preTitle
      title
      lead
      image {
        ...ImageRef
      }
      tags
      properties {
        key
        value
        public
      }
      authors {
        ...AuthorRef
      }
      hideAuthor
      breaking
      socialMediaTitle
      socialMediaDescription
      socialMediaAuthors {
        ...AuthorRef
      }
      socialMediaImage {
        ...ImageRef
      }
      blocks {
        ...FullBlock
      }
    }
  }
}
    ${ImageRefFragmentDoc}
${AuthorRefFragmentDoc}
${FullBlockFragmentDoc}`;

/**
 * __useArticleQuery__
 *
 * To run a query within a React component, call `useArticleQuery` and pass it any options that fit your needs.
 * When your component renders, `useArticleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArticleQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useArticleQuery(baseOptions?: Apollo.QueryHookOptions<ArticleQuery, ArticleQueryVariables>) {
        return Apollo.useQuery<ArticleQuery, ArticleQueryVariables>(ArticleDocument, baseOptions);
      }
export function useArticleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ArticleQuery, ArticleQueryVariables>) {
          return Apollo.useLazyQuery<ArticleQuery, ArticleQueryVariables>(ArticleDocument, baseOptions);
        }
export type ArticleQueryHookResult = ReturnType<typeof useArticleQuery>;
export type ArticleLazyQueryHookResult = ReturnType<typeof useArticleLazyQuery>;
export type ArticleQueryResult = Apollo.QueryResult<ArticleQuery, ArticleQueryVariables>;
export const CreateSessionDocument = gql`
    mutation CreateSession($email: String!, $password: String!) {
  createSession(email: $email, password: $password) {
    user {
      email
      roles {
        ...FullUserRole
      }
    }
    token
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateSessionMutationFn = Apollo.MutationFunction<CreateSessionMutation, CreateSessionMutationVariables>;

/**
 * __useCreateSessionMutation__
 *
 * To run a mutation, you first call `useCreateSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSessionMutation, { data, loading, error }] = useCreateSessionMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useCreateSessionMutation(baseOptions?: Apollo.MutationHookOptions<CreateSessionMutation, CreateSessionMutationVariables>) {
        return Apollo.useMutation<CreateSessionMutation, CreateSessionMutationVariables>(CreateSessionDocument, baseOptions);
      }
export type CreateSessionMutationHookResult = ReturnType<typeof useCreateSessionMutation>;
export type CreateSessionMutationResult = Apollo.MutationResult<CreateSessionMutation>;
export type CreateSessionMutationOptions = Apollo.BaseMutationOptions<CreateSessionMutation, CreateSessionMutationVariables>;
export const GetAuthProvidersDocument = gql`
    query GetAuthProviders($redirectUri: String!) {
  authProviders(redirectUri: $redirectUri) {
    name
    url
  }
}
    `;

/**
 * __useGetAuthProvidersQuery__
 *
 * To run a query within a React component, call `useGetAuthProvidersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAuthProvidersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAuthProvidersQuery({
 *   variables: {
 *      redirectUri: // value for 'redirectUri'
 *   },
 * });
 */
export function useGetAuthProvidersQuery(baseOptions?: Apollo.QueryHookOptions<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>) {
        return Apollo.useQuery<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>(GetAuthProvidersDocument, baseOptions);
      }
export function useGetAuthProvidersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>) {
          return Apollo.useLazyQuery<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>(GetAuthProvidersDocument, baseOptions);
        }
export type GetAuthProvidersQueryHookResult = ReturnType<typeof useGetAuthProvidersQuery>;
export type GetAuthProvidersLazyQueryHookResult = ReturnType<typeof useGetAuthProvidersLazyQuery>;
export type GetAuthProvidersQueryResult = Apollo.QueryResult<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>;
export const CreateSessionWithOAuth2CodeDocument = gql`
    mutation CreateSessionWithOAuth2Code($redirectUri: String!, $name: String!, $code: String!) {
  createSessionWithOAuth2Code(redirectUri: $redirectUri, name: $name, code: $code) {
    user {
      email
      roles {
        ...FullUserRole
      }
    }
    token
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateSessionWithOAuth2CodeMutationFn = Apollo.MutationFunction<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>;

/**
 * __useCreateSessionWithOAuth2CodeMutation__
 *
 * To run a mutation, you first call `useCreateSessionWithOAuth2CodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSessionWithOAuth2CodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSessionWithOAuth2CodeMutation, { data, loading, error }] = useCreateSessionWithOAuth2CodeMutation({
 *   variables: {
 *      redirectUri: // value for 'redirectUri'
 *      name: // value for 'name'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useCreateSessionWithOAuth2CodeMutation(baseOptions?: Apollo.MutationHookOptions<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>) {
        return Apollo.useMutation<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>(CreateSessionWithOAuth2CodeDocument, baseOptions);
      }
export type CreateSessionWithOAuth2CodeMutationHookResult = ReturnType<typeof useCreateSessionWithOAuth2CodeMutation>;
export type CreateSessionWithOAuth2CodeMutationResult = Apollo.MutationResult<CreateSessionWithOAuth2CodeMutation>;
export type CreateSessionWithOAuth2CodeMutationOptions = Apollo.BaseMutationOptions<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>;
export const CreateSessionWithJwtDocument = gql`
    mutation CreateSessionWithJWT($jwt: String!) {
  createSessionWithJWT(jwt: $jwt) {
    user {
      email
      roles {
        ...FullUserRole
      }
    }
    token
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateSessionWithJwtMutationFn = Apollo.MutationFunction<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>;

/**
 * __useCreateSessionWithJwtMutation__
 *
 * To run a mutation, you first call `useCreateSessionWithJwtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSessionWithJwtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSessionWithJwtMutation, { data, loading, error }] = useCreateSessionWithJwtMutation({
 *   variables: {
 *      jwt: // value for 'jwt'
 *   },
 * });
 */
export function useCreateSessionWithJwtMutation(baseOptions?: Apollo.MutationHookOptions<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>) {
        return Apollo.useMutation<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>(CreateSessionWithJwtDocument, baseOptions);
      }
export type CreateSessionWithJwtMutationHookResult = ReturnType<typeof useCreateSessionWithJwtMutation>;
export type CreateSessionWithJwtMutationResult = Apollo.MutationResult<CreateSessionWithJwtMutation>;
export type CreateSessionWithJwtMutationOptions = Apollo.BaseMutationOptions<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>;
export const AuthorListDocument = gql`
    query AuthorList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  authors(filter: {name: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...FullAuthor
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullAuthorFragmentDoc}`;

/**
 * __useAuthorListQuery__
 *
 * To run a query within a React component, call `useAuthorListQuery` and pass it any options that fit your needs.
 * When your component renders, `useAuthorListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAuthorListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useAuthorListQuery(baseOptions?: Apollo.QueryHookOptions<AuthorListQuery, AuthorListQueryVariables>) {
        return Apollo.useQuery<AuthorListQuery, AuthorListQueryVariables>(AuthorListDocument, baseOptions);
      }
export function useAuthorListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AuthorListQuery, AuthorListQueryVariables>) {
          return Apollo.useLazyQuery<AuthorListQuery, AuthorListQueryVariables>(AuthorListDocument, baseOptions);
        }
export type AuthorListQueryHookResult = ReturnType<typeof useAuthorListQuery>;
export type AuthorListLazyQueryHookResult = ReturnType<typeof useAuthorListLazyQuery>;
export type AuthorListQueryResult = Apollo.QueryResult<AuthorListQuery, AuthorListQueryVariables>;
export const AuthorDocument = gql`
    query Author($id: ID!) {
  author(id: $id) {
    ...FullAuthor
  }
}
    ${FullAuthorFragmentDoc}`;

/**
 * __useAuthorQuery__
 *
 * To run a query within a React component, call `useAuthorQuery` and pass it any options that fit your needs.
 * When your component renders, `useAuthorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAuthorQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAuthorQuery(baseOptions?: Apollo.QueryHookOptions<AuthorQuery, AuthorQueryVariables>) {
        return Apollo.useQuery<AuthorQuery, AuthorQueryVariables>(AuthorDocument, baseOptions);
      }
export function useAuthorLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AuthorQuery, AuthorQueryVariables>) {
          return Apollo.useLazyQuery<AuthorQuery, AuthorQueryVariables>(AuthorDocument, baseOptions);
        }
export type AuthorQueryHookResult = ReturnType<typeof useAuthorQuery>;
export type AuthorLazyQueryHookResult = ReturnType<typeof useAuthorLazyQuery>;
export type AuthorQueryResult = Apollo.QueryResult<AuthorQuery, AuthorQueryVariables>;
export const CreateAuthorDocument = gql`
    mutation CreateAuthor($input: AuthorInput!) {
  createAuthor(input: $input) {
    ...FullAuthor
  }
}
    ${FullAuthorFragmentDoc}`;
export type CreateAuthorMutationFn = Apollo.MutationFunction<CreateAuthorMutation, CreateAuthorMutationVariables>;

/**
 * __useCreateAuthorMutation__
 *
 * To run a mutation, you first call `useCreateAuthorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAuthorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAuthorMutation, { data, loading, error }] = useCreateAuthorMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAuthorMutation(baseOptions?: Apollo.MutationHookOptions<CreateAuthorMutation, CreateAuthorMutationVariables>) {
        return Apollo.useMutation<CreateAuthorMutation, CreateAuthorMutationVariables>(CreateAuthorDocument, baseOptions);
      }
export type CreateAuthorMutationHookResult = ReturnType<typeof useCreateAuthorMutation>;
export type CreateAuthorMutationResult = Apollo.MutationResult<CreateAuthorMutation>;
export type CreateAuthorMutationOptions = Apollo.BaseMutationOptions<CreateAuthorMutation, CreateAuthorMutationVariables>;
export const UpdateAuthorDocument = gql`
    mutation UpdateAuthor($id: ID!, $input: AuthorInput!) {
  updateAuthor(id: $id, input: $input) {
    ...FullAuthor
  }
}
    ${FullAuthorFragmentDoc}`;
export type UpdateAuthorMutationFn = Apollo.MutationFunction<UpdateAuthorMutation, UpdateAuthorMutationVariables>;

/**
 * __useUpdateAuthorMutation__
 *
 * To run a mutation, you first call `useUpdateAuthorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAuthorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAuthorMutation, { data, loading, error }] = useUpdateAuthorMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAuthorMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAuthorMutation, UpdateAuthorMutationVariables>) {
        return Apollo.useMutation<UpdateAuthorMutation, UpdateAuthorMutationVariables>(UpdateAuthorDocument, baseOptions);
      }
export type UpdateAuthorMutationHookResult = ReturnType<typeof useUpdateAuthorMutation>;
export type UpdateAuthorMutationResult = Apollo.MutationResult<UpdateAuthorMutation>;
export type UpdateAuthorMutationOptions = Apollo.BaseMutationOptions<UpdateAuthorMutation, UpdateAuthorMutationVariables>;
export const DeleteAuthorDocument = gql`
    mutation DeleteAuthor($id: ID!) {
  deleteAuthor(id: $id)
}
    `;
export type DeleteAuthorMutationFn = Apollo.MutationFunction<DeleteAuthorMutation, DeleteAuthorMutationVariables>;

/**
 * __useDeleteAuthorMutation__
 *
 * To run a mutation, you first call `useDeleteAuthorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAuthorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAuthorMutation, { data, loading, error }] = useDeleteAuthorMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteAuthorMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAuthorMutation, DeleteAuthorMutationVariables>) {
        return Apollo.useMutation<DeleteAuthorMutation, DeleteAuthorMutationVariables>(DeleteAuthorDocument, baseOptions);
      }
export type DeleteAuthorMutationHookResult = ReturnType<typeof useDeleteAuthorMutation>;
export type DeleteAuthorMutationResult = Apollo.MutationResult<DeleteAuthorMutation>;
export type DeleteAuthorMutationOptions = Apollo.BaseMutationOptions<DeleteAuthorMutation, DeleteAuthorMutationVariables>;
export const ImageListDocument = gql`
    query ImageList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  images(filter: {title: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...ImageRef
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
  }
}
    ${ImageRefFragmentDoc}`;

/**
 * __useImageListQuery__
 *
 * To run a query within a React component, call `useImageListQuery` and pass it any options that fit your needs.
 * When your component renders, `useImageListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImageListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useImageListQuery(baseOptions?: Apollo.QueryHookOptions<ImageListQuery, ImageListQueryVariables>) {
        return Apollo.useQuery<ImageListQuery, ImageListQueryVariables>(ImageListDocument, baseOptions);
      }
export function useImageListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImageListQuery, ImageListQueryVariables>) {
          return Apollo.useLazyQuery<ImageListQuery, ImageListQueryVariables>(ImageListDocument, baseOptions);
        }
export type ImageListQueryHookResult = ReturnType<typeof useImageListQuery>;
export type ImageListLazyQueryHookResult = ReturnType<typeof useImageListLazyQuery>;
export type ImageListQueryResult = Apollo.QueryResult<ImageListQuery, ImageListQueryVariables>;
export const ImageDocument = gql`
    query Image($id: ID!) {
  image(id: $id) {
    ...FullImage
  }
}
    ${FullImageFragmentDoc}`;

/**
 * __useImageQuery__
 *
 * To run a query within a React component, call `useImageQuery` and pass it any options that fit your needs.
 * When your component renders, `useImageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useImageQuery(baseOptions?: Apollo.QueryHookOptions<ImageQuery, ImageQueryVariables>) {
        return Apollo.useQuery<ImageQuery, ImageQueryVariables>(ImageDocument, baseOptions);
      }
export function useImageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImageQuery, ImageQueryVariables>) {
          return Apollo.useLazyQuery<ImageQuery, ImageQueryVariables>(ImageDocument, baseOptions);
        }
export type ImageQueryHookResult = ReturnType<typeof useImageQuery>;
export type ImageLazyQueryHookResult = ReturnType<typeof useImageLazyQuery>;
export type ImageQueryResult = Apollo.QueryResult<ImageQuery, ImageQueryVariables>;
export const UploadImageDocument = gql`
    mutation UploadImage($input: UploadImageInput!) {
  uploadImage(input: $input) {
    ...ImageRef
  }
}
    ${ImageRefFragmentDoc}`;
export type UploadImageMutationFn = Apollo.MutationFunction<UploadImageMutation, UploadImageMutationVariables>;

/**
 * __useUploadImageMutation__
 *
 * To run a mutation, you first call `useUploadImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadImageMutation, { data, loading, error }] = useUploadImageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUploadImageMutation(baseOptions?: Apollo.MutationHookOptions<UploadImageMutation, UploadImageMutationVariables>) {
        return Apollo.useMutation<UploadImageMutation, UploadImageMutationVariables>(UploadImageDocument, baseOptions);
      }
export type UploadImageMutationHookResult = ReturnType<typeof useUploadImageMutation>;
export type UploadImageMutationResult = Apollo.MutationResult<UploadImageMutation>;
export type UploadImageMutationOptions = Apollo.BaseMutationOptions<UploadImageMutation, UploadImageMutationVariables>;
export const UpdateImageDocument = gql`
    mutation UpdateImage($id: ID!, $input: UpdateImageInput!) {
  updateImage(id: $id, input: $input) {
    ...FullImage
  }
}
    ${FullImageFragmentDoc}`;
export type UpdateImageMutationFn = Apollo.MutationFunction<UpdateImageMutation, UpdateImageMutationVariables>;

/**
 * __useUpdateImageMutation__
 *
 * To run a mutation, you first call `useUpdateImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateImageMutation, { data, loading, error }] = useUpdateImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateImageMutation(baseOptions?: Apollo.MutationHookOptions<UpdateImageMutation, UpdateImageMutationVariables>) {
        return Apollo.useMutation<UpdateImageMutation, UpdateImageMutationVariables>(UpdateImageDocument, baseOptions);
      }
export type UpdateImageMutationHookResult = ReturnType<typeof useUpdateImageMutation>;
export type UpdateImageMutationResult = Apollo.MutationResult<UpdateImageMutation>;
export type UpdateImageMutationOptions = Apollo.BaseMutationOptions<UpdateImageMutation, UpdateImageMutationVariables>;
export const DeleteImageDocument = gql`
    mutation DeleteImage($id: ID!) {
  deleteImage(id: $id)
}
    `;
export type DeleteImageMutationFn = Apollo.MutationFunction<DeleteImageMutation, DeleteImageMutationVariables>;

/**
 * __useDeleteImageMutation__
 *
 * To run a mutation, you first call `useDeleteImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteImageMutation, { data, loading, error }] = useDeleteImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteImageMutation(baseOptions?: Apollo.MutationHookOptions<DeleteImageMutation, DeleteImageMutationVariables>) {
        return Apollo.useMutation<DeleteImageMutation, DeleteImageMutationVariables>(DeleteImageDocument, baseOptions);
      }
export type DeleteImageMutationHookResult = ReturnType<typeof useDeleteImageMutation>;
export type DeleteImageMutationResult = Apollo.MutationResult<DeleteImageMutation>;
export type DeleteImageMutationOptions = Apollo.BaseMutationOptions<DeleteImageMutation, DeleteImageMutationVariables>;
export const NavigationListDocument = gql`
    query NavigationList {
  navigations {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;

/**
 * __useNavigationListQuery__
 *
 * To run a query within a React component, call `useNavigationListQuery` and pass it any options that fit your needs.
 * When your component renders, `useNavigationListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNavigationListQuery({
 *   variables: {
 *   },
 * });
 */
export function useNavigationListQuery(baseOptions?: Apollo.QueryHookOptions<NavigationListQuery, NavigationListQueryVariables>) {
        return Apollo.useQuery<NavigationListQuery, NavigationListQueryVariables>(NavigationListDocument, baseOptions);
      }
export function useNavigationListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NavigationListQuery, NavigationListQueryVariables>) {
          return Apollo.useLazyQuery<NavigationListQuery, NavigationListQueryVariables>(NavigationListDocument, baseOptions);
        }
export type NavigationListQueryHookResult = ReturnType<typeof useNavigationListQuery>;
export type NavigationListLazyQueryHookResult = ReturnType<typeof useNavigationListLazyQuery>;
export type NavigationListQueryResult = Apollo.QueryResult<NavigationListQuery, NavigationListQueryVariables>;
export const NavigationDocument = gql`
    query Navigation($id: ID!) {
  navigation(id: $id) {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;

/**
 * __useNavigationQuery__
 *
 * To run a query within a React component, call `useNavigationQuery` and pass it any options that fit your needs.
 * When your component renders, `useNavigationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNavigationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useNavigationQuery(baseOptions?: Apollo.QueryHookOptions<NavigationQuery, NavigationQueryVariables>) {
        return Apollo.useQuery<NavigationQuery, NavigationQueryVariables>(NavigationDocument, baseOptions);
      }
export function useNavigationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NavigationQuery, NavigationQueryVariables>) {
          return Apollo.useLazyQuery<NavigationQuery, NavigationQueryVariables>(NavigationDocument, baseOptions);
        }
export type NavigationQueryHookResult = ReturnType<typeof useNavigationQuery>;
export type NavigationLazyQueryHookResult = ReturnType<typeof useNavigationLazyQuery>;
export type NavigationQueryResult = Apollo.QueryResult<NavigationQuery, NavigationQueryVariables>;
export const CreateNavigationDocument = gql`
    mutation CreateNavigation($input: NavigationInput!) {
  createNavigation(input: $input) {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;
export type CreateNavigationMutationFn = Apollo.MutationFunction<CreateNavigationMutation, CreateNavigationMutationVariables>;

/**
 * __useCreateNavigationMutation__
 *
 * To run a mutation, you first call `useCreateNavigationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNavigationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNavigationMutation, { data, loading, error }] = useCreateNavigationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNavigationMutation(baseOptions?: Apollo.MutationHookOptions<CreateNavigationMutation, CreateNavigationMutationVariables>) {
        return Apollo.useMutation<CreateNavigationMutation, CreateNavigationMutationVariables>(CreateNavigationDocument, baseOptions);
      }
export type CreateNavigationMutationHookResult = ReturnType<typeof useCreateNavigationMutation>;
export type CreateNavigationMutationResult = Apollo.MutationResult<CreateNavigationMutation>;
export type CreateNavigationMutationOptions = Apollo.BaseMutationOptions<CreateNavigationMutation, CreateNavigationMutationVariables>;
export const UpdateNavigationDocument = gql`
    mutation UpdateNavigation($id: ID!, $input: NavigationInput!) {
  updateNavigation(id: $id, input: $input) {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;
export type UpdateNavigationMutationFn = Apollo.MutationFunction<UpdateNavigationMutation, UpdateNavigationMutationVariables>;

/**
 * __useUpdateNavigationMutation__
 *
 * To run a mutation, you first call `useUpdateNavigationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNavigationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNavigationMutation, { data, loading, error }] = useUpdateNavigationMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNavigationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNavigationMutation, UpdateNavigationMutationVariables>) {
        return Apollo.useMutation<UpdateNavigationMutation, UpdateNavigationMutationVariables>(UpdateNavigationDocument, baseOptions);
      }
export type UpdateNavigationMutationHookResult = ReturnType<typeof useUpdateNavigationMutation>;
export type UpdateNavigationMutationResult = Apollo.MutationResult<UpdateNavigationMutation>;
export type UpdateNavigationMutationOptions = Apollo.BaseMutationOptions<UpdateNavigationMutation, UpdateNavigationMutationVariables>;
export const DeleteNavigationDocument = gql`
    mutation DeleteNavigation($id: ID!) {
  deleteNavigation(id: $id)
}
    `;
export type DeleteNavigationMutationFn = Apollo.MutationFunction<DeleteNavigationMutation, DeleteNavigationMutationVariables>;

/**
 * __useDeleteNavigationMutation__
 *
 * To run a mutation, you first call `useDeleteNavigationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNavigationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNavigationMutation, { data, loading, error }] = useDeleteNavigationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteNavigationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNavigationMutation, DeleteNavigationMutationVariables>) {
        return Apollo.useMutation<DeleteNavigationMutation, DeleteNavigationMutationVariables>(DeleteNavigationDocument, baseOptions);
      }
export type DeleteNavigationMutationHookResult = ReturnType<typeof useDeleteNavigationMutation>;
export type DeleteNavigationMutationResult = Apollo.MutationResult<DeleteNavigationMutation>;
export type DeleteNavigationMutationOptions = Apollo.BaseMutationOptions<DeleteNavigationMutation, DeleteNavigationMutationVariables>;
export const PageListDocument = gql`
    query PageList($filter: String, $after: ID, $first: Int) {
  pages(first: $first, after: $after, filter: {title: $filter}) {
    nodes {
      ...PageRef
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${PageRefFragmentDoc}`;

/**
 * __usePageListQuery__
 *
 * To run a query within a React component, call `usePageListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePageListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePageListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *   },
 * });
 */
export function usePageListQuery(baseOptions?: Apollo.QueryHookOptions<PageListQuery, PageListQueryVariables>) {
        return Apollo.useQuery<PageListQuery, PageListQueryVariables>(PageListDocument, baseOptions);
      }
export function usePageListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PageListQuery, PageListQueryVariables>) {
          return Apollo.useLazyQuery<PageListQuery, PageListQueryVariables>(PageListDocument, baseOptions);
        }
export type PageListQueryHookResult = ReturnType<typeof usePageListQuery>;
export type PageListLazyQueryHookResult = ReturnType<typeof usePageListLazyQuery>;
export type PageListQueryResult = Apollo.QueryResult<PageListQuery, PageListQueryVariables>;
export const CreatePageDocument = gql`
    mutation CreatePage($input: PageInput!) {
  createPage(input: $input) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type CreatePageMutationFn = Apollo.MutationFunction<CreatePageMutation, CreatePageMutationVariables>;

/**
 * __useCreatePageMutation__
 *
 * To run a mutation, you first call `useCreatePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPageMutation, { data, loading, error }] = useCreatePageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePageMutation(baseOptions?: Apollo.MutationHookOptions<CreatePageMutation, CreatePageMutationVariables>) {
        return Apollo.useMutation<CreatePageMutation, CreatePageMutationVariables>(CreatePageDocument, baseOptions);
      }
export type CreatePageMutationHookResult = ReturnType<typeof useCreatePageMutation>;
export type CreatePageMutationResult = Apollo.MutationResult<CreatePageMutation>;
export type CreatePageMutationOptions = Apollo.BaseMutationOptions<CreatePageMutation, CreatePageMutationVariables>;
export const UpdatePageDocument = gql`
    mutation UpdatePage($id: ID!, $input: PageInput!) {
  updatePage(id: $id, input: $input) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type UpdatePageMutationFn = Apollo.MutationFunction<UpdatePageMutation, UpdatePageMutationVariables>;

/**
 * __useUpdatePageMutation__
 *
 * To run a mutation, you first call `useUpdatePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePageMutation, { data, loading, error }] = useUpdatePageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePageMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePageMutation, UpdatePageMutationVariables>) {
        return Apollo.useMutation<UpdatePageMutation, UpdatePageMutationVariables>(UpdatePageDocument, baseOptions);
      }
export type UpdatePageMutationHookResult = ReturnType<typeof useUpdatePageMutation>;
export type UpdatePageMutationResult = Apollo.MutationResult<UpdatePageMutation>;
export type UpdatePageMutationOptions = Apollo.BaseMutationOptions<UpdatePageMutation, UpdatePageMutationVariables>;
export const PublishPageDocument = gql`
    mutation PublishPage($id: ID!, $publishAt: DateTime, $publishedAt: DateTime, $updatedAt: DateTime) {
  publishPage(id: $id, publishAt: $publishAt, publishedAt: $publishedAt, updatedAt: $updatedAt) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type PublishPageMutationFn = Apollo.MutationFunction<PublishPageMutation, PublishPageMutationVariables>;

/**
 * __usePublishPageMutation__
 *
 * To run a mutation, you first call `usePublishPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePublishPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [publishPageMutation, { data, loading, error }] = usePublishPageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      publishAt: // value for 'publishAt'
 *      publishedAt: // value for 'publishedAt'
 *      updatedAt: // value for 'updatedAt'
 *   },
 * });
 */
export function usePublishPageMutation(baseOptions?: Apollo.MutationHookOptions<PublishPageMutation, PublishPageMutationVariables>) {
        return Apollo.useMutation<PublishPageMutation, PublishPageMutationVariables>(PublishPageDocument, baseOptions);
      }
export type PublishPageMutationHookResult = ReturnType<typeof usePublishPageMutation>;
export type PublishPageMutationResult = Apollo.MutationResult<PublishPageMutation>;
export type PublishPageMutationOptions = Apollo.BaseMutationOptions<PublishPageMutation, PublishPageMutationVariables>;
export const UnpublishPageDocument = gql`
    mutation UnpublishPage($id: ID!) {
  unpublishPage(id: $id) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type UnpublishPageMutationFn = Apollo.MutationFunction<UnpublishPageMutation, UnpublishPageMutationVariables>;

/**
 * __useUnpublishPageMutation__
 *
 * To run a mutation, you first call `useUnpublishPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpublishPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpublishPageMutation, { data, loading, error }] = useUnpublishPageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnpublishPageMutation(baseOptions?: Apollo.MutationHookOptions<UnpublishPageMutation, UnpublishPageMutationVariables>) {
        return Apollo.useMutation<UnpublishPageMutation, UnpublishPageMutationVariables>(UnpublishPageDocument, baseOptions);
      }
export type UnpublishPageMutationHookResult = ReturnType<typeof useUnpublishPageMutation>;
export type UnpublishPageMutationResult = Apollo.MutationResult<UnpublishPageMutation>;
export type UnpublishPageMutationOptions = Apollo.BaseMutationOptions<UnpublishPageMutation, UnpublishPageMutationVariables>;
export const DeletePageDocument = gql`
    mutation DeletePage($id: ID!) {
  deletePage(id: $id)
}
    `;
export type DeletePageMutationFn = Apollo.MutationFunction<DeletePageMutation, DeletePageMutationVariables>;

/**
 * __useDeletePageMutation__
 *
 * To run a mutation, you first call `useDeletePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePageMutation, { data, loading, error }] = useDeletePageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePageMutation(baseOptions?: Apollo.MutationHookOptions<DeletePageMutation, DeletePageMutationVariables>) {
        return Apollo.useMutation<DeletePageMutation, DeletePageMutationVariables>(DeletePageDocument, baseOptions);
      }
export type DeletePageMutationHookResult = ReturnType<typeof useDeletePageMutation>;
export type DeletePageMutationResult = Apollo.MutationResult<DeletePageMutation>;
export type DeletePageMutationOptions = Apollo.BaseMutationOptions<DeletePageMutation, DeletePageMutationVariables>;
export const PageDocument = gql`
    query Page($id: ID!) {
  page(id: $id) {
    id
    pending {
      publishAt
    }
    published {
      publishedAt
      updatedAt
    }
    latest {
      publishedAt
      updatedAt
      slug
      title
      description
      image {
        ...ImageRef
      }
      tags
      properties {
        key
        value
        public
      }
      socialMediaTitle
      socialMediaDescription
      socialMediaImage {
        ...ImageRef
      }
      blocks {
        ...FullBlock
      }
    }
  }
}
    ${ImageRefFragmentDoc}
${FullBlockFragmentDoc}`;

/**
 * __usePageQuery__
 *
 * To run a query within a React component, call `usePageQuery` and pass it any options that fit your needs.
 * When your component renders, `usePageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePageQuery(baseOptions?: Apollo.QueryHookOptions<PageQuery, PageQueryVariables>) {
        return Apollo.useQuery<PageQuery, PageQueryVariables>(PageDocument, baseOptions);
      }
export function usePageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PageQuery, PageQueryVariables>) {
          return Apollo.useLazyQuery<PageQuery, PageQueryVariables>(PageDocument, baseOptions);
        }
export type PageQueryHookResult = ReturnType<typeof usePageQuery>;
export type PageLazyQueryHookResult = ReturnType<typeof usePageLazyQuery>;
export type PageQueryResult = Apollo.QueryResult<PageQuery, PageQueryVariables>;
export const PeerProfileDocument = gql`
    query PeerProfile {
  peerProfile {
    ...FullPeerProfile
  }
}
    ${FullPeerProfileFragmentDoc}`;

/**
 * __usePeerProfileQuery__
 *
 * To run a query within a React component, call `usePeerProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerProfileQuery({
 *   variables: {
 *   },
 * });
 */
export function usePeerProfileQuery(baseOptions?: Apollo.QueryHookOptions<PeerProfileQuery, PeerProfileQueryVariables>) {
        return Apollo.useQuery<PeerProfileQuery, PeerProfileQueryVariables>(PeerProfileDocument, baseOptions);
      }
export function usePeerProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerProfileQuery, PeerProfileQueryVariables>) {
          return Apollo.useLazyQuery<PeerProfileQuery, PeerProfileQueryVariables>(PeerProfileDocument, baseOptions);
        }
export type PeerProfileQueryHookResult = ReturnType<typeof usePeerProfileQuery>;
export type PeerProfileLazyQueryHookResult = ReturnType<typeof usePeerProfileLazyQuery>;
export type PeerProfileQueryResult = Apollo.QueryResult<PeerProfileQuery, PeerProfileQueryVariables>;
export const UpdatePeerProfileDocument = gql`
    mutation UpdatePeerProfile($input: PeerProfileInput!) {
  updatePeerProfile(input: $input) {
    ...FullPeerProfile
  }
}
    ${FullPeerProfileFragmentDoc}`;
export type UpdatePeerProfileMutationFn = Apollo.MutationFunction<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>;

/**
 * __useUpdatePeerProfileMutation__
 *
 * To run a mutation, you first call `useUpdatePeerProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePeerProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePeerProfileMutation, { data, loading, error }] = useUpdatePeerProfileMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePeerProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>) {
        return Apollo.useMutation<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>(UpdatePeerProfileDocument, baseOptions);
      }
export type UpdatePeerProfileMutationHookResult = ReturnType<typeof useUpdatePeerProfileMutation>;
export type UpdatePeerProfileMutationResult = Apollo.MutationResult<UpdatePeerProfileMutation>;
export type UpdatePeerProfileMutationOptions = Apollo.BaseMutationOptions<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>;
export const PeerListDocument = gql`
    query PeerList {
  peers {
    ...PeerWithProfile
  }
}
    ${PeerWithProfileFragmentDoc}`;

/**
 * __usePeerListQuery__
 *
 * To run a query within a React component, call `usePeerListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerListQuery({
 *   variables: {
 *   },
 * });
 */
export function usePeerListQuery(baseOptions?: Apollo.QueryHookOptions<PeerListQuery, PeerListQueryVariables>) {
        return Apollo.useQuery<PeerListQuery, PeerListQueryVariables>(PeerListDocument, baseOptions);
      }
export function usePeerListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerListQuery, PeerListQueryVariables>) {
          return Apollo.useLazyQuery<PeerListQuery, PeerListQueryVariables>(PeerListDocument, baseOptions);
        }
export type PeerListQueryHookResult = ReturnType<typeof usePeerListQuery>;
export type PeerListLazyQueryHookResult = ReturnType<typeof usePeerListLazyQuery>;
export type PeerListQueryResult = Apollo.QueryResult<PeerListQuery, PeerListQueryVariables>;
export const PeerDocument = gql`
    query Peer($id: ID!) {
  peer(id: $id) {
    ...PeerRef
  }
}
    ${PeerRefFragmentDoc}`;

/**
 * __usePeerQuery__
 *
 * To run a query within a React component, call `usePeerQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePeerQuery(baseOptions?: Apollo.QueryHookOptions<PeerQuery, PeerQueryVariables>) {
        return Apollo.useQuery<PeerQuery, PeerQueryVariables>(PeerDocument, baseOptions);
      }
export function usePeerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerQuery, PeerQueryVariables>) {
          return Apollo.useLazyQuery<PeerQuery, PeerQueryVariables>(PeerDocument, baseOptions);
        }
export type PeerQueryHookResult = ReturnType<typeof usePeerQuery>;
export type PeerLazyQueryHookResult = ReturnType<typeof usePeerLazyQuery>;
export type PeerQueryResult = Apollo.QueryResult<PeerQuery, PeerQueryVariables>;
export const CreatePeerDocument = gql`
    mutation CreatePeer($input: CreatePeerInput!) {
  createPeer(input: $input) {
    ...PeerRef
  }
}
    ${PeerRefFragmentDoc}`;
export type CreatePeerMutationFn = Apollo.MutationFunction<CreatePeerMutation, CreatePeerMutationVariables>;

/**
 * __useCreatePeerMutation__
 *
 * To run a mutation, you first call `useCreatePeerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePeerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPeerMutation, { data, loading, error }] = useCreatePeerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePeerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePeerMutation, CreatePeerMutationVariables>) {
        return Apollo.useMutation<CreatePeerMutation, CreatePeerMutationVariables>(CreatePeerDocument, baseOptions);
      }
export type CreatePeerMutationHookResult = ReturnType<typeof useCreatePeerMutation>;
export type CreatePeerMutationResult = Apollo.MutationResult<CreatePeerMutation>;
export type CreatePeerMutationOptions = Apollo.BaseMutationOptions<CreatePeerMutation, CreatePeerMutationVariables>;
export const UpdatePeerDocument = gql`
    mutation UpdatePeer($id: ID!, $input: UpdatePeerInput!) {
  updatePeer(id: $id, input: $input) {
    ...PeerRef
  }
}
    ${PeerRefFragmentDoc}`;
export type UpdatePeerMutationFn = Apollo.MutationFunction<UpdatePeerMutation, UpdatePeerMutationVariables>;

/**
 * __useUpdatePeerMutation__
 *
 * To run a mutation, you first call `useUpdatePeerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePeerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePeerMutation, { data, loading, error }] = useUpdatePeerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePeerMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePeerMutation, UpdatePeerMutationVariables>) {
        return Apollo.useMutation<UpdatePeerMutation, UpdatePeerMutationVariables>(UpdatePeerDocument, baseOptions);
      }
export type UpdatePeerMutationHookResult = ReturnType<typeof useUpdatePeerMutation>;
export type UpdatePeerMutationResult = Apollo.MutationResult<UpdatePeerMutation>;
export type UpdatePeerMutationOptions = Apollo.BaseMutationOptions<UpdatePeerMutation, UpdatePeerMutationVariables>;
export const DeletePeerDocument = gql`
    mutation DeletePeer($id: ID!) {
  deletePeer(id: $id)
}
    `;
export type DeletePeerMutationFn = Apollo.MutationFunction<DeletePeerMutation, DeletePeerMutationVariables>;

/**
 * __useDeletePeerMutation__
 *
 * To run a mutation, you first call `useDeletePeerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePeerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePeerMutation, { data, loading, error }] = useDeletePeerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePeerMutation(baseOptions?: Apollo.MutationHookOptions<DeletePeerMutation, DeletePeerMutationVariables>) {
        return Apollo.useMutation<DeletePeerMutation, DeletePeerMutationVariables>(DeletePeerDocument, baseOptions);
      }
export type DeletePeerMutationHookResult = ReturnType<typeof useDeletePeerMutation>;
export type DeletePeerMutationResult = Apollo.MutationResult<DeletePeerMutation>;
export type DeletePeerMutationOptions = Apollo.BaseMutationOptions<DeletePeerMutation, DeletePeerMutationVariables>;
export const TokenListDocument = gql`
    query TokenList {
  tokens {
    ...TokenRef
  }
}
    ${TokenRefFragmentDoc}`;

/**
 * __useTokenListQuery__
 *
 * To run a query within a React component, call `useTokenListQuery` and pass it any options that fit your needs.
 * When your component renders, `useTokenListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTokenListQuery({
 *   variables: {
 *   },
 * });
 */
export function useTokenListQuery(baseOptions?: Apollo.QueryHookOptions<TokenListQuery, TokenListQueryVariables>) {
        return Apollo.useQuery<TokenListQuery, TokenListQueryVariables>(TokenListDocument, baseOptions);
      }
export function useTokenListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TokenListQuery, TokenListQueryVariables>) {
          return Apollo.useLazyQuery<TokenListQuery, TokenListQueryVariables>(TokenListDocument, baseOptions);
        }
export type TokenListQueryHookResult = ReturnType<typeof useTokenListQuery>;
export type TokenListLazyQueryHookResult = ReturnType<typeof useTokenListLazyQuery>;
export type TokenListQueryResult = Apollo.QueryResult<TokenListQuery, TokenListQueryVariables>;
export const CreateTokenDocument = gql`
    mutation CreateToken($input: TokenInput!) {
  createToken(input: $input) {
    id
    name
    token
  }
}
    `;
export type CreateTokenMutationFn = Apollo.MutationFunction<CreateTokenMutation, CreateTokenMutationVariables>;

/**
 * __useCreateTokenMutation__
 *
 * To run a mutation, you first call `useCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTokenMutation, { data, loading, error }] = useCreateTokenMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<CreateTokenMutation, CreateTokenMutationVariables>) {
        return Apollo.useMutation<CreateTokenMutation, CreateTokenMutationVariables>(CreateTokenDocument, baseOptions);
      }
export type CreateTokenMutationHookResult = ReturnType<typeof useCreateTokenMutation>;
export type CreateTokenMutationResult = Apollo.MutationResult<CreateTokenMutation>;
export type CreateTokenMutationOptions = Apollo.BaseMutationOptions<CreateTokenMutation, CreateTokenMutationVariables>;
export const DeleteTokenDocument = gql`
    mutation DeleteToken($id: ID!) {
  deleteToken(id: $id)
}
    `;
export type DeleteTokenMutationFn = Apollo.MutationFunction<DeleteTokenMutation, DeleteTokenMutationVariables>;

/**
 * __useDeleteTokenMutation__
 *
 * To run a mutation, you first call `useDeleteTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTokenMutation, { data, loading, error }] = useDeleteTokenMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteTokenMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTokenMutation, DeleteTokenMutationVariables>) {
        return Apollo.useMutation<DeleteTokenMutation, DeleteTokenMutationVariables>(DeleteTokenDocument, baseOptions);
      }
export type DeleteTokenMutationHookResult = ReturnType<typeof useDeleteTokenMutation>;
export type DeleteTokenMutationResult = Apollo.MutationResult<DeleteTokenMutation>;
export type DeleteTokenMutationOptions = Apollo.BaseMutationOptions<DeleteTokenMutation, DeleteTokenMutationVariables>;
export const UserListDocument = gql`
    query UserList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  users(filter: {name: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...FullUser
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullUserFragmentDoc}`;

/**
 * __useUserListQuery__
 *
 * To run a query within a React component, call `useUserListQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useUserListQuery(baseOptions?: Apollo.QueryHookOptions<UserListQuery, UserListQueryVariables>) {
        return Apollo.useQuery<UserListQuery, UserListQueryVariables>(UserListDocument, baseOptions);
      }
export function useUserListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserListQuery, UserListQueryVariables>) {
          return Apollo.useLazyQuery<UserListQuery, UserListQueryVariables>(UserListDocument, baseOptions);
        }
export type UserListQueryHookResult = ReturnType<typeof useUserListQuery>;
export type UserListLazyQueryHookResult = ReturnType<typeof useUserListLazyQuery>;
export type UserListQueryResult = Apollo.QueryResult<UserListQuery, UserListQueryVariables>;
export const UserDocument = gql`
    query User($id: ID!) {
  user(id: $id) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserQuery(baseOptions?: Apollo.QueryHookOptions<UserQuery, UserQueryVariables>) {
        return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
      }
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
          return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
        }
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export const CreateUserDocument = gql`
    mutation CreateUser($input: UserInput!, $password: String!) {
  createUser(input: $input, password: $password) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;
export type CreateUserMutationFn = Apollo.MutationFunction<CreateUserMutation, CreateUserMutationVariables>;

/**
 * __useCreateUserMutation__
 *
 * To run a mutation, you first call `useCreateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserMutation, { data, loading, error }] = useCreateUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useCreateUserMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserMutation, CreateUserMutationVariables>) {
        return Apollo.useMutation<CreateUserMutation, CreateUserMutationVariables>(CreateUserDocument, baseOptions);
      }
export type CreateUserMutationHookResult = ReturnType<typeof useCreateUserMutation>;
export type CreateUserMutationResult = Apollo.MutationResult<CreateUserMutation>;
export type CreateUserMutationOptions = Apollo.BaseMutationOptions<CreateUserMutation, CreateUserMutationVariables>;
export const UpdateUserDocument = gql`
    mutation UpdateUser($id: ID!, $input: UserInput!) {
  updateUser(id: $id, input: $input) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;
export type UpdateUserMutationFn = Apollo.MutationFunction<UpdateUserMutation, UpdateUserMutationVariables>;

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserMutation, UpdateUserMutationVariables>) {
        return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, baseOptions);
      }
export type UpdateUserMutationHookResult = ReturnType<typeof useUpdateUserMutation>;
export type UpdateUserMutationResult = Apollo.MutationResult<UpdateUserMutation>;
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<UpdateUserMutation, UpdateUserMutationVariables>;
export const ResetUserPasswordDocument = gql`
    mutation ResetUserPassword($id: ID!, $password: String!) {
  resetUserPassword(id: $id, password: $password) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;
export type ResetUserPasswordMutationFn = Apollo.MutationFunction<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>;

/**
 * __useResetUserPasswordMutation__
 *
 * To run a mutation, you first call `useResetUserPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetUserPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetUserPasswordMutation, { data, loading, error }] = useResetUserPasswordMutation({
 *   variables: {
 *      id: // value for 'id'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useResetUserPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>) {
        return Apollo.useMutation<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>(ResetUserPasswordDocument, baseOptions);
      }
export type ResetUserPasswordMutationHookResult = ReturnType<typeof useResetUserPasswordMutation>;
export type ResetUserPasswordMutationResult = Apollo.MutationResult<ResetUserPasswordMutation>;
export type ResetUserPasswordMutationOptions = Apollo.BaseMutationOptions<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>;
export const DeleteUserDocument = gql`
    mutation DeleteUser($id: ID!) {
  deleteUser(id: $id)
}
    `;
export type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>) {
        return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, baseOptions);
      }
export type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export const UserRoleListDocument = gql`
    query UserRoleList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  userRoles(filter: {name: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...FullUserRole
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullUserRoleFragmentDoc}`;

/**
 * __useUserRoleListQuery__
 *
 * To run a query within a React component, call `useUserRoleListQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserRoleListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserRoleListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useUserRoleListQuery(baseOptions?: Apollo.QueryHookOptions<UserRoleListQuery, UserRoleListQueryVariables>) {
        return Apollo.useQuery<UserRoleListQuery, UserRoleListQueryVariables>(UserRoleListDocument, baseOptions);
      }
export function useUserRoleListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserRoleListQuery, UserRoleListQueryVariables>) {
          return Apollo.useLazyQuery<UserRoleListQuery, UserRoleListQueryVariables>(UserRoleListDocument, baseOptions);
        }
export type UserRoleListQueryHookResult = ReturnType<typeof useUserRoleListQuery>;
export type UserRoleListLazyQueryHookResult = ReturnType<typeof useUserRoleListLazyQuery>;
export type UserRoleListQueryResult = Apollo.QueryResult<UserRoleListQuery, UserRoleListQueryVariables>;
export const PermissionListDocument = gql`
    query PermissionList {
  permissions {
    ...FullPermission
  }
}
    ${FullPermissionFragmentDoc}`;

/**
 * __usePermissionListQuery__
 *
 * To run a query within a React component, call `usePermissionListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePermissionListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePermissionListQuery({
 *   variables: {
 *   },
 * });
 */
export function usePermissionListQuery(baseOptions?: Apollo.QueryHookOptions<PermissionListQuery, PermissionListQueryVariables>) {
        return Apollo.useQuery<PermissionListQuery, PermissionListQueryVariables>(PermissionListDocument, baseOptions);
      }
export function usePermissionListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PermissionListQuery, PermissionListQueryVariables>) {
          return Apollo.useLazyQuery<PermissionListQuery, PermissionListQueryVariables>(PermissionListDocument, baseOptions);
        }
export type PermissionListQueryHookResult = ReturnType<typeof usePermissionListQuery>;
export type PermissionListLazyQueryHookResult = ReturnType<typeof usePermissionListLazyQuery>;
export type PermissionListQueryResult = Apollo.QueryResult<PermissionListQuery, PermissionListQueryVariables>;
export const UserRoleDocument = gql`
    query UserRole($id: ID!) {
  userRole(id: $id) {
    ...FullUserRole
  }
}
    ${FullUserRoleFragmentDoc}`;

/**
 * __useUserRoleQuery__
 *
 * To run a query within a React component, call `useUserRoleQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserRoleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserRoleQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserRoleQuery(baseOptions?: Apollo.QueryHookOptions<UserRoleQuery, UserRoleQueryVariables>) {
        return Apollo.useQuery<UserRoleQuery, UserRoleQueryVariables>(UserRoleDocument, baseOptions);
      }
export function useUserRoleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserRoleQuery, UserRoleQueryVariables>) {
          return Apollo.useLazyQuery<UserRoleQuery, UserRoleQueryVariables>(UserRoleDocument, baseOptions);
        }
export type UserRoleQueryHookResult = ReturnType<typeof useUserRoleQuery>;
export type UserRoleLazyQueryHookResult = ReturnType<typeof useUserRoleLazyQuery>;
export type UserRoleQueryResult = Apollo.QueryResult<UserRoleQuery, UserRoleQueryVariables>;
export const CreateUserRoleDocument = gql`
    mutation CreateUserRole($input: UserRoleInput!) {
  createUserRole(input: $input) {
    ...FullUserRole
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateUserRoleMutationFn = Apollo.MutationFunction<CreateUserRoleMutation, CreateUserRoleMutationVariables>;

/**
 * __useCreateUserRoleMutation__
 *
 * To run a mutation, you first call `useCreateUserRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserRoleMutation, { data, loading, error }] = useCreateUserRoleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateUserRoleMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserRoleMutation, CreateUserRoleMutationVariables>) {
        return Apollo.useMutation<CreateUserRoleMutation, CreateUserRoleMutationVariables>(CreateUserRoleDocument, baseOptions);
      }
export type CreateUserRoleMutationHookResult = ReturnType<typeof useCreateUserRoleMutation>;
export type CreateUserRoleMutationResult = Apollo.MutationResult<CreateUserRoleMutation>;
export type CreateUserRoleMutationOptions = Apollo.BaseMutationOptions<CreateUserRoleMutation, CreateUserRoleMutationVariables>;
export const UpdateUserRoleDocument = gql`
    mutation UpdateUserRole($id: ID!, $input: UserRoleInput!) {
  updateUserRole(id: $id, input: $input) {
    ...FullUserRole
  }
}
    ${FullUserRoleFragmentDoc}`;
export type UpdateUserRoleMutationFn = Apollo.MutationFunction<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>;

/**
 * __useUpdateUserRoleMutation__
 *
 * To run a mutation, you first call `useUpdateUserRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserRoleMutation, { data, loading, error }] = useUpdateUserRoleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>) {
        return Apollo.useMutation<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>(UpdateUserRoleDocument, baseOptions);
      }
export type UpdateUserRoleMutationHookResult = ReturnType<typeof useUpdateUserRoleMutation>;
export type UpdateUserRoleMutationResult = Apollo.MutationResult<UpdateUserRoleMutation>;
export type UpdateUserRoleMutationOptions = Apollo.BaseMutationOptions<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>;
export const DeleteUserRoleDocument = gql`
    mutation DeleteUserRole($id: ID!) {
  deleteUserRole(id: $id)
}
    `;
export type DeleteUserRoleMutationFn = Apollo.MutationFunction<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>;

/**
 * __useDeleteUserRoleMutation__
 *
 * To run a mutation, you first call `useDeleteUserRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserRoleMutation, { data, loading, error }] = useDeleteUserRoleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserRoleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>) {
        return Apollo.useMutation<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>(DeleteUserRoleDocument, baseOptions);
      }
export type DeleteUserRoleMutationHookResult = ReturnType<typeof useDeleteUserRoleMutation>;
export type DeleteUserRoleMutationResult = Apollo.MutationResult<DeleteUserRoleMutation>;
export type DeleteUserRoleMutationOptions = Apollo.BaseMutationOptions<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>;