// THIS FILE IS AUTOGENERATED, EDIT WITH CAUTION
import {Node} from 'slate'
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  DateTime: string;
  RichText: Node[];
  /** A hexidecimal color value. */
  Color: string;
  Unknown: any;
  ContentModelSchema: any;
  Slug: string;
  /** The `Upload` scalar type represents a file upload. */
  Upload: File;
};

export type _Cmp_Article = {
  __typename?: '_cmp_article';
  read: _Cmp_Article_Record;
  list: _Cmp_ArticleConnection;
};


export type _Cmp_ArticleReadArgs = {
  peerID?: Maybe<Scalars['ID']>;
  id: Scalars['ID'];
};


export type _Cmp_ArticleListArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};

export type _Cmp_Article_Record = {
  __typename?: '_cmp_article_record';
  id: Scalars['ID'];
  contentType: Scalars['String'];
  revision: Scalars['Int'];
  state: ContentStateEnum;
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  publicationDate?: Maybe<Scalars['DateTime']>;
  dePublicationDate?: Maybe<Scalars['DateTime']>;
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmp_Article_Record_Content>;
};

export type _Cmp_Article_Record_Content = {
  __typename?: '_cmp_article_record_content';
  blocks?: Maybe<Array<Maybe<_Cmp_Article_Record_Content_Blocks>>>;
};

export type _Cmp_Article_Record_Content_Blocks = _Cmp_Article_Record_Content_Blocks_Title | _Cmp_Article_Record_Content_Blocks_RichText | _Cmp_Article_Record_Content_Blocks_Image | _Cmp_Article_Record_Content_Blocks_ImageGallery | _Cmp_Article_Record_Content_Blocks_Listicle | _Cmp_Article_Record_Content_Blocks_Vimeo | _Cmp_Article_Record_Content_Blocks_Youtube | _Cmp_Article_Record_Content_Blocks_SoundCloudTrack | _Cmp_Article_Record_Content_Blocks_Embed | _Cmp_Article_Record_Content_Blocks_LinkPageBreak | _Cmp_Article_Record_Content_Blocks_Quote | _Cmp_Article_Record_Content_Blocks_TeaserGrid;

export type _Cmp_Article_Record_Content_Blocks_Embed = {
  __typename?: '_cmp_article_record_content_blocks_embed';
  embed?: Maybe<_Cmp_Article_Record_Content_Blocks_Embed_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_Embed_Content = {
  __typename?: '_cmp_article_record_content_blocks_embed_content';
  type?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  styleCustom?: Maybe<Scalars['String']>;
};

export type _Cmp_Article_Record_Content_Blocks_Image = {
  __typename?: '_cmp_article_record_content_blocks_image';
  image?: Maybe<_Cmp_Article_Record_Content_Blocks_Image_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_Image_Content = {
  __typename?: '_cmp_article_record_content_blocks_image_content';
  image: Ref__Media;
  caption?: Maybe<Scalars['String']>;
};

export type _Cmp_Article_Record_Content_Blocks_ImageGallery = {
  __typename?: '_cmp_article_record_content_blocks_imageGallery';
  imageGallery?: Maybe<_Cmp_Article_Record_Content_Blocks_ImageGallery_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_ImageGallery_Content = {
  __typename?: '_cmp_article_record_content_blocks_imageGallery_content';
  images: Array<Maybe<_Cmp_Article_Record_Content_Blocks_ImageGallery_Images>>;
};

export type _Cmp_Article_Record_Content_Blocks_ImageGallery_Images = {
  __typename?: '_cmp_article_record_content_blocks_imageGallery_images';
  image: Ref__Media;
  caption?: Maybe<Scalars['String']>;
};

export type _Cmp_Article_Record_Content_Blocks_LinkPageBreak = {
  __typename?: '_cmp_article_record_content_blocks_linkPageBreak';
  linkPageBreak?: Maybe<_Cmp_Article_Record_Content_Blocks_LinkPageBreak_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_LinkPageBreak_Content = {
  __typename?: '_cmp_article_record_content_blocks_linkPageBreak_content';
  text?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
  linkURL?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  linkTarget?: Maybe<Scalars['String']>;
  hideButton: Scalars['Boolean'];
  styleOption?: Maybe<Scalars['String']>;
  layoutOption?: Maybe<Scalars['String']>;
  templateOption?: Maybe<Scalars['String']>;
  image?: Maybe<Ref__Media>;
};

export type _Cmp_Article_Record_Content_Blocks_Listicle = {
  __typename?: '_cmp_article_record_content_blocks_listicle';
  listicle?: Maybe<_Cmp_Article_Record_Content_Blocks_Listicle_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_Listicle_Content = {
  __typename?: '_cmp_article_record_content_blocks_listicle_content';
  items: Array<Maybe<_Cmp_Article_Record_Content_Blocks_Listicle_Items>>;
};

export type _Cmp_Article_Record_Content_Blocks_Listicle_Items = {
  __typename?: '_cmp_article_record_content_blocks_listicle_items';
  title?: Maybe<Scalars['String']>;
  richText?: Maybe<Scalars['RichText']>;
  image?: Maybe<Ref__Media>;
};

export type _Cmp_Article_Record_Content_Blocks_Quote = {
  __typename?: '_cmp_article_record_content_blocks_quote';
  quote?: Maybe<_Cmp_Article_Record_Content_Blocks_Quote_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_Quote_Content = {
  __typename?: '_cmp_article_record_content_blocks_quote_content';
  quote?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
};

export type _Cmp_Article_Record_Content_Blocks_RichText = {
  __typename?: '_cmp_article_record_content_blocks_richText';
  richText?: Maybe<_Cmp_Article_Record_Content_Blocks_RichText_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_RichText_Content = {
  __typename?: '_cmp_article_record_content_blocks_richText_content';
  richText: Scalars['RichText'];
};

export type _Cmp_Article_Record_Content_Blocks_SoundCloudTrack = {
  __typename?: '_cmp_article_record_content_blocks_soundCloudTrack';
  soundCloudTrack?: Maybe<_Cmp_Article_Record_Content_Blocks_SoundCloudTrack_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_SoundCloudTrack_Content = {
  __typename?: '_cmp_article_record_content_blocks_soundCloudTrack_content';
  trackID: Scalars['ID'];
};

export type _Cmp_Article_Record_Content_Blocks_TeaserGrid = {
  __typename?: '_cmp_article_record_content_blocks_teaserGrid';
  teaserGrid?: Maybe<_Cmp_Article_Record_Content_Blocks_TeaserGrid_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_TeaserGrid_Content = {
  __typename?: '_cmp_article_record_content_blocks_teaserGrid_content';
  teasers: Array<Maybe<_Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers>>;
  numColumns: Scalars['Int'];
};

export type _Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers = {
  __typename?: '_cmp_article_record_content_blocks_teaserGrid_teasers';
  style?: Maybe<_Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_Style>;
  imageID?: Maybe<Ref__Media>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  contentRef?: Maybe<Ref_Article_Page>;
};

export type _Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_ContentRef = _Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_ContentRef_Article | _Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_ContentRef_Page;

export type _Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_ContentRef_Article = {
  __typename?: '_cmp_article_record_content_blocks_teaserGrid_teasers_contentRef_article';
  article?: Maybe<_Cmp_Article_Record>;
};

export type _Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_ContentRef_Page = {
  __typename?: '_cmp_article_record_content_blocks_teaserGrid_teasers_contentRef_page';
  page?: Maybe<Scalars['Unknown']>;
};

export enum _Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_Style {
  /** default */
  Default = 'DEFAULT',
  /** light */
  Light = 'LIGHT',
  /** text */
  Text = 'TEXT'
}

export type _Cmp_Article_Record_Content_Blocks_Title = {
  __typename?: '_cmp_article_record_content_blocks_title';
  title?: Maybe<_Cmp_Article_Record_Content_Blocks_Title_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_Title_Content = {
  __typename?: '_cmp_article_record_content_blocks_title_content';
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
};

export type _Cmp_Article_Record_Content_Blocks_Vimeo = {
  __typename?: '_cmp_article_record_content_blocks_vimeo';
  vimeo?: Maybe<_Cmp_Article_Record_Content_Blocks_Vimeo_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_Vimeo_Content = {
  __typename?: '_cmp_article_record_content_blocks_vimeo_content';
  videoID: Scalars['ID'];
};

export type _Cmp_Article_Record_Content_Blocks_Youtube = {
  __typename?: '_cmp_article_record_content_blocks_youtube';
  youtube?: Maybe<_Cmp_Article_Record_Content_Blocks_Youtube_Content>;
};

export type _Cmp_Article_Record_Content_Blocks_Youtube_Content = {
  __typename?: '_cmp_article_record_content_blocks_youtube_content';
  videoID: Scalars['ID'];
};

export type _Cmp_ArticleConnection = {
  __typename?: '_cmp_articleConnection';
  nodes: Array<_Cmp_Article_Record>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type _Cmp_ModelA = {
  __typename?: '_cmp_modelA';
  read: _Cmp_ModelA_Record;
  list: _Cmp_ModelAConnection;
};


export type _Cmp_ModelAReadArgs = {
  peerID?: Maybe<Scalars['ID']>;
  id: Scalars['ID'];
};


export type _Cmp_ModelAListArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};

export type _Cmp_ModelA_Record = {
  __typename?: '_cmp_modelA_record';
  id: Scalars['ID'];
  contentType: Scalars['String'];
  revision: Scalars['Int'];
  state: ContentStateEnum;
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  publicationDate?: Maybe<Scalars['DateTime']>;
  dePublicationDate?: Maybe<Scalars['DateTime']>;
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmp_ModelA_Record_Content>;
  meta?: Maybe<_Cmp_ModelA_Record_Meta>;
};

export type _Cmp_ModelA_Record_Content = {
  __typename?: '_cmp_modelA_record_content';
  myString?: Maybe<Scalars['String']>;
  myStringI18n?: Maybe<I18n_String>;
  myRichText?: Maybe<Scalars['RichText']>;
  myRichTextI18n?: Maybe<I18n_RichText>;
  myRef?: Maybe<Ref_ModelA_ModelB__Media>;
};

export type _Cmp_ModelA_Record_Content_MyRef = _Cmp_ModelA_Record_Content_MyRef_ModelA | _Cmp_ModelA_Record_Content_MyRef_ModelB | _Cmp_ModelA_Record_Content_MyRef__Media;

export type _Cmp_ModelA_Record_Content_MyRef__Media = {
  __typename?: '_cmp_modelA_record_content_myRef__media';
  _media?: Maybe<Image>;
};

export type _Cmp_ModelA_Record_Content_MyRef_ModelA = {
  __typename?: '_cmp_modelA_record_content_myRef_modelA';
  modelA?: Maybe<_Cmp_ModelA_Record>;
};

export type _Cmp_ModelA_Record_Content_MyRef_ModelB = {
  __typename?: '_cmp_modelA_record_content_myRef_modelB';
  modelB?: Maybe<_Cmp_ModelB_Record>;
};

export type _Cmp_ModelA_Record_Meta = {
  __typename?: '_cmp_modelA_record_meta';
  myString?: Maybe<Scalars['String']>;
  myStringI18n?: Maybe<I18n_String>;
  myRichText?: Maybe<Scalars['RichText']>;
  myRichTextI18n?: Maybe<I18n_RichText>;
  myRef?: Maybe<Ref_ModelA_ModelB__Media>;
};

export type _Cmp_ModelAConnection = {
  __typename?: '_cmp_modelAConnection';
  nodes: Array<_Cmp_ModelA_Record>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type _Cmp_ModelB = {
  __typename?: '_cmp_modelB';
  read: _Cmp_ModelB_Record;
  list: _Cmp_ModelBConnection;
};


export type _Cmp_ModelBReadArgs = {
  peerID?: Maybe<Scalars['ID']>;
  id: Scalars['ID'];
};


export type _Cmp_ModelBListArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};

export type _Cmp_ModelB_Record = {
  __typename?: '_cmp_modelB_record';
  id: Scalars['ID'];
  contentType: Scalars['String'];
  revision: Scalars['Int'];
  state: ContentStateEnum;
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  publicationDate?: Maybe<Scalars['DateTime']>;
  dePublicationDate?: Maybe<Scalars['DateTime']>;
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmp_ModelB_Record_Content>;
};

export type _Cmp_ModelB_Record_Content = {
  __typename?: '_cmp_modelB_record_content';
  myString?: Maybe<Scalars['String']>;
  myRichText?: Maybe<Scalars['RichText']>;
  myRef?: Maybe<Ref_ModelA>;
};

export type _Cmp_ModelBConnection = {
  __typename?: '_cmp_modelBConnection';
  nodes: Array<_Cmp_ModelB_Record>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type _Cmpi_Article = {
  __typename?: '_cmpi_article';
  create: _Cmp_Article_Record;
  update: _Cmp_Article_Record;
  delete: Scalars['Boolean'];
  publish?: Maybe<_Cmp_Article_Record>;
  unpublish?: Maybe<_Cmp_Article_Record>;
};


export type _Cmpi_ArticleCreateArgs = {
  input: _Cmpi_Article_Record_Create;
};


export type _Cmpi_ArticleUpdateArgs = {
  input: _Cmpi_Article_Record_Update;
};


export type _Cmpi_ArticleDeleteArgs = {
  id: Scalars['ID'];
  revision?: Maybe<Scalars['Int']>;
};


export type _Cmpi_ArticlePublishArgs = {
  id: Scalars['ID'];
  revision: Scalars['Int'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type _Cmpi_ArticleUnpublishArgs = {
  id: Scalars['ID'];
};

export type _Cmpi_Article_Record_Content = {
  blocks?: Maybe<Array<Maybe<_Cmpi_Article_Record_Content_Blocks>>>;
};

export type _Cmpi_Article_Record_Content_Blocks = {
  title?: Maybe<_Cmpi_Article_Record_Content_Blocks_Title>;
  richText?: Maybe<_Cmpi_Article_Record_Content_Blocks_RichText>;
  image?: Maybe<_Cmpi_Article_Record_Content_Blocks_Image>;
  imageGallery?: Maybe<_Cmpi_Article_Record_Content_Blocks_ImageGallery>;
  listicle?: Maybe<_Cmpi_Article_Record_Content_Blocks_Listicle>;
  vimeo?: Maybe<_Cmpi_Article_Record_Content_Blocks_Vimeo>;
  youtube?: Maybe<_Cmpi_Article_Record_Content_Blocks_Youtube>;
  soundCloudTrack?: Maybe<_Cmpi_Article_Record_Content_Blocks_SoundCloudTrack>;
  embed?: Maybe<_Cmpi_Article_Record_Content_Blocks_Embed>;
  linkPageBreak?: Maybe<_Cmpi_Article_Record_Content_Blocks_LinkPageBreak>;
  quote?: Maybe<_Cmpi_Article_Record_Content_Blocks_Quote>;
  teaserGrid?: Maybe<_Cmpi_Article_Record_Content_Blocks_TeaserGrid>;
};

export type _Cmpi_Article_Record_Content_Blocks_Embed = {
  type?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  styleCustom?: Maybe<Scalars['String']>;
};

export type _Cmpi_Article_Record_Content_Blocks_Image = {
  image: Ref_Input;
  caption?: Maybe<Scalars['String']>;
};

export type _Cmpi_Article_Record_Content_Blocks_ImageGallery = {
  images: Array<Maybe<_Cmpi_Article_Record_Content_Blocks_ImageGallery_Images>>;
};

export type _Cmpi_Article_Record_Content_Blocks_ImageGallery_Images = {
  image: Ref_Input;
  caption?: Maybe<Scalars['String']>;
};

export type _Cmpi_Article_Record_Content_Blocks_LinkPageBreak = {
  text?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
  linkURL?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  linkTarget?: Maybe<Scalars['String']>;
  hideButton: Scalars['Boolean'];
  styleOption?: Maybe<Scalars['String']>;
  layoutOption?: Maybe<Scalars['String']>;
  templateOption?: Maybe<Scalars['String']>;
  image?: Maybe<Ref_Input>;
};

export type _Cmpi_Article_Record_Content_Blocks_Listicle = {
  items: Array<Maybe<_Cmpi_Article_Record_Content_Blocks_Listicle_Items>>;
};

export type _Cmpi_Article_Record_Content_Blocks_Listicle_Items = {
  title?: Maybe<Scalars['String']>;
  richText?: Maybe<Scalars['RichText']>;
  image?: Maybe<Ref_Input>;
};

export type _Cmpi_Article_Record_Content_Blocks_Quote = {
  quote?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
};

export type _Cmpi_Article_Record_Content_Blocks_RichText = {
  richText: Scalars['RichText'];
};

export type _Cmpi_Article_Record_Content_Blocks_SoundCloudTrack = {
  trackID: Scalars['ID'];
};

export type _Cmpi_Article_Record_Content_Blocks_TeaserGrid = {
  teasers: Array<Maybe<_Cmpi_Article_Record_Content_Blocks_TeaserGrid_Teasers>>;
  numColumns: Scalars['Int'];
};

export type _Cmpi_Article_Record_Content_Blocks_TeaserGrid_Teasers = {
  style?: Maybe<_Cmpi_Article_Record_Content_Blocks_TeaserGrid_Teasers_Style>;
  imageID?: Maybe<Ref_Input>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  contentRef?: Maybe<Ref_Input>;
};

export enum _Cmpi_Article_Record_Content_Blocks_TeaserGrid_Teasers_Style {
  /** default */
  Default = 'DEFAULT',
  /** light */
  Light = 'LIGHT',
  /** text */
  Text = 'TEXT'
}

export type _Cmpi_Article_Record_Content_Blocks_Title = {
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
};

export type _Cmpi_Article_Record_Content_Blocks_Vimeo = {
  videoID: Scalars['ID'];
};

export type _Cmpi_Article_Record_Content_Blocks_Youtube = {
  videoID: Scalars['ID'];
};

export type _Cmpi_Article_Record_Create = {
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmpi_Article_Record_Content>;
};

export type _Cmpi_Article_Record_Update = {
  id: Scalars['ID'];
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmpi_Article_Record_Content>;
};

export type _Cmpi_ModelA = {
  __typename?: '_cmpi_modelA';
  create: _Cmp_ModelA_Record;
  update: _Cmp_ModelA_Record;
  delete: Scalars['Boolean'];
  publish?: Maybe<_Cmp_ModelA_Record>;
  unpublish?: Maybe<_Cmp_ModelA_Record>;
};


export type _Cmpi_ModelACreateArgs = {
  input: _Cmpi_ModelA_Record_Create;
};


export type _Cmpi_ModelAUpdateArgs = {
  input: _Cmpi_ModelA_Record_Update;
};


export type _Cmpi_ModelADeleteArgs = {
  id: Scalars['ID'];
  revision?: Maybe<Scalars['Int']>;
};


export type _Cmpi_ModelAPublishArgs = {
  id: Scalars['ID'];
  revision: Scalars['Int'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type _Cmpi_ModelAUnpublishArgs = {
  id: Scalars['ID'];
};

export type _Cmpi_ModelA_Record_Content = {
  myString?: Maybe<Scalars['String']>;
  myStringI18n?: Maybe<I18n_String_Input>;
  myRichText?: Maybe<Scalars['RichText']>;
  myRichTextI18n?: Maybe<I18n_RichText_Input>;
  myRef?: Maybe<Ref_Input>;
};

export type _Cmpi_ModelA_Record_Create = {
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmpi_ModelA_Record_Content>;
  meta?: Maybe<_Cmpi_ModelA_Record_Meta>;
};

export type _Cmpi_ModelA_Record_Meta = {
  myString?: Maybe<Scalars['String']>;
  myStringI18n?: Maybe<I18n_String_Input>;
  myRichText?: Maybe<Scalars['RichText']>;
  myRichTextI18n?: Maybe<I18n_RichText_Input>;
  myRef?: Maybe<Ref_Input>;
};

export type _Cmpi_ModelA_Record_Update = {
  id: Scalars['ID'];
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmpi_ModelA_Record_Content>;
  meta?: Maybe<_Cmpi_ModelA_Record_Meta>;
};

export type _Cmpi_ModelB = {
  __typename?: '_cmpi_modelB';
  create: _Cmp_ModelB_Record;
  update: _Cmp_ModelB_Record;
  delete: Scalars['Boolean'];
  publish?: Maybe<_Cmp_ModelB_Record>;
  unpublish?: Maybe<_Cmp_ModelB_Record>;
};


export type _Cmpi_ModelBCreateArgs = {
  input: _Cmpi_ModelB_Record_Create;
};


export type _Cmpi_ModelBUpdateArgs = {
  input: _Cmpi_ModelB_Record_Update;
};


export type _Cmpi_ModelBDeleteArgs = {
  id: Scalars['ID'];
  revision?: Maybe<Scalars['Int']>;
};


export type _Cmpi_ModelBPublishArgs = {
  id: Scalars['ID'];
  revision: Scalars['Int'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type _Cmpi_ModelBUnpublishArgs = {
  id: Scalars['ID'];
};

export type _Cmpi_ModelB_Record_Content = {
  myString?: Maybe<Scalars['String']>;
  myRichText?: Maybe<Scalars['RichText']>;
  myRef?: Maybe<Ref_Input>;
};

export type _Cmpi_ModelB_Record_Create = {
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmpi_ModelB_Record_Content>;
};

export type _Cmpi_ModelB_Record_Update = {
  id: Scalars['ID'];
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  content?: Maybe<_Cmpi_ModelB_Record_Content>;
};

export type All = {
  __typename?: 'All';
  list: ListByTypeConnection;
  read: ContentModelSummary;
};


export type AllListArgs = {
  type: ContentTypeEnum;
  context?: Maybe<ContentContextEnum>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};


export type AllReadArgs = {
  peerID?: Maybe<Scalars['ID']>;
  id: Scalars['ID'];
};

export type AllCustomContents = {
  __typename?: 'AllCustomContents';
  id: Scalars['ID'];
  shared: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  draft?: Maybe<AllCustomContentsRevision>;
  published?: Maybe<AllCustomContentsRevision>;
  pending?: Maybe<AllCustomContentsRevision>;
  latest: AllCustomContentsRevision;
};

export type AllCustomContentsRevision = {
  __typename?: 'AllCustomContentsRevision';
  revision: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
  title: Scalars['String'];
  slug: Scalars['Slug'];
};

export type AllMutations = {
  __typename?: 'AllMutations';
  delete?: Maybe<Scalars['Boolean']>;
  publish?: Maybe<AllCustomContents>;
  unpublish?: Maybe<AllCustomContents>;
};


export type AllMutationsDeleteArgs = {
  id: Scalars['ID'];
};


export type AllMutationsPublishArgs = {
  id: Scalars['ID'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type AllMutationsUnpublishArgs = {
  id: Scalars['ID'];
};

export type Article = {
  __typename?: 'Article';
  id: Scalars['ID'];
  shared: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  draft?: Maybe<ArticleRevision>;
  published?: Maybe<ArticleRevision>;
  pending?: Maybe<ArticleRevision>;
  latest: ArticleRevision;
};

export type ArticleConnection = {
  __typename?: 'ArticleConnection';
  nodes: Array<Article>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ArticleFilter = {
  title?: Maybe<Scalars['String']>;
  draft?: Maybe<Scalars['Boolean']>;
  published?: Maybe<Scalars['Boolean']>;
  pending?: Maybe<Scalars['Boolean']>;
  authors?: Maybe<Array<Scalars['ID']>>;
  tags?: Maybe<Array<Scalars['String']>>;
};

export type ArticleInput = {
  slug: Scalars['Slug'];
  preTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  lead?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  properties: Array<PropertiesInput>;
  imageID?: Maybe<Scalars['ID']>;
  authorIDs: Array<Scalars['ID']>;
  shared: Scalars['Boolean'];
  breaking: Scalars['Boolean'];
  hideAuthor: Scalars['Boolean'];
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaAuthorIDs: Array<Scalars['ID']>;
  socialMediaImageID?: Maybe<Scalars['ID']>;
  blocks: Array<BlockInput>;
};

export type ArticleNavigationLink = BaseNavigationLink & {
  __typename?: 'ArticleNavigationLink';
  label: Scalars['String'];
  article?: Maybe<Article>;
};

export type ArticleNavigationLinkInput = {
  label: Scalars['String'];
  articleID: Scalars['ID'];
};

export type ArticleRevision = {
  __typename?: 'ArticleRevision';
  revision: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
  hideAuthor: Scalars['Boolean'];
  preTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  lead?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  tags: Array<Scalars['String']>;
  properties: Array<Properties>;
  image?: Maybe<Image>;
  authors: Array<Maybe<Author>>;
  breaking: Scalars['Boolean'];
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaAuthors: Array<Author>;
  socialMediaImage?: Maybe<Image>;
  blocks: Array<Block>;
};

export enum ArticleSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT',
  PublishAt = 'PUBLISH_AT',
  PublishedAt = 'PUBLISHED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type ArticleTeaser = {
  __typename?: 'ArticleTeaser';
  style: TeaserStyle;
  image?: Maybe<Image>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  article?: Maybe<Article>;
};

export type ArticleTeaserInput = {
  style: TeaserStyle;
  imageID?: Maybe<Scalars['ID']>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  articleID: Scalars['ID'];
};

export type Author = {
  __typename?: 'Author';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['Slug'];
  url: Scalars['String'];
  links?: Maybe<Array<AuthorLink>>;
  bio?: Maybe<Scalars['RichText']>;
  jobTitle?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
};

export type AuthorConnection = {
  __typename?: 'AuthorConnection';
  nodes: Array<Author>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type AuthorFilter = {
  name?: Maybe<Scalars['String']>;
};

export type AuthorInput = {
  name: Scalars['String'];
  slug: Scalars['Slug'];
  links?: Maybe<Array<AuthorLinkInput>>;
  bio?: Maybe<Scalars['RichText']>;
  jobTitle?: Maybe<Scalars['String']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type AuthorLink = {
  __typename?: 'AuthorLink';
  title: Scalars['String'];
  url: Scalars['String'];
};

export type AuthorLinkInput = {
  title: Scalars['String'];
  url: Scalars['String'];
};

export enum AuthorSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export type AuthProvider = {
  __typename?: 'AuthProvider';
  name: Scalars['String'];
  url: Scalars['String'];
};

export type AvailablePaymentMethod = {
  __typename?: 'AvailablePaymentMethod';
  paymentMethods: Array<PaymentMethod>;
  paymentPeriodicities: Array<PaymentPeriodicity>;
  forceAutoRenewal: Scalars['Boolean'];
};

export type AvailablePaymentMethodInput = {
  paymentMethodIDs: Array<Scalars['String']>;
  paymentPeriodicities: Array<PaymentPeriodicity>;
  forceAutoRenewal: Scalars['Boolean'];
};

export type BaseNavigationLink = {
  label: Scalars['String'];
};

export type Block = RichTextBlock | ImageBlock | ImageGalleryBlock | ListicleBlock | FacebookPostBlock | FacebookVideoBlock | InstagramPostBlock | TwitterTweetBlock | VimeoVideoBlock | YouTubeVideoBlock | SoundCloudTrackBlock | EmbedBlock | LinkPageBreakBlock | TitleBlock | QuoteBlock | TeaserGridBlock;

export type BlockInput = {
  richText?: Maybe<RichTextBlockInput>;
  image?: Maybe<ImageBlockInput>;
  imageGallery?: Maybe<ImageGalleryBlockInput>;
  listicle?: Maybe<ListicleBlockInput>;
  title?: Maybe<TitleBlockInput>;
  quote?: Maybe<QuoteBlockInput>;
  facebookPost?: Maybe<FacebookPostBlockInput>;
  facebookVideo?: Maybe<FacebookVideoBlockInput>;
  instagramPost?: Maybe<InstagramPostBlockInput>;
  twitterTweet?: Maybe<TwitterTweetBlockInput>;
  vimeoVideo?: Maybe<VimeoVideoBlockInput>;
  youTubeVideo?: Maybe<YouTubeVideoBlockInput>;
  soundCloudTrack?: Maybe<SoundCloudTrackBlockInput>;
  embed?: Maybe<EmbedBlockInput>;
  linkPageBreak?: Maybe<LinkPageBreakBlockInput>;
  teaserGrid?: Maybe<TeaserGridBlockInput>;
};


export type Comment = {
  __typename?: 'Comment';
  id: Scalars['ID'];
  user: User;
  authorType: CommentAuthorType;
  itemID: Scalars['ID'];
  itemType: CommentItemType;
  parentID?: Maybe<Scalars['ID']>;
  revisions: Array<CommentRevision>;
  state: CommentState;
  rejectionReason?: Maybe<CommentRejectionReason>;
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
};

export enum CommentAuthorType {
  Author = 'Author',
  Team = 'Team',
  VerifiedUser = 'VerifiedUser'
}

export type CommentConnection = {
  __typename?: 'CommentConnection';
  nodes: Array<Comment>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type CommentFilter = {
  state?: Maybe<CommentState>;
};

export enum CommentItemType {
  Article = 'Article',
  Page = 'Page'
}

export enum CommentRejectionReason {
  Misconduct = 'Misconduct',
  Spam = 'Spam'
}

export type CommentRevision = {
  __typename?: 'CommentRevision';
  text: Scalars['RichText'];
  createdAt: Scalars['DateTime'];
};

export enum CommentSort {
  ModifiedAt = 'ModifiedAt',
  CreatedAt = 'CreatedAt'
}

export enum CommentState {
  Approved = 'Approved',
  PendingApproval = 'PendingApproval',
  PendingUserChanges = 'PendingUserChanges',
  Rejected = 'Rejected'
}

export type Config = {
  __typename?: 'Config';
  content: Array<ContentConfig>;
  languages: LanguagesConfig;
};

export type Content = {
  __typename?: 'content';
  modelA: _Cmp_ModelA;
  modelB: _Cmp_ModelB;
  article: _Cmp_Article;
  _all: All;
};

export type Content_Mutations = {
  __typename?: 'content_mutations';
  modelA: _Cmpi_ModelA;
  modelB: _Cmpi_ModelB;
  article: _Cmpi_Article;
  _all: AllMutations;
};

export type ContentConfig = {
  __typename?: 'ContentConfig';
  id: Scalars['ID'];
  identifier: Scalars['String'];
  namePlural: Scalars['String'];
  nameSingular: Scalars['String'];
  schema: Scalars['ContentModelSchema'];
};

export enum ContentContextEnum {
  Local = 'local',
  Peers = 'peers'
}


export type ContentModelSummary = {
  __typename?: 'ContentModelSummary';
  id: Scalars['ID'];
  title: Scalars['String'];
  shared: Scalars['Boolean'];
  contentType: ContentTypeEnum;
  revision: Scalars['Int'];
  state: ContentStateEnum;
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  publicationDate?: Maybe<Scalars['DateTime']>;
  dePublicationDate?: Maybe<Scalars['DateTime']>;
};

export enum ContentStateEnum {
  Draft = 'Draft',
  Review = 'Review',
  Release = 'Release',
  Archive = 'Archive'
}

export enum ContentTypeEnum {
  ModelA = 'modelA',
  ModelB = 'modelB',
  Article = 'article'
}

export type CreatedToken = {
  __typename?: 'CreatedToken';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  token: Scalars['String'];
};

export type CreatePeerInput = {
  name: Scalars['String'];
  slug: Scalars['String'];
  hostURL: Scalars['String'];
  token: Scalars['String'];
};

export type DateFilter = {
  date?: Maybe<Scalars['DateTime']>;
  comparison: DateFilterComparison;
};

export enum DateFilterComparison {
  Greater = 'GREATER',
  GreaterOrEqual = 'GREATER_OR_EQUAL',
  Equal = 'EQUAL',
  Lower = 'LOWER',
  LowerOrEqual = 'LOWER_OR_EQUAL'
}


export type EmbedBlock = {
  __typename?: 'EmbedBlock';
  url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  styleCustom?: Maybe<Scalars['String']>;
};

export type EmbedBlockInput = {
  url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  styleCustom?: Maybe<Scalars['String']>;
};

export type ExternalNavigationLink = BaseNavigationLink & {
  __typename?: 'ExternalNavigationLink';
  label: Scalars['String'];
  url: Scalars['String'];
};

export type ExternalNavigationLinkInput = {
  label: Scalars['String'];
  url: Scalars['String'];
};

export type FacebookPostBlock = {
  __typename?: 'FacebookPostBlock';
  userID: Scalars['String'];
  postID: Scalars['String'];
};

export type FacebookPostBlockInput = {
  userID: Scalars['String'];
  postID: Scalars['String'];
};

export type FacebookVideoBlock = {
  __typename?: 'FacebookVideoBlock';
  userID: Scalars['String'];
  videoID: Scalars['String'];
};

export type FacebookVideoBlockInput = {
  userID: Scalars['String'];
  videoID: Scalars['String'];
};

export type GalleryImageEdge = {
  __typename?: 'GalleryImageEdge';
  caption?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
};

export type GalleryImageEdgeInput = {
  caption?: Maybe<Scalars['String']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type I18n_RichText = {
  __typename?: 'i18n_RichText';
  en?: Maybe<Scalars['RichText']>;
  de?: Maybe<Scalars['RichText']>;
};

export type I18n_RichText_Input = {
  en?: Maybe<Scalars['RichText']>;
  de?: Maybe<Scalars['RichText']>;
};

export type I18n_String = {
  __typename?: 'i18n_String';
  en?: Maybe<Scalars['String']>;
  de?: Maybe<Scalars['String']>;
};

export type I18n_String_Input = {
  en?: Maybe<Scalars['String']>;
  de?: Maybe<Scalars['String']>;
};

export type Image = {
  __typename?: 'Image';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  filename?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  license?: Maybe<Scalars['String']>;
  fileSize: Scalars['Int'];
  extension: Scalars['String'];
  mimeType: Scalars['String'];
  format: Scalars['String'];
  width: Scalars['Int'];
  height: Scalars['Int'];
  focalPoint?: Maybe<Point>;
  url?: Maybe<Scalars['String']>;
  transformURL?: Maybe<Scalars['String']>;
};


export type ImageTransformUrlArgs = {
  input?: Maybe<ImageTransformation>;
};

export type ImageBlock = {
  __typename?: 'ImageBlock';
  image?: Maybe<Image>;
  caption?: Maybe<Scalars['String']>;
};

export type ImageBlockInput = {
  caption?: Maybe<Scalars['String']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type ImageConnection = {
  __typename?: 'ImageConnection';
  nodes: Array<Image>;
  totalCount: Scalars['Int'];
  pageInfo: PageInfo;
};

export type ImageFilter = {
  title?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
};

export type ImageGalleryBlock = {
  __typename?: 'ImageGalleryBlock';
  images: Array<GalleryImageEdge>;
};

export type ImageGalleryBlockInput = {
  images?: Maybe<Array<Maybe<GalleryImageEdgeInput>>>;
};

export enum ImageOutput {
  Png = 'PNG',
  Jpeg = 'JPEG',
  Webp = 'WEBP'
}

export enum ImageRotation {
  Auto = 'AUTO',
  Rotate_0 = 'ROTATE_0',
  Rotate_90 = 'ROTATE_90',
  Rotate_180 = 'ROTATE_180',
  Rotate_270 = 'ROTATE_270'
}

export enum ImageSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export type ImageTransformation = {
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  rotation?: Maybe<ImageRotation>;
  quality?: Maybe<Scalars['Float']>;
  output?: Maybe<ImageOutput>;
};

export type InputPoint = {
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type InstagramPostBlock = {
  __typename?: 'InstagramPostBlock';
  postID: Scalars['String'];
};

export type InstagramPostBlockInput = {
  postID: Scalars['String'];
};

export type Invoice = {
  __typename?: 'Invoice';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  mail: Scalars['String'];
  user?: Maybe<User>;
  description?: Maybe<Scalars['String']>;
  paidAt?: Maybe<Scalars['DateTime']>;
  items: Array<InvoiceItem>;
  total: Scalars['Int'];
};

export type InvoiceConnection = {
  __typename?: 'InvoiceConnection';
  nodes: Array<Invoice>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type InvoiceFilter = {
  mail?: Maybe<Scalars['String']>;
};

export type InvoiceInput = {
  mail: Scalars['String'];
  userID?: Maybe<Scalars['ID']>;
  description?: Maybe<Scalars['String']>;
  paidAt?: Maybe<Scalars['DateTime']>;
  items: Array<InvoiceItemInput>;
};

export type InvoiceItem = {
  __typename?: 'InvoiceItem';
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  amount: Scalars['Int'];
  total: Scalars['Int'];
};

export type InvoiceItemInput = {
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  amount: Scalars['Int'];
};

export enum InvoiceSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT',
  PaidAt = 'PAID_AT'
}

export type LanguageConfig = {
  __typename?: 'LanguageConfig';
  id: Scalars['ID'];
  tag: Scalars['String'];
  description: Scalars['String'];
};

export type LanguagesConfig = {
  __typename?: 'LanguagesConfig';
  defaultLanguageId: Scalars['String'];
  languages: Array<LanguageConfig>;
};

export type LinkPageBreakBlock = {
  __typename?: 'LinkPageBreakBlock';
  text?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
  linkURL?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  linkTarget?: Maybe<Scalars['String']>;
  hideButton: Scalars['Boolean'];
  styleOption?: Maybe<Scalars['String']>;
  layoutOption?: Maybe<Scalars['String']>;
  templateOption?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
};

export type LinkPageBreakBlockInput = {
  text?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
  linkURL?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  linkTarget?: Maybe<Scalars['String']>;
  hideButton: Scalars['Boolean'];
  styleOption?: Maybe<Scalars['String']>;
  templateOption?: Maybe<Scalars['String']>;
  layoutOption?: Maybe<Scalars['String']>;
  imageID?: Maybe<Scalars['ID']>;
};

export type ListByTypeConnection = {
  __typename?: 'listByTypeConnection';
  nodes: Array<ListByTypePeerCustomContent>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ListByTypePeerCustomContent = {
  __typename?: 'listByTypePeerCustomContent';
  peer?: Maybe<Peer>;
  content: ContentModelSummary;
};

export type ListicleBlock = {
  __typename?: 'ListicleBlock';
  items: Array<ListicleItem>;
};

export type ListicleBlockInput = {
  items?: Maybe<Array<Maybe<ListicleItemInput>>>;
};

export type ListicleItem = {
  __typename?: 'ListicleItem';
  title: Scalars['String'];
  image?: Maybe<Image>;
  richText: Scalars['RichText'];
};

export type ListicleItemInput = {
  title: Scalars['String'];
  imageID?: Maybe<Scalars['ID']>;
  richText: Scalars['RichText'];
};

export type MemberPlan = {
  __typename?: 'MemberPlan';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['String'];
  image?: Maybe<Image>;
  description?: Maybe<Scalars['RichText']>;
  active: Scalars['Boolean'];
  amountPerMonthMin: Scalars['Int'];
  availablePaymentMethods: Array<AvailablePaymentMethod>;
};

export type MemberPlanConnection = {
  __typename?: 'MemberPlanConnection';
  nodes: Array<MemberPlan>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type MemberPlanFilter = {
  name?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
};

export type MemberPlanInput = {
  name: Scalars['String'];
  slug: Scalars['String'];
  imageID?: Maybe<Scalars['ID']>;
  description?: Maybe<Scalars['RichText']>;
  active: Scalars['Boolean'];
  amountPerMonthMin: Scalars['Int'];
  availablePaymentMethods: Array<AvailablePaymentMethodInput>;
};

export enum MemberPlanSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export type Mutation = {
  __typename?: 'Mutation';
  content: Content_Mutations;
  updatePeerProfile: PeerProfile;
  createPeer: Peer;
  updatePeer: Peer;
  deletePeer?: Maybe<Scalars['ID']>;
  createSession: SessionWithToken;
  createSessionWithJWT: SessionWithToken;
  createSessionWithOAuth2Code: SessionWithToken;
  revokeSession: Scalars['Boolean'];
  revokeActiveSession: Scalars['Boolean'];
  sessions: Array<Session>;
  sendJWTLogin: Scalars['String'];
  createToken: CreatedToken;
  deleteToken?: Maybe<Scalars['String']>;
  createUser?: Maybe<User>;
  updateUser?: Maybe<User>;
  updateUserSubscription?: Maybe<UserSubscription>;
  resetUserPassword?: Maybe<User>;
  deleteUser?: Maybe<Scalars['String']>;
  deleteUserSubscription?: Maybe<Scalars['String']>;
  createUserRole?: Maybe<UserRole>;
  updateUserRole?: Maybe<UserRole>;
  deleteUserRole?: Maybe<Scalars['String']>;
  createNavigation?: Maybe<Navigation>;
  updateNavigation?: Maybe<Navigation>;
  deleteNavigation?: Maybe<Scalars['ID']>;
  createAuthor?: Maybe<Author>;
  updateAuthor?: Maybe<Author>;
  deleteAuthor?: Maybe<Scalars['ID']>;
  uploadImage?: Maybe<Image>;
  updateImage?: Maybe<Image>;
  deleteImage?: Maybe<Scalars['Boolean']>;
  createArticle: Article;
  updateArticle?: Maybe<Article>;
  deleteArticle?: Maybe<Scalars['Boolean']>;
  publishArticle?: Maybe<Article>;
  unpublishArticle?: Maybe<Article>;
  duplicateArticle: Article;
  createPage: Page;
  updatePage?: Maybe<Page>;
  deletePage?: Maybe<Scalars['Boolean']>;
  publishPage?: Maybe<Page>;
  unpublishPage?: Maybe<Page>;
  duplicatePage: Page;
  createMemberPlan?: Maybe<MemberPlan>;
  updateMemberPlan?: Maybe<MemberPlan>;
  deleteMemberPlan?: Maybe<Scalars['ID']>;
  createPaymentMethod?: Maybe<PaymentMethod>;
  updatePaymentMethod?: Maybe<PaymentMethod>;
  deletePaymentMethod?: Maybe<Scalars['ID']>;
  createInvoice?: Maybe<Invoice>;
  createPaymentFromInvoice?: Maybe<Payment>;
  updateInvoice?: Maybe<Invoice>;
  deleteInvoice?: Maybe<Scalars['ID']>;
  approveComment: Comment;
  rejectComment: Comment;
  requestChangesOnComment: Comment;
};


export type MutationUpdatePeerProfileArgs = {
  input: PeerProfileInput;
};


export type MutationCreatePeerArgs = {
  input: CreatePeerInput;
};


export type MutationUpdatePeerArgs = {
  id: Scalars['ID'];
  input: UpdatePeerInput;
};


export type MutationDeletePeerArgs = {
  id: Scalars['ID'];
};


export type MutationCreateSessionArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};


export type MutationCreateSessionWithJwtArgs = {
  jwt: Scalars['String'];
};


export type MutationCreateSessionWithOAuth2CodeArgs = {
  name: Scalars['String'];
  code: Scalars['String'];
  redirectUri: Scalars['String'];
};


export type MutationRevokeSessionArgs = {
  id: Scalars['ID'];
};


export type MutationSendJwtLoginArgs = {
  url: Scalars['String'];
  email: Scalars['String'];
};


export type MutationCreateTokenArgs = {
  input: TokenInput;
};


export type MutationDeleteTokenArgs = {
  id: Scalars['ID'];
};


export type MutationCreateUserArgs = {
  input: UserInput;
  password: Scalars['String'];
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID'];
  input: UserInput;
};


export type MutationUpdateUserSubscriptionArgs = {
  userID: Scalars['ID'];
  input: UserSubscriptionInput;
};


export type MutationResetUserPasswordArgs = {
  id: Scalars['ID'];
  password: Scalars['String'];
  sendMail?: Maybe<Scalars['Boolean']>;
};


export type MutationDeleteUserArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteUserSubscriptionArgs = {
  userID: Scalars['ID'];
};


export type MutationCreateUserRoleArgs = {
  input: UserRoleInput;
};


export type MutationUpdateUserRoleArgs = {
  id: Scalars['ID'];
  input: UserRoleInput;
};


export type MutationDeleteUserRoleArgs = {
  id: Scalars['ID'];
};


export type MutationCreateNavigationArgs = {
  input: NavigationInput;
};


export type MutationUpdateNavigationArgs = {
  id: Scalars['ID'];
  input: NavigationInput;
};


export type MutationDeleteNavigationArgs = {
  id: Scalars['ID'];
};


export type MutationCreateAuthorArgs = {
  input: AuthorInput;
};


export type MutationUpdateAuthorArgs = {
  id: Scalars['ID'];
  input: AuthorInput;
};


export type MutationDeleteAuthorArgs = {
  id: Scalars['ID'];
};


export type MutationUploadImageArgs = {
  input: UploadImageInput;
};


export type MutationUpdateImageArgs = {
  id: Scalars['ID'];
  input: UpdateImageInput;
};


export type MutationDeleteImageArgs = {
  id: Scalars['ID'];
};


export type MutationCreateArticleArgs = {
  input: ArticleInput;
};


export type MutationUpdateArticleArgs = {
  id: Scalars['ID'];
  input: ArticleInput;
};


export type MutationDeleteArticleArgs = {
  id: Scalars['ID'];
};


export type MutationPublishArticleArgs = {
  id: Scalars['ID'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type MutationUnpublishArticleArgs = {
  id: Scalars['ID'];
};


export type MutationDuplicateArticleArgs = {
  id: Scalars['ID'];
};


export type MutationCreatePageArgs = {
  input: PageInput;
};


export type MutationUpdatePageArgs = {
  id: Scalars['ID'];
  input: PageInput;
};


export type MutationDeletePageArgs = {
  id: Scalars['ID'];
};


export type MutationPublishPageArgs = {
  id: Scalars['ID'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
};


export type MutationUnpublishPageArgs = {
  id: Scalars['ID'];
};


export type MutationDuplicatePageArgs = {
  id: Scalars['ID'];
};


export type MutationCreateMemberPlanArgs = {
  input: MemberPlanInput;
};


export type MutationUpdateMemberPlanArgs = {
  id: Scalars['ID'];
  input: MemberPlanInput;
};


export type MutationDeleteMemberPlanArgs = {
  id: Scalars['ID'];
};


export type MutationCreatePaymentMethodArgs = {
  input: PaymentMethodInput;
};


export type MutationUpdatePaymentMethodArgs = {
  id: Scalars['ID'];
  input: PaymentMethodInput;
};


export type MutationDeletePaymentMethodArgs = {
  id: Scalars['ID'];
};


export type MutationCreateInvoiceArgs = {
  input: InvoiceInput;
};


export type MutationCreatePaymentFromInvoiceArgs = {
  input: PaymentFromInvoiceInput;
};


export type MutationUpdateInvoiceArgs = {
  id: Scalars['ID'];
  input: InvoiceInput;
};


export type MutationDeleteInvoiceArgs = {
  id: Scalars['ID'];
};


export type MutationApproveCommentArgs = {
  id: Scalars['ID'];
};


export type MutationRejectCommentArgs = {
  id: Scalars['ID'];
  rejectionReason: CommentRejectionReason;
};


export type MutationRequestChangesOnCommentArgs = {
  id: Scalars['ID'];
  rejectionReason: CommentRejectionReason;
};

export type Navigation = {
  __typename?: 'Navigation';
  id: Scalars['ID'];
  key: Scalars['String'];
  name: Scalars['String'];
  links: Array<NavigationLink>;
};

export type NavigationInput = {
  key: Scalars['String'];
  name: Scalars['String'];
  links: Array<NavigationLinkInput>;
};

export type NavigationLink = PageNavigationLink | ArticleNavigationLink | ExternalNavigationLink;

export type NavigationLinkInput = {
  page?: Maybe<PageNavigationLinkInput>;
  article?: Maybe<ArticleNavigationLinkInput>;
  external?: Maybe<ExternalNavigationLinkInput>;
};

export type Page = {
  __typename?: 'Page';
  id: Scalars['ID'];
  shared: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  draft?: Maybe<PageRevision>;
  published?: Maybe<PageRevision>;
  pending?: Maybe<PageRevision>;
  latest: PageRevision;
};

export type PageConnection = {
  __typename?: 'PageConnection';
  nodes: Array<Page>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PageFilter = {
  title?: Maybe<Scalars['String']>;
  draft?: Maybe<Scalars['Boolean']>;
  published?: Maybe<Scalars['Boolean']>;
  pending?: Maybe<Scalars['Boolean']>;
  tags?: Maybe<Array<Scalars['String']>>;
};

export type PageInfo = {
  __typename?: 'PageInfo';
  startCursor?: Maybe<Scalars['String']>;
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
};

export type PageInput = {
  slug: Scalars['Slug'];
  title: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  properties: Array<PropertiesInput>;
  imageID?: Maybe<Scalars['ID']>;
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaImageID?: Maybe<Scalars['ID']>;
  blocks: Array<BlockInput>;
};

export type PageNavigationLink = BaseNavigationLink & {
  __typename?: 'PageNavigationLink';
  label: Scalars['String'];
  page?: Maybe<Page>;
};

export type PageNavigationLinkInput = {
  label: Scalars['String'];
  pageID: Scalars['ID'];
};

export type PageRevision = {
  __typename?: 'PageRevision';
  revision: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  publishAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
  slug: Scalars['Slug'];
  title: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  properties: Array<Properties>;
  image?: Maybe<Image>;
  socialMediaTitle?: Maybe<Scalars['String']>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaImage?: Maybe<Image>;
  blocks: Array<Block>;
};

export enum PageSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT',
  PublishAt = 'PUBLISH_AT',
  PublishedAt = 'PUBLISHED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type PageTeaser = {
  __typename?: 'PageTeaser';
  style: TeaserStyle;
  image?: Maybe<Image>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  page?: Maybe<Page>;
};

export type PageTeaserInput = {
  style: TeaserStyle;
  imageID?: Maybe<Scalars['ID']>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  pageID: Scalars['ID'];
};

export type Payment = {
  __typename?: 'Payment';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  intentID?: Maybe<Scalars['String']>;
  intentSecret?: Maybe<Scalars['String']>;
  state: PaymentState;
  invoice: Invoice;
  intentData?: Maybe<Scalars['String']>;
  paymentMethod: PaymentMethod;
  paymentData?: Maybe<Scalars['String']>;
};

export type PaymentConnection = {
  __typename?: 'PaymentConnection';
  nodes: Array<Payment>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PaymentFilter = {
  intentID?: Maybe<Scalars['String']>;
};

export type PaymentFromInvoiceInput = {
  invoiceID: Scalars['String'];
  paymentMethodID: Scalars['String'];
  successURL?: Maybe<Scalars['String']>;
  failureURL?: Maybe<Scalars['String']>;
};

export type PaymentMethod = {
  __typename?: 'PaymentMethod';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  description: Scalars['String'];
  paymentProvider: PaymentProvider;
  active: Scalars['Boolean'];
};

export type PaymentMethodInput = {
  name: Scalars['String'];
  description: Scalars['String'];
  paymentProviderID: Scalars['String'];
  active: Scalars['Boolean'];
};

export enum PaymentPeriodicity {
  Monthly = 'MONTHLY',
  Quarterly = 'QUARTERLY',
  Biannual = 'BIANNUAL',
  Yearly = 'YEARLY'
}

export type PaymentProvider = {
  __typename?: 'PaymentProvider';
  id: Scalars['ID'];
  name: Scalars['String'];
};

export enum PaymentSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export enum PaymentState {
  Created = 'Created',
  Submitted = 'Submitted',
  RequiresUserAction = 'RequiresUserAction',
  Processing = 'Processing',
  Payed = 'Payed',
  Canceled = 'Canceled',
  Declined = 'Declined'
}

export type Peer = {
  __typename?: 'Peer';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['String'];
  hostURL: Scalars['String'];
  profile?: Maybe<PeerProfile>;
};

export type PeerArticle = {
  __typename?: 'PeerArticle';
  peer: Peer;
  article: Article;
};

export type PeerArticleConnection = {
  __typename?: 'PeerArticleConnection';
  nodes: Array<PeerArticle>;
  pageInfo: UnidirectionalPageInfo;
  totalCount: Scalars['Int'];
};

export type PeerArticleTeaser = {
  __typename?: 'PeerArticleTeaser';
  style: TeaserStyle;
  image?: Maybe<Image>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  peer?: Maybe<Peer>;
  articleID: Scalars['ID'];
  article?: Maybe<Article>;
};

export type PeerArticleTeaserInput = {
  style: TeaserStyle;
  imageID?: Maybe<Scalars['ID']>;
  preTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  peerID: Scalars['ID'];
  articleID: Scalars['ID'];
};

export type PeerProfile = {
  __typename?: 'PeerProfile';
  name: Scalars['String'];
  logo?: Maybe<Image>;
  themeColor: Scalars['Color'];
  hostURL: Scalars['String'];
  websiteURL: Scalars['String'];
  callToActionText: Scalars['RichText'];
  callToActionURL: Scalars['String'];
};

export type PeerProfileInput = {
  name: Scalars['String'];
  logoID?: Maybe<Scalars['ID']>;
  themeColor: Scalars['Color'];
  callToActionText: Scalars['RichText'];
  callToActionURL: Scalars['String'];
};

export type Permission = {
  __typename?: 'Permission';
  id: Scalars['String'];
  description: Scalars['String'];
  deprecated: Scalars['Boolean'];
};

export type Point = {
  __typename?: 'Point';
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type Properties = {
  __typename?: 'Properties';
  key: Scalars['String'];
  value: Scalars['String'];
  public: Scalars['Boolean'];
};

export type PropertiesInput = {
  key: Scalars['String'];
  value: Scalars['String'];
  public: Scalars['Boolean'];
};

export type Query = {
  __typename?: 'Query';
  content: Content;
  config: Config;
  peerProfile: PeerProfile;
  peers?: Maybe<Array<Peer>>;
  peer?: Maybe<Peer>;
  me?: Maybe<User>;
  sessions: Array<Session>;
  authProviders: Array<AuthProvider>;
  user?: Maybe<User>;
  users: UserConnection;
  userRole?: Maybe<UserRole>;
  userRoles: UserRoleConnection;
  permissions?: Maybe<Array<Permission>>;
  tokens: Array<Token>;
  navigation?: Maybe<Navigation>;
  navigations: Array<Navigation>;
  author?: Maybe<Author>;
  authors: AuthorConnection;
  image?: Maybe<Image>;
  images: ImageConnection;
  comments: CommentConnection;
  article?: Maybe<Article>;
  articles: ArticleConnection;
  peerArticle?: Maybe<Article>;
  peerArticles: PeerArticleConnection;
  articlePreviewLink?: Maybe<Scalars['String']>;
  page?: Maybe<Page>;
  pages: PageConnection;
  memberPlan?: Maybe<MemberPlan>;
  memberPlans: MemberPlanConnection;
  paymentMethod?: Maybe<PaymentMethod>;
  paymentMethods: Array<PaymentMethod>;
  paymentProviders: Array<PaymentProvider>;
  invoice?: Maybe<Invoice>;
  invoices: InvoiceConnection;
  payment?: Maybe<Payment>;
  payments: PaymentConnection;
};


export type QueryPeerArgs = {
  id: Scalars['ID'];
};


export type QueryAuthProvidersArgs = {
  redirectUri?: Maybe<Scalars['String']>;
};


export type QueryUserArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryUsersArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  filter?: Maybe<UserFilter>;
  sort?: Maybe<UserSort>;
  order?: Maybe<SortOrder>;
};


export type QueryUserRoleArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryUserRolesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<UserRoleFilter>;
  sort?: Maybe<UserRoleSort>;
  order?: Maybe<SortOrder>;
};


export type QueryNavigationArgs = {
  id?: Maybe<Scalars['ID']>;
  key?: Maybe<Scalars['ID']>;
};


export type QueryAuthorArgs = {
  id?: Maybe<Scalars['ID']>;
  slug?: Maybe<Scalars['Slug']>;
};


export type QueryAuthorsArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<AuthorFilter>;
  sort?: Maybe<AuthorSort>;
  order?: Maybe<SortOrder>;
};


export type QueryImageArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryImagesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<ImageFilter>;
  sort?: Maybe<ImageSort>;
  order?: Maybe<SortOrder>;
};


export type QueryCommentsArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  filter?: Maybe<CommentFilter>;
  sort?: Maybe<CommentSort>;
  order?: Maybe<SortOrder>;
};


export type QueryArticleArgs = {
  id: Scalars['ID'];
};


export type QueryArticlesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};


export type QueryPeerArticleArgs = {
  peerID: Scalars['ID'];
  id: Scalars['ID'];
};


export type QueryPeerArticlesArgs = {
  after?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  filter?: Maybe<ArticleFilter>;
  sort?: Maybe<ArticleSort>;
  order?: Maybe<SortOrder>;
};


export type QueryArticlePreviewLinkArgs = {
  id: Scalars['ID'];
  hours: Scalars['Int'];
};


export type QueryPageArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryPagesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<PageFilter>;
  skip?: Maybe<Scalars['Int']>;
  sort?: Maybe<PageSort>;
  order?: Maybe<SortOrder>;
};


export type QueryMemberPlanArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryMemberPlansArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<MemberPlanFilter>;
  sort?: Maybe<MemberPlanSort>;
  order?: Maybe<SortOrder>;
};


export type QueryPaymentMethodArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryInvoiceArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryInvoicesArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<InvoiceFilter>;
  sort?: Maybe<InvoiceSort>;
  order?: Maybe<SortOrder>;
};


export type QueryPaymentArgs = {
  id?: Maybe<Scalars['ID']>;
};


export type QueryPaymentsArgs = {
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  filter?: Maybe<PaymentFilter>;
  sort?: Maybe<PaymentSort>;
  order?: Maybe<SortOrder>;
};

export type QuoteBlock = {
  __typename?: 'QuoteBlock';
  quote?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
};

export type QuoteBlockInput = {
  quote?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
};

export type Ref__Media = {
  __typename?: 'ref__media';
  recordId: Scalars['ID'];
  contentType: Scalars['ID'];
  peerId?: Maybe<Scalars['ID']>;
  record?: Maybe<Image>;
  peer?: Maybe<Peer>;
};

export type Ref_Article_Page = {
  __typename?: 'ref_article_page';
  recordId: Scalars['ID'];
  contentType: Scalars['ID'];
  peerId?: Maybe<Scalars['ID']>;
  record?: Maybe<_Cmp_Article_Record_Content_Blocks_TeaserGrid_Teasers_ContentRef>;
  peer?: Maybe<Peer>;
};

export type Ref_Input = {
  recordId: Scalars['ID'];
  contentType: Scalars['ID'];
  peerId?: Maybe<Scalars['ID']>;
  record?: Maybe<Scalars['Unknown']>;
  peer?: Maybe<Scalars['Unknown']>;
};

export type Ref_ModelA = {
  __typename?: 'ref_modelA';
  recordId: Scalars['ID'];
  contentType: Scalars['ID'];
  peerId?: Maybe<Scalars['ID']>;
  record?: Maybe<_Cmp_ModelA_Record>;
  peer?: Maybe<Peer>;
};

export type Ref_ModelA_ModelB__Media = {
  __typename?: 'ref_modelA_modelB__media';
  recordId: Scalars['ID'];
  contentType: Scalars['ID'];
  peerId?: Maybe<Scalars['ID']>;
  record?: Maybe<_Cmp_ModelA_Record_Content_MyRef>;
  peer?: Maybe<Peer>;
};


export type RichTextBlock = {
  __typename?: 'RichTextBlock';
  richText: Scalars['RichText'];
};

export type RichTextBlockInput = {
  richText: Scalars['RichText'];
};

export type Session = {
  __typename?: 'Session';
  id: Scalars['ID'];
  user: User;
  createdAt: Scalars['DateTime'];
  expiresAt: Scalars['DateTime'];
};

export type SessionWithToken = {
  __typename?: 'SessionWithToken';
  id: Scalars['ID'];
  user: User;
  token: Scalars['String'];
  createdAt: Scalars['DateTime'];
  expiresAt: Scalars['DateTime'];
};


export enum SortOrder {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

export type SoundCloudTrackBlock = {
  __typename?: 'SoundCloudTrackBlock';
  trackID: Scalars['String'];
};

export type SoundCloudTrackBlockInput = {
  trackID: Scalars['String'];
};

export type Teaser = ArticleTeaser | PeerArticleTeaser | PageTeaser;

export type TeaserGridBlock = {
  __typename?: 'TeaserGridBlock';
  teasers: Array<Maybe<Teaser>>;
  numColumns: Scalars['Int'];
};

export type TeaserGridBlockInput = {
  teasers: Array<Maybe<TeaserInput>>;
  numColumns: Scalars['Int'];
};

export type TeaserInput = {
  article?: Maybe<ArticleTeaserInput>;
  peerArticle?: Maybe<PeerArticleTeaserInput>;
  page?: Maybe<PageTeaserInput>;
};

export enum TeaserStyle {
  Default = 'DEFAULT',
  Light = 'LIGHT',
  Text = 'TEXT'
}

export type TitleBlock = {
  __typename?: 'TitleBlock';
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
};

export type TitleBlockInput = {
  title?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
};

export type Token = {
  __typename?: 'Token';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
};

export type TokenInput = {
  name: Scalars['String'];
};

export type TwitterTweetBlock = {
  __typename?: 'TwitterTweetBlock';
  userID: Scalars['String'];
  tweetID: Scalars['String'];
};

export type TwitterTweetBlockInput = {
  userID: Scalars['String'];
  tweetID: Scalars['String'];
};

export type UnidirectionalPageInfo = {
  __typename?: 'UnidirectionalPageInfo';
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
};


export type UpdateImageInput = {
  filename?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  source?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  license?: Maybe<Scalars['String']>;
  focalPoint?: Maybe<InputPoint>;
};

export type UpdatePeerInput = {
  name: Scalars['String'];
  slug: Scalars['String'];
  hostURL: Scalars['String'];
  token?: Maybe<Scalars['String']>;
};


export type UploadImageInput = {
  file: Scalars['Upload'];
  filename?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  tags?: Maybe<Array<Scalars['String']>>;
  source?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  license?: Maybe<Scalars['String']>;
  focalPoint?: Maybe<InputPoint>;
};

export type User = {
  __typename?: 'User';
  id: Scalars['String'];
  createdAt: Scalars['DateTime'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  email: Scalars['String'];
  preferredName?: Maybe<Scalars['String']>;
  address?: Maybe<UserAddress>;
  active: Scalars['Boolean'];
  lastLogin?: Maybe<Scalars['DateTime']>;
  properties: Array<Properties>;
  roles: Array<UserRole>;
  subscription?: Maybe<UserSubscription>;
};

export type UserAddress = {
  __typename?: 'UserAddress';
  company?: Maybe<Scalars['String']>;
  streetAddress: Scalars['String'];
  streetAddress2?: Maybe<Scalars['String']>;
  zipCode: Scalars['String'];
  city: Scalars['String'];
  country: Scalars['String'];
};

export type UserAddressInput = {
  company?: Maybe<Scalars['String']>;
  streetAddress: Scalars['String'];
  streetAddress2?: Maybe<Scalars['String']>;
  zipCode: Scalars['String'];
  city: Scalars['String'];
  country: Scalars['String'];
};

export type UserConnection = {
  __typename?: 'UserConnection';
  nodes: Array<User>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserFilter = {
  name?: Maybe<Scalars['String']>;
  text?: Maybe<Scalars['String']>;
  subscription?: Maybe<UserSubscriptionFilter>;
};

export type UserInput = {
  name: Scalars['String'];
  email: Scalars['String'];
  preferredName?: Maybe<Scalars['String']>;
  address?: Maybe<UserAddressInput>;
  active: Scalars['Boolean'];
  properties: Array<PropertiesInput>;
  roleIDs?: Maybe<Array<Scalars['String']>>;
};

export type UserRole = {
  __typename?: 'UserRole';
  id: Scalars['String'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  systemRole: Scalars['Boolean'];
  permissions: Array<Permission>;
};

export type UserRoleConnection = {
  __typename?: 'UserRoleConnection';
  nodes: Array<UserRole>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserRoleFilter = {
  name?: Maybe<Scalars['String']>;
};

export type UserRoleInput = {
  name: Scalars['String'];
  description: Scalars['String'];
  permissionIDs?: Maybe<Array<Scalars['String']>>;
};

export enum UserRoleSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT'
}

export enum UserSort {
  CreatedAt = 'CREATED_AT',
  ModifiedAt = 'MODIFIED_AT',
  Name = 'NAME'
}

export type UserSubscription = {
  __typename?: 'UserSubscription';
  memberPlan: MemberPlan;
  paymentPeriodicity: PaymentPeriodicity;
  monthlyAmount: Scalars['Int'];
  autoRenew: Scalars['Boolean'];
  startsAt: Scalars['DateTime'];
  paidUntil?: Maybe<Scalars['DateTime']>;
  paymentMethod: PaymentMethod;
  deactivatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserSubscriptionFilter = {
  startsAt?: Maybe<DateFilter>;
  paidUntil?: Maybe<DateFilter>;
  deactivatedAt?: Maybe<DateFilter>;
  autoRenew?: Maybe<Scalars['Boolean']>;
};

export type UserSubscriptionInput = {
  memberPlanID: Scalars['String'];
  paymentPeriodicity: PaymentPeriodicity;
  monthlyAmount: Scalars['Int'];
  autoRenew: Scalars['Boolean'];
  startsAt: Scalars['DateTime'];
  paidUntil?: Maybe<Scalars['DateTime']>;
  paymentMethodID: Scalars['String'];
  deactivatedAt?: Maybe<Scalars['DateTime']>;
};

export type VimeoVideoBlock = {
  __typename?: 'VimeoVideoBlock';
  videoID: Scalars['String'];
};

export type VimeoVideoBlockInput = {
  videoID: Scalars['String'];
};

export type YouTubeVideoBlock = {
  __typename?: 'YouTubeVideoBlock';
  videoID: Scalars['String'];
};

export type YouTubeVideoBlockInput = {
  videoID: Scalars['String'];
};

export type MutationArticleFragment = (
  { __typename?: 'Article' }
  & Pick<Article, 'id'>
  & { draft?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishAt' | 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  ) }
);

export type ArticleRefFragment = (
  { __typename?: 'Article' }
  & Pick<Article, 'id' | 'createdAt' | 'modifiedAt'>
  & { draft?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'ArticleRevision' }
    & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision' | 'preTitle' | 'title' | 'lead'>
    & { authors: Array<Maybe<(
      { __typename?: 'Author' }
      & Pick<Author, 'name'>
    )>>, image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  ) }
);

export type ArticleListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  order?: Maybe<SortOrder>;
  sort?: Maybe<ArticleSort>;
}>;


export type ArticleListQuery = (
  { __typename?: 'Query' }
  & { articles: (
    { __typename?: 'ArticleConnection' }
    & Pick<ArticleConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'Article' }
      & ArticleRefFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type PeerArticleListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
}>;


export type PeerArticleListQuery = (
  { __typename?: 'Query' }
  & { peerArticles: (
    { __typename?: 'PeerArticleConnection' }
    & Pick<PeerArticleConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'PeerArticle' }
      & { peer: (
        { __typename?: 'Peer' }
        & PeerWithProfileFragment
      ), article: (
        { __typename?: 'Article' }
        & ArticleRefFragment
      ) }
    )>, pageInfo: (
      { __typename?: 'UnidirectionalPageInfo' }
      & Pick<UnidirectionalPageInfo, 'endCursor' | 'hasNextPage'>
    ) }
  ) }
);

export type CreateArticleMutationVariables = Exact<{
  input: ArticleInput;
}>;


export type CreateArticleMutation = (
  { __typename?: 'Mutation' }
  & { createArticle: (
    { __typename?: 'Article' }
    & MutationArticleFragment
  ) }
);

export type UpdateArticleMutationVariables = Exact<{
  id: Scalars['ID'];
  input: ArticleInput;
}>;


export type UpdateArticleMutation = (
  { __typename?: 'Mutation' }
  & { updateArticle?: Maybe<(
    { __typename?: 'Article' }
    & MutationArticleFragment
  )> }
);

export type PublishArticleMutationVariables = Exact<{
  id: Scalars['ID'];
  publishAt: Scalars['DateTime'];
  publishedAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
}>;


export type PublishArticleMutation = (
  { __typename?: 'Mutation' }
  & { publishArticle?: Maybe<(
    { __typename?: 'Article' }
    & MutationArticleFragment
  )> }
);

export type UnpublishArticleMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UnpublishArticleMutation = (
  { __typename?: 'Mutation' }
  & { unpublishArticle?: Maybe<(
    { __typename?: 'Article' }
    & MutationArticleFragment
  )> }
);

export type DeleteArticleMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteArticleMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteArticle'>
);

export type DuplicateArticleMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DuplicateArticleMutation = (
  { __typename?: 'Mutation' }
  & { duplicateArticle: (
    { __typename?: 'Article' }
    & MutationArticleFragment
  ) }
);

export type ArticlePreviewLinkQueryVariables = Exact<{
  id: Scalars['ID'];
  hours: Scalars['Int'];
}>;


export type ArticlePreviewLinkQuery = (
  { __typename?: 'Query' }
  & Pick<Query, 'articlePreviewLink'>
);

export type ArticleQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ArticleQuery = (
  { __typename?: 'Query' }
  & { article?: Maybe<(
    { __typename?: 'Article' }
    & Pick<Article, 'id' | 'shared'>
    & { pending?: Maybe<(
      { __typename?: 'ArticleRevision' }
      & Pick<ArticleRevision, 'publishAt'>
    )>, published?: Maybe<(
      { __typename?: 'ArticleRevision' }
      & Pick<ArticleRevision, 'publishedAt' | 'updatedAt'>
    )>, latest: (
      { __typename?: 'ArticleRevision' }
      & Pick<ArticleRevision, 'publishedAt' | 'updatedAt' | 'revision' | 'slug' | 'preTitle' | 'title' | 'lead' | 'seoTitle' | 'tags' | 'hideAuthor' | 'breaking' | 'socialMediaTitle' | 'socialMediaDescription'>
      & { image?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, properties: Array<(
        { __typename?: 'Properties' }
        & Pick<Properties, 'key' | 'value' | 'public'>
      )>, authors: Array<Maybe<(
        { __typename?: 'Author' }
        & AuthorRefFragment
      )>>, socialMediaAuthors: Array<(
        { __typename?: 'Author' }
        & AuthorRefFragment
      )>, socialMediaImage?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, blocks: Array<(
        { __typename?: 'RichTextBlock' }
        & FullBlock_RichTextBlock_Fragment
      ) | (
        { __typename?: 'ImageBlock' }
        & FullBlock_ImageBlock_Fragment
      ) | (
        { __typename?: 'ImageGalleryBlock' }
        & FullBlock_ImageGalleryBlock_Fragment
      ) | (
        { __typename?: 'ListicleBlock' }
        & FullBlock_ListicleBlock_Fragment
      ) | (
        { __typename?: 'FacebookPostBlock' }
        & FullBlock_FacebookPostBlock_Fragment
      ) | (
        { __typename?: 'FacebookVideoBlock' }
        & FullBlock_FacebookVideoBlock_Fragment
      ) | (
        { __typename?: 'InstagramPostBlock' }
        & FullBlock_InstagramPostBlock_Fragment
      ) | (
        { __typename?: 'TwitterTweetBlock' }
        & FullBlock_TwitterTweetBlock_Fragment
      ) | (
        { __typename?: 'VimeoVideoBlock' }
        & FullBlock_VimeoVideoBlock_Fragment
      ) | (
        { __typename?: 'YouTubeVideoBlock' }
        & FullBlock_YouTubeVideoBlock_Fragment
      ) | (
        { __typename?: 'SoundCloudTrackBlock' }
        & FullBlock_SoundCloudTrackBlock_Fragment
      ) | (
        { __typename?: 'EmbedBlock' }
        & FullBlock_EmbedBlock_Fragment
      ) | (
        { __typename?: 'LinkPageBreakBlock' }
        & FullBlock_LinkPageBreakBlock_Fragment
      ) | (
        { __typename?: 'TitleBlock' }
        & FullBlock_TitleBlock_Fragment
      ) | (
        { __typename?: 'QuoteBlock' }
        & FullBlock_QuoteBlock_Fragment
      ) | (
        { __typename?: 'TeaserGridBlock' }
        & FullBlock_TeaserGridBlock_Fragment
      )> }
    ) }
  )> }
);

export type CreateSessionMutationVariables = Exact<{
  email: Scalars['String'];
  password: Scalars['String'];
}>;


export type CreateSessionMutation = (
  { __typename?: 'Mutation' }
  & { createSession: (
    { __typename?: 'SessionWithToken' }
    & Pick<SessionWithToken, 'token'>
    & { user: (
      { __typename?: 'User' }
      & Pick<User, 'email'>
      & { roles: Array<(
        { __typename?: 'UserRole' }
        & FullUserRoleFragment
      )> }
    ) }
  ) }
);

export type GetAuthProvidersQueryVariables = Exact<{
  redirectUri: Scalars['String'];
}>;


export type GetAuthProvidersQuery = (
  { __typename?: 'Query' }
  & { authProviders: Array<(
    { __typename?: 'AuthProvider' }
    & Pick<AuthProvider, 'name' | 'url'>
  )> }
);

export type CreateSessionWithOAuth2CodeMutationVariables = Exact<{
  redirectUri: Scalars['String'];
  name: Scalars['String'];
  code: Scalars['String'];
}>;


export type CreateSessionWithOAuth2CodeMutation = (
  { __typename?: 'Mutation' }
  & { createSessionWithOAuth2Code: (
    { __typename?: 'SessionWithToken' }
    & Pick<SessionWithToken, 'token'>
    & { user: (
      { __typename?: 'User' }
      & Pick<User, 'email'>
      & { roles: Array<(
        { __typename?: 'UserRole' }
        & FullUserRoleFragment
      )> }
    ) }
  ) }
);

export type CreateSessionWithJwtMutationVariables = Exact<{
  jwt: Scalars['String'];
}>;


export type CreateSessionWithJwtMutation = (
  { __typename?: 'Mutation' }
  & { createSessionWithJWT: (
    { __typename?: 'SessionWithToken' }
    & Pick<SessionWithToken, 'token'>
    & { user: (
      { __typename?: 'User' }
      & Pick<User, 'email'>
      & { roles: Array<(
        { __typename?: 'UserRole' }
        & FullUserRoleFragment
      )> }
    ) }
  ) }
);

export type AuthorRefFragment = (
  { __typename?: 'Author' }
  & Pick<Author, 'id' | 'name' | 'jobTitle'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

export type FullAuthorFragment = (
  { __typename?: 'Author' }
  & Pick<Author, 'slug' | 'bio'>
  & { links?: Maybe<Array<(
    { __typename?: 'AuthorLink' }
    & Pick<AuthorLink, 'title' | 'url'>
  )>> }
  & AuthorRefFragment
);

export type AuthorListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type AuthorListQuery = (
  { __typename?: 'Query' }
  & { authors: (
    { __typename?: 'AuthorConnection' }
    & Pick<AuthorConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'Author' }
      & FullAuthorFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type AuthorQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type AuthorQuery = (
  { __typename?: 'Query' }
  & { author?: Maybe<(
    { __typename?: 'Author' }
    & FullAuthorFragment
  )> }
);

export type CreateAuthorMutationVariables = Exact<{
  input: AuthorInput;
}>;


export type CreateAuthorMutation = (
  { __typename?: 'Mutation' }
  & { createAuthor?: Maybe<(
    { __typename?: 'Author' }
    & FullAuthorFragment
  )> }
);

export type UpdateAuthorMutationVariables = Exact<{
  id: Scalars['ID'];
  input: AuthorInput;
}>;


export type UpdateAuthorMutation = (
  { __typename?: 'Mutation' }
  & { updateAuthor?: Maybe<(
    { __typename?: 'Author' }
    & FullAuthorFragment
  )> }
);

export type DeleteAuthorMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteAuthorMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteAuthor'>
);

type FullTeaser_ArticleTeaser_Fragment = (
  { __typename?: 'ArticleTeaser' }
  & Pick<ArticleTeaser, 'style' | 'preTitle' | 'title' | 'lead'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )>, article?: Maybe<(
    { __typename?: 'Article' }
    & ArticleRefFragment
  )> }
);

type FullTeaser_PeerArticleTeaser_Fragment = (
  { __typename?: 'PeerArticleTeaser' }
  & Pick<PeerArticleTeaser, 'style' | 'preTitle' | 'title' | 'lead' | 'articleID'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )>, peer?: Maybe<(
    { __typename?: 'Peer' }
    & PeerWithProfileFragment
  )>, article?: Maybe<(
    { __typename?: 'Article' }
    & ArticleRefFragment
  )> }
);

type FullTeaser_PageTeaser_Fragment = (
  { __typename?: 'PageTeaser' }
  & Pick<PageTeaser, 'style' | 'preTitle' | 'title' | 'lead'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )>, page?: Maybe<(
    { __typename?: 'Page' }
    & PageRefFragment
  )> }
);

export type FullTeaserFragment = FullTeaser_ArticleTeaser_Fragment | FullTeaser_PeerArticleTeaser_Fragment | FullTeaser_PageTeaser_Fragment;

type FullBlock_RichTextBlock_Fragment = (
  { __typename: 'RichTextBlock' }
  & Pick<RichTextBlock, 'richText'>
);

type FullBlock_ImageBlock_Fragment = (
  { __typename: 'ImageBlock' }
  & Pick<ImageBlock, 'caption'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

type FullBlock_ImageGalleryBlock_Fragment = (
  { __typename: 'ImageGalleryBlock' }
  & { images: Array<(
    { __typename?: 'GalleryImageEdge' }
    & Pick<GalleryImageEdge, 'caption'>
    & { image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  )> }
);

type FullBlock_ListicleBlock_Fragment = (
  { __typename: 'ListicleBlock' }
  & { items: Array<(
    { __typename?: 'ListicleItem' }
    & Pick<ListicleItem, 'title' | 'richText'>
    & { image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  )> }
);

type FullBlock_FacebookPostBlock_Fragment = (
  { __typename: 'FacebookPostBlock' }
  & Pick<FacebookPostBlock, 'userID' | 'postID'>
);

type FullBlock_FacebookVideoBlock_Fragment = (
  { __typename: 'FacebookVideoBlock' }
  & Pick<FacebookVideoBlock, 'userID' | 'videoID'>
);

type FullBlock_InstagramPostBlock_Fragment = (
  { __typename: 'InstagramPostBlock' }
  & Pick<InstagramPostBlock, 'postID'>
);

type FullBlock_TwitterTweetBlock_Fragment = (
  { __typename: 'TwitterTweetBlock' }
  & Pick<TwitterTweetBlock, 'userID' | 'tweetID'>
);

type FullBlock_VimeoVideoBlock_Fragment = (
  { __typename: 'VimeoVideoBlock' }
  & Pick<VimeoVideoBlock, 'videoID'>
);

type FullBlock_YouTubeVideoBlock_Fragment = (
  { __typename: 'YouTubeVideoBlock' }
  & Pick<YouTubeVideoBlock, 'videoID'>
);

type FullBlock_SoundCloudTrackBlock_Fragment = (
  { __typename: 'SoundCloudTrackBlock' }
  & Pick<SoundCloudTrackBlock, 'trackID'>
);

type FullBlock_EmbedBlock_Fragment = (
  { __typename: 'EmbedBlock' }
  & Pick<EmbedBlock, 'url' | 'title' | 'width' | 'height' | 'styleCustom'>
);

type FullBlock_LinkPageBreakBlock_Fragment = (
  { __typename: 'LinkPageBreakBlock' }
  & Pick<LinkPageBreakBlock, 'text' | 'linkText' | 'linkURL' | 'styleOption' | 'richText' | 'linkTarget' | 'hideButton' | 'templateOption' | 'layoutOption'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

type FullBlock_TitleBlock_Fragment = (
  { __typename: 'TitleBlock' }
  & Pick<TitleBlock, 'title' | 'lead'>
);

type FullBlock_QuoteBlock_Fragment = (
  { __typename: 'QuoteBlock' }
  & Pick<QuoteBlock, 'quote' | 'author'>
);

type FullBlock_TeaserGridBlock_Fragment = (
  { __typename: 'TeaserGridBlock' }
  & Pick<TeaserGridBlock, 'numColumns'>
  & { teasers: Array<Maybe<(
    { __typename?: 'ArticleTeaser' }
    & FullTeaser_ArticleTeaser_Fragment
  ) | (
    { __typename?: 'PeerArticleTeaser' }
    & FullTeaser_PeerArticleTeaser_Fragment
  ) | (
    { __typename?: 'PageTeaser' }
    & FullTeaser_PageTeaser_Fragment
  )>> }
);

export type FullBlockFragment = FullBlock_RichTextBlock_Fragment | FullBlock_ImageBlock_Fragment | FullBlock_ImageGalleryBlock_Fragment | FullBlock_ListicleBlock_Fragment | FullBlock_FacebookPostBlock_Fragment | FullBlock_FacebookVideoBlock_Fragment | FullBlock_InstagramPostBlock_Fragment | FullBlock_TwitterTweetBlock_Fragment | FullBlock_VimeoVideoBlock_Fragment | FullBlock_YouTubeVideoBlock_Fragment | FullBlock_SoundCloudTrackBlock_Fragment | FullBlock_EmbedBlock_Fragment | FullBlock_LinkPageBreakBlock_Fragment | FullBlock_TitleBlock_Fragment | FullBlock_QuoteBlock_Fragment | FullBlock_TeaserGridBlock_Fragment;

export type FullCommentFragment = (
  { __typename?: 'Comment' }
  & Pick<Comment, 'id' | 'state' | 'rejectionReason' | 'createdAt' | 'modifiedAt'>
  & { user: (
    { __typename?: 'User' }
    & FullUserFragment
  ), revisions: Array<(
    { __typename?: 'CommentRevision' }
    & Pick<CommentRevision, 'text' | 'createdAt'>
  )> }
);

export type CommentListQueryVariables = Exact<{
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  order?: Maybe<SortOrder>;
  sort?: Maybe<CommentSort>;
}>;


export type CommentListQuery = (
  { __typename?: 'Query' }
  & { comments: (
    { __typename?: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'Comment' }
      & FullCommentFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type ApproveCommentMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ApproveCommentMutation = (
  { __typename?: 'Mutation' }
  & { approveComment: (
    { __typename?: 'Comment' }
    & Pick<Comment, 'state'>
  ) }
);

export type RejectCommentMutationVariables = Exact<{
  id: Scalars['ID'];
  rejectionReason: CommentRejectionReason;
}>;


export type RejectCommentMutation = (
  { __typename?: 'Mutation' }
  & { rejectComment: (
    { __typename?: 'Comment' }
    & Pick<Comment, 'state' | 'rejectionReason'>
  ) }
);

export type RequestChangesOnCommentMutationVariables = Exact<{
  id: Scalars['ID'];
  rejectionReason: CommentRejectionReason;
}>;


export type RequestChangesOnCommentMutation = (
  { __typename?: 'Mutation' }
  & { requestChangesOnComment: (
    { __typename?: 'Comment' }
    & Pick<Comment, 'state' | 'rejectionReason'>
  ) }
);

export type ContentListQueryVariables = Exact<{
  type: ContentTypeEnum;
  context?: Maybe<ContentContextEnum>;
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
}>;


export type ContentListQuery = (
  { __typename?: 'Query' }
  & { content: (
    { __typename?: 'content' }
    & { _all: (
      { __typename?: 'All' }
      & { list: (
        { __typename?: 'listByTypeConnection' }
        & Pick<ListByTypeConnection, 'totalCount'>
        & { nodes: Array<(
          { __typename?: 'listByTypePeerCustomContent' }
          & { peer?: Maybe<(
            { __typename?: 'Peer' }
            & Pick<Peer, 'id' | 'name'>
          )>, content: (
            { __typename?: 'ContentModelSummary' }
            & ContentListRefFragment
          ) }
        )>, pageInfo: (
          { __typename?: 'PageInfo' }
          & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
        ) }
      ) }
    ) }
  ) }
);

export type ContentGetQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ContentGetQuery = (
  { __typename?: 'Query' }
  & { content: (
    { __typename?: 'content' }
    & { _all: (
      { __typename?: 'All' }
      & { read: (
        { __typename?: 'ContentModelSummary' }
        & ContentListRefFragment
      ) }
    ) }
  ) }
);

export type ContentListRefFragment = (
  { __typename?: 'ContentModelSummary' }
  & Pick<ContentModelSummary, 'id' | 'title' | 'shared' | 'contentType' | 'revision' | 'state' | 'createdAt' | 'modifiedAt' | 'publicationDate' | 'dePublicationDate'>
);

export type PublishContentMutationVariables = Exact<{
  id: Scalars['ID'];
  publishAt: Scalars['DateTime'];
  publishedAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
}>;


export type PublishContentMutation = (
  { __typename?: 'Mutation' }
  & { content: (
    { __typename?: 'content_mutations' }
    & { _all: (
      { __typename?: 'AllMutations' }
      & { publish?: Maybe<(
        { __typename?: 'AllCustomContents' }
        & Pick<AllCustomContents, 'id'>
        & { pending?: Maybe<(
          { __typename?: 'AllCustomContentsRevision' }
          & Pick<AllCustomContentsRevision, 'publishAt'>
        )>, published?: Maybe<(
          { __typename?: 'AllCustomContentsRevision' }
          & Pick<AllCustomContentsRevision, 'publishedAt'>
        )> }
      )> }
    ) }
  ) }
);

export type UnpublishContentMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UnpublishContentMutation = (
  { __typename?: 'Mutation' }
  & { content: (
    { __typename?: 'content_mutations' }
    & { _all: (
      { __typename?: 'AllMutations' }
      & { unpublish?: Maybe<(
        { __typename?: 'AllCustomContents' }
        & Pick<AllCustomContents, 'id'>
        & { pending?: Maybe<(
          { __typename?: 'AllCustomContentsRevision' }
          & Pick<AllCustomContentsRevision, 'publishAt'>
        )>, published?: Maybe<(
          { __typename?: 'AllCustomContentsRevision' }
          & Pick<AllCustomContentsRevision, 'publishedAt'>
        )> }
      )> }
    ) }
  ) }
);

export type DeleteContentMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteContentMutation = (
  { __typename?: 'Mutation' }
  & { content: (
    { __typename?: 'content_mutations' }
    & { _all: (
      { __typename?: 'AllMutations' }
      & Pick<AllMutations, 'delete'>
    ) }
  ) }
);

export type ConfigQueryVariables = Exact<{ [key: string]: never; }>;


export type ConfigQuery = (
  { __typename?: 'Query' }
  & { config: (
    { __typename?: 'Config' }
    & { content: Array<(
      { __typename?: 'ContentConfig' }
      & Pick<ContentConfig, 'id' | 'identifier' | 'namePlural' | 'nameSingular' | 'schema'>
    )>, languages: (
      { __typename?: 'LanguagesConfig' }
      & Pick<LanguagesConfig, 'defaultLanguageId'>
      & { languages: Array<(
        { __typename?: 'LanguageConfig' }
        & Pick<LanguageConfig, 'id' | 'tag' | 'description'>
      )> }
    ) }
  ) }
);

export type ImageUrLsFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'url'>
  & { largeURL: Image['transformURL'], mediumURL: Image['transformURL'], thumbURL: Image['transformURL'], squareURL: Image['transformURL'], previewURL: Image['transformURL'], column1URL: Image['transformURL'], column6URL: Image['transformURL'] }
);

export type ImageRefFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id' | 'filename' | 'extension' | 'title' | 'description' | 'width' | 'height'>
  & ImageUrLsFragment
);

export type FullImageFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id' | 'createdAt' | 'modifiedAt' | 'filename' | 'extension' | 'width' | 'height' | 'fileSize' | 'description' | 'tags' | 'author' | 'source' | 'license'>
  & { focalPoint?: Maybe<(
    { __typename?: 'Point' }
    & Pick<Point, 'x' | 'y'>
  )> }
  & ImageRefFragment
);

export type ImageListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type ImageListQuery = (
  { __typename?: 'Query' }
  & { images: (
    { __typename?: 'ImageConnection' }
    & { nodes: Array<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type ImageQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ImageQuery = (
  { __typename?: 'Query' }
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & FullImageFragment
  )> }
);

export type UploadImageMutationVariables = Exact<{
  input: UploadImageInput;
}>;


export type UploadImageMutation = (
  { __typename?: 'Mutation' }
  & { uploadImage?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

export type UpdateImageMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UpdateImageInput;
}>;


export type UpdateImageMutation = (
  { __typename?: 'Mutation' }
  & { updateImage?: Maybe<(
    { __typename?: 'Image' }
    & FullImageFragment
  )> }
);

export type DeleteImageMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteImageMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteImage'>
);

export type MemberPlanRefFragment = (
  { __typename?: 'MemberPlan' }
  & Pick<MemberPlan, 'id' | 'name' | 'slug' | 'active'>
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

export type FullMemberPlanFragment = (
  { __typename?: 'MemberPlan' }
  & Pick<MemberPlan, 'description' | 'amountPerMonthMin'>
  & { availablePaymentMethods: Array<(
    { __typename?: 'AvailablePaymentMethod' }
    & Pick<AvailablePaymentMethod, 'paymentPeriodicities' | 'forceAutoRenewal'>
    & { paymentMethods: Array<(
      { __typename?: 'PaymentMethod' }
      & FullPaymentMethodFragment
    )> }
  )> }
  & MemberPlanRefFragment
);

export type MemberPlanListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type MemberPlanListQuery = (
  { __typename?: 'Query' }
  & { memberPlans: (
    { __typename?: 'MemberPlanConnection' }
    & Pick<MemberPlanConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'MemberPlan' }
      & FullMemberPlanFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type MemberPlanQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type MemberPlanQuery = (
  { __typename?: 'Query' }
  & { memberPlan?: Maybe<(
    { __typename?: 'MemberPlan' }
    & FullMemberPlanFragment
  )> }
);

export type CreateMemberPlanMutationVariables = Exact<{
  input: MemberPlanInput;
}>;


export type CreateMemberPlanMutation = (
  { __typename?: 'Mutation' }
  & { createMemberPlan?: Maybe<(
    { __typename?: 'MemberPlan' }
    & FullMemberPlanFragment
  )> }
);

export type UpdateMemberPlanMutationVariables = Exact<{
  id: Scalars['ID'];
  input: MemberPlanInput;
}>;


export type UpdateMemberPlanMutation = (
  { __typename?: 'Mutation' }
  & { updateMemberPlan?: Maybe<(
    { __typename?: 'MemberPlan' }
    & FullMemberPlanFragment
  )> }
);

export type DeleteMemberPlanMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteMemberPlanMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteMemberPlan'>
);

export type FullNavigationFragment = (
  { __typename?: 'Navigation' }
  & Pick<Navigation, 'id' | 'key' | 'name'>
  & { links: Array<(
    { __typename: 'PageNavigationLink' }
    & Pick<PageNavigationLink, 'label'>
    & { page?: Maybe<(
      { __typename?: 'Page' }
      & PageRefFragment
    )> }
  ) | (
    { __typename: 'ArticleNavigationLink' }
    & Pick<ArticleNavigationLink, 'label'>
    & { article?: Maybe<(
      { __typename?: 'Article' }
      & ArticleRefFragment
    )> }
  ) | (
    { __typename: 'ExternalNavigationLink' }
    & Pick<ExternalNavigationLink, 'label' | 'url'>
  )> }
);

export type NavigationListQueryVariables = Exact<{ [key: string]: never; }>;


export type NavigationListQuery = (
  { __typename?: 'Query' }
  & { navigations: Array<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type NavigationQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type NavigationQuery = (
  { __typename?: 'Query' }
  & { navigation?: Maybe<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type CreateNavigationMutationVariables = Exact<{
  input: NavigationInput;
}>;


export type CreateNavigationMutation = (
  { __typename?: 'Mutation' }
  & { createNavigation?: Maybe<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type UpdateNavigationMutationVariables = Exact<{
  id: Scalars['ID'];
  input: NavigationInput;
}>;


export type UpdateNavigationMutation = (
  { __typename?: 'Mutation' }
  & { updateNavigation?: Maybe<(
    { __typename?: 'Navigation' }
    & FullNavigationFragment
  )> }
);

export type DeleteNavigationMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteNavigationMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteNavigation'>
);

export type MutationPageFragment = (
  { __typename?: 'Page' }
  & Pick<Page, 'id'>
  & { draft?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishAt' | 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  ) }
);

export type PageRefFragment = (
  { __typename?: 'Page' }
  & Pick<Page, 'id' | 'createdAt' | 'modifiedAt'>
  & { draft?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'revision'>
  )>, pending?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'revision'>
  )>, published?: Maybe<(
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision'>
  )>, latest: (
    { __typename?: 'PageRevision' }
    & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'revision' | 'title' | 'description'>
    & { image?: Maybe<(
      { __typename?: 'Image' }
      & ImageRefFragment
    )> }
  ) }
);

export type PageListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  order?: Maybe<SortOrder>;
  sort?: Maybe<PageSort>;
}>;


export type PageListQuery = (
  { __typename?: 'Query' }
  & { pages: (
    { __typename?: 'PageConnection' }
    & Pick<PageConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'Page' }
      & PageRefFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type CreatePageMutationVariables = Exact<{
  input: PageInput;
}>;


export type CreatePageMutation = (
  { __typename?: 'Mutation' }
  & { createPage: (
    { __typename?: 'Page' }
    & MutationPageFragment
  ) }
);

export type UpdatePageMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PageInput;
}>;


export type UpdatePageMutation = (
  { __typename?: 'Mutation' }
  & { updatePage?: Maybe<(
    { __typename?: 'Page' }
    & MutationPageFragment
  )> }
);

export type PublishPageMutationVariables = Exact<{
  id: Scalars['ID'];
  publishAt?: Maybe<Scalars['DateTime']>;
  publishedAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
}>;


export type PublishPageMutation = (
  { __typename?: 'Mutation' }
  & { publishPage?: Maybe<(
    { __typename?: 'Page' }
    & MutationPageFragment
  )> }
);

export type UnpublishPageMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UnpublishPageMutation = (
  { __typename?: 'Mutation' }
  & { unpublishPage?: Maybe<(
    { __typename?: 'Page' }
    & MutationPageFragment
  )> }
);

export type DeletePageMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeletePageMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deletePage'>
);

export type DuplicatePageMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DuplicatePageMutation = (
  { __typename?: 'Mutation' }
  & { duplicatePage: (
    { __typename?: 'Page' }
    & MutationPageFragment
  ) }
);

export type PageQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PageQuery = (
  { __typename?: 'Query' }
  & { page?: Maybe<(
    { __typename?: 'Page' }
    & Pick<Page, 'id'>
    & { pending?: Maybe<(
      { __typename?: 'PageRevision' }
      & Pick<PageRevision, 'publishAt'>
    )>, published?: Maybe<(
      { __typename?: 'PageRevision' }
      & Pick<PageRevision, 'publishedAt' | 'updatedAt'>
    )>, latest: (
      { __typename?: 'PageRevision' }
      & Pick<PageRevision, 'publishedAt' | 'updatedAt' | 'slug' | 'title' | 'description' | 'tags' | 'socialMediaTitle' | 'socialMediaDescription'>
      & { image?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, properties: Array<(
        { __typename?: 'Properties' }
        & Pick<Properties, 'key' | 'value' | 'public'>
      )>, socialMediaImage?: Maybe<(
        { __typename?: 'Image' }
        & ImageRefFragment
      )>, blocks: Array<(
        { __typename?: 'RichTextBlock' }
        & FullBlock_RichTextBlock_Fragment
      ) | (
        { __typename?: 'ImageBlock' }
        & FullBlock_ImageBlock_Fragment
      ) | (
        { __typename?: 'ImageGalleryBlock' }
        & FullBlock_ImageGalleryBlock_Fragment
      ) | (
        { __typename?: 'ListicleBlock' }
        & FullBlock_ListicleBlock_Fragment
      ) | (
        { __typename?: 'FacebookPostBlock' }
        & FullBlock_FacebookPostBlock_Fragment
      ) | (
        { __typename?: 'FacebookVideoBlock' }
        & FullBlock_FacebookVideoBlock_Fragment
      ) | (
        { __typename?: 'InstagramPostBlock' }
        & FullBlock_InstagramPostBlock_Fragment
      ) | (
        { __typename?: 'TwitterTweetBlock' }
        & FullBlock_TwitterTweetBlock_Fragment
      ) | (
        { __typename?: 'VimeoVideoBlock' }
        & FullBlock_VimeoVideoBlock_Fragment
      ) | (
        { __typename?: 'YouTubeVideoBlock' }
        & FullBlock_YouTubeVideoBlock_Fragment
      ) | (
        { __typename?: 'SoundCloudTrackBlock' }
        & FullBlock_SoundCloudTrackBlock_Fragment
      ) | (
        { __typename?: 'EmbedBlock' }
        & FullBlock_EmbedBlock_Fragment
      ) | (
        { __typename?: 'LinkPageBreakBlock' }
        & FullBlock_LinkPageBreakBlock_Fragment
      ) | (
        { __typename?: 'TitleBlock' }
        & FullBlock_TitleBlock_Fragment
      ) | (
        { __typename?: 'QuoteBlock' }
        & FullBlock_QuoteBlock_Fragment
      ) | (
        { __typename?: 'TeaserGridBlock' }
        & FullBlock_TeaserGridBlock_Fragment
      )> }
    ) }
  )> }
);

export type FullPaymentProviderFragment = (
  { __typename?: 'PaymentProvider' }
  & Pick<PaymentProvider, 'id' | 'name'>
);

export type FullPaymentMethodFragment = (
  { __typename?: 'PaymentMethod' }
  & Pick<PaymentMethod, 'id' | 'name' | 'createdAt' | 'modifiedAt' | 'description' | 'active'>
  & { paymentProvider: (
    { __typename?: 'PaymentProvider' }
    & FullPaymentProviderFragment
  ) }
);

export type PaymentProviderListQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentProviderListQuery = (
  { __typename?: 'Query' }
  & { paymentProviders: Array<(
    { __typename?: 'PaymentProvider' }
    & FullPaymentProviderFragment
  )> }
);

export type PaymentMethodListQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentMethodListQuery = (
  { __typename?: 'Query' }
  & { paymentMethods: Array<(
    { __typename?: 'PaymentMethod' }
    & FullPaymentMethodFragment
  )> }
);

export type PaymentMethodQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PaymentMethodQuery = (
  { __typename?: 'Query' }
  & { paymentMethod?: Maybe<(
    { __typename?: 'PaymentMethod' }
    & FullPaymentMethodFragment
  )> }
);

export type CreatePaymentMethodMutationVariables = Exact<{
  input: PaymentMethodInput;
}>;


export type CreatePaymentMethodMutation = (
  { __typename?: 'Mutation' }
  & { createPaymentMethod?: Maybe<(
    { __typename?: 'PaymentMethod' }
    & FullPaymentMethodFragment
  )> }
);

export type UpdatePaymentMethodMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PaymentMethodInput;
}>;


export type UpdatePaymentMethodMutation = (
  { __typename?: 'Mutation' }
  & { updatePaymentMethod?: Maybe<(
    { __typename?: 'PaymentMethod' }
    & FullPaymentMethodFragment
  )> }
);

export type DeletePaymentMethodMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeletePaymentMethodMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deletePaymentMethod'>
);

export type FullPeerProfileFragment = (
  { __typename?: 'PeerProfile' }
  & Pick<PeerProfile, 'name' | 'hostURL' | 'themeColor' | 'callToActionText' | 'callToActionURL'>
  & { logo?: Maybe<(
    { __typename?: 'Image' }
    & ImageRefFragment
  )> }
);

export type PeerRefFragment = (
  { __typename?: 'Peer' }
  & Pick<Peer, 'id' | 'name' | 'slug' | 'hostURL'>
);

export type PeerWithProfileFragment = (
  { __typename?: 'Peer' }
  & { profile?: Maybe<(
    { __typename?: 'PeerProfile' }
    & FullPeerProfileFragment
  )> }
  & PeerRefFragment
);

export type PeerProfileQueryVariables = Exact<{ [key: string]: never; }>;


export type PeerProfileQuery = (
  { __typename?: 'Query' }
  & { peerProfile: (
    { __typename?: 'PeerProfile' }
    & FullPeerProfileFragment
  ) }
);

export type UpdatePeerProfileMutationVariables = Exact<{
  input: PeerProfileInput;
}>;


export type UpdatePeerProfileMutation = (
  { __typename?: 'Mutation' }
  & { updatePeerProfile: (
    { __typename?: 'PeerProfile' }
    & FullPeerProfileFragment
  ) }
);

export type PeerListQueryVariables = Exact<{ [key: string]: never; }>;


export type PeerListQuery = (
  { __typename?: 'Query' }
  & { peers?: Maybe<Array<(
    { __typename?: 'Peer' }
    & PeerWithProfileFragment
  )>> }
);

export type PeerQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PeerQuery = (
  { __typename?: 'Query' }
  & { peer?: Maybe<(
    { __typename?: 'Peer' }
    & PeerRefFragment
  )> }
);

export type CreatePeerMutationVariables = Exact<{
  input: CreatePeerInput;
}>;


export type CreatePeerMutation = (
  { __typename?: 'Mutation' }
  & { createPeer: (
    { __typename?: 'Peer' }
    & PeerRefFragment
  ) }
);

export type UpdatePeerMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UpdatePeerInput;
}>;


export type UpdatePeerMutation = (
  { __typename?: 'Mutation' }
  & { updatePeer: (
    { __typename?: 'Peer' }
    & PeerRefFragment
  ) }
);

export type DeletePeerMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeletePeerMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deletePeer'>
);

export type TokenRefFragment = (
  { __typename?: 'Token' }
  & Pick<Token, 'id' | 'name'>
);

export type TokenListQueryVariables = Exact<{ [key: string]: never; }>;


export type TokenListQuery = (
  { __typename?: 'Query' }
  & { tokens: Array<(
    { __typename?: 'Token' }
    & TokenRefFragment
  )> }
);

export type CreateTokenMutationVariables = Exact<{
  input: TokenInput;
}>;


export type CreateTokenMutation = (
  { __typename?: 'Mutation' }
  & { createToken: (
    { __typename?: 'CreatedToken' }
    & Pick<CreatedToken, 'id' | 'name' | 'token'>
  ) }
);

export type DeleteTokenMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteTokenMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteToken'>
);

export type FullUserSubscriptionFragment = (
  { __typename?: 'UserSubscription' }
  & Pick<UserSubscription, 'paymentPeriodicity' | 'monthlyAmount' | 'autoRenew' | 'startsAt' | 'paidUntil' | 'deactivatedAt'>
  & { memberPlan: (
    { __typename?: 'MemberPlan' }
    & FullMemberPlanFragment
  ), paymentMethod: (
    { __typename?: 'PaymentMethod' }
    & FullPaymentMethodFragment
  ) }
);

export type FullUserFragment = (
  { __typename?: 'User' }
  & Pick<User, 'id' | 'createdAt' | 'modifiedAt' | 'name' | 'preferredName' | 'active' | 'lastLogin' | 'email'>
  & { address?: Maybe<(
    { __typename?: 'UserAddress' }
    & Pick<UserAddress, 'streetAddress' | 'zipCode' | 'city' | 'country'>
  )>, properties: Array<(
    { __typename?: 'Properties' }
    & Pick<Properties, 'key' | 'value' | 'public'>
  )>, roles: Array<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )>, subscription?: Maybe<(
    { __typename?: 'UserSubscription' }
    & FullUserSubscriptionFragment
  )> }
);

export type UserListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  order?: Maybe<SortOrder>;
  sort?: Maybe<UserSort>;
}>;


export type UserListQuery = (
  { __typename?: 'Query' }
  & { users: (
    { __typename?: 'UserConnection' }
    & Pick<UserConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'User' }
      & FullUserFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type UserQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UserQuery = (
  { __typename?: 'Query' }
  & { user?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type CreateUserMutationVariables = Exact<{
  input: UserInput;
  password: Scalars['String'];
}>;


export type CreateUserMutation = (
  { __typename?: 'Mutation' }
  & { createUser?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type UpdateUserMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UserInput;
}>;


export type UpdateUserMutation = (
  { __typename?: 'Mutation' }
  & { updateUser?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type UpdateUserSubscriptionMutationVariables = Exact<{
  userID: Scalars['ID'];
  input: UserSubscriptionInput;
}>;


export type UpdateUserSubscriptionMutation = (
  { __typename?: 'Mutation' }
  & { updateUserSubscription?: Maybe<(
    { __typename?: 'UserSubscription' }
    & FullUserSubscriptionFragment
  )> }
);

export type ResetUserPasswordMutationVariables = Exact<{
  id: Scalars['ID'];
  password: Scalars['String'];
}>;


export type ResetUserPasswordMutation = (
  { __typename?: 'Mutation' }
  & { resetUserPassword?: Maybe<(
    { __typename?: 'User' }
    & FullUserFragment
  )> }
);

export type DeleteUserMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteUserMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteUser'>
);

export type DeleteUserSubscriptionMutationVariables = Exact<{
  userID: Scalars['ID'];
}>;


export type DeleteUserSubscriptionMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteUserSubscription'>
);

export type FullPermissionFragment = (
  { __typename?: 'Permission' }
  & Pick<Permission, 'id' | 'description' | 'deprecated'>
);

export type FullUserRoleFragment = (
  { __typename?: 'UserRole' }
  & Pick<UserRole, 'id' | 'name' | 'description' | 'systemRole'>
  & { permissions: Array<(
    { __typename?: 'Permission' }
    & FullPermissionFragment
  )> }
);

export type UserRoleListQueryVariables = Exact<{
  filter?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['ID']>;
  before?: Maybe<Scalars['ID']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type UserRoleListQuery = (
  { __typename?: 'Query' }
  & { userRoles: (
    { __typename?: 'UserRoleConnection' }
    & Pick<UserRoleConnection, 'totalCount'>
    & { nodes: Array<(
      { __typename?: 'UserRole' }
      & FullUserRoleFragment
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ) }
  ) }
);

export type PermissionListQueryVariables = Exact<{ [key: string]: never; }>;


export type PermissionListQuery = (
  { __typename?: 'Query' }
  & { permissions?: Maybe<Array<(
    { __typename?: 'Permission' }
    & FullPermissionFragment
  )>> }
);

export type UserRoleQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UserRoleQuery = (
  { __typename?: 'Query' }
  & { userRole?: Maybe<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )> }
);

export type CreateUserRoleMutationVariables = Exact<{
  input: UserRoleInput;
}>;


export type CreateUserRoleMutation = (
  { __typename?: 'Mutation' }
  & { createUserRole?: Maybe<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )> }
);

export type UpdateUserRoleMutationVariables = Exact<{
  id: Scalars['ID'];
  input: UserRoleInput;
}>;


export type UpdateUserRoleMutation = (
  { __typename?: 'Mutation' }
  & { updateUserRole?: Maybe<(
    { __typename?: 'UserRole' }
    & FullUserRoleFragment
  )> }
);

export type DeleteUserRoleMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteUserRoleMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'deleteUserRole'>
);

export const MutationArticleFragmentDoc = gql`
    fragment MutationArticle on Article {
  id
  draft {
    publishedAt
    updatedAt
    revision
  }
  pending {
    publishAt
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
  }
}
    `;
export const ImageUrLsFragmentDoc = gql`
    fragment ImageURLs on Image {
  url
  largeURL: transformURL(input: {width: 500})
  mediumURL: transformURL(input: {width: 300})
  thumbURL: transformURL(input: {width: 280, height: 200})
  squareURL: transformURL(input: {width: 100, height: 100})
  previewURL: transformURL(input: {width: 400, height: 200})
  column1URL: transformURL(input: {width: 800, height: 300})
  column6URL: transformURL(input: {width: 260, height: 300})
}
    `;
export const ImageRefFragmentDoc = gql`
    fragment ImageRef on Image {
  id
  filename
  extension
  title
  description
  width
  height
  ...ImageURLs
}
    ${ImageUrLsFragmentDoc}`;
export const AuthorRefFragmentDoc = gql`
    fragment AuthorRef on Author {
  id
  name
  jobTitle
  image {
    ...ImageRef
  }
}
    ${ImageRefFragmentDoc}`;
export const FullAuthorFragmentDoc = gql`
    fragment FullAuthor on Author {
  slug
  links {
    title
    url
  }
  bio
  ...AuthorRef
}
    ${AuthorRefFragmentDoc}`;
export const ArticleRefFragmentDoc = gql`
    fragment ArticleRef on Article {
  id
  createdAt
  modifiedAt
  draft {
    revision
  }
  pending {
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
    preTitle
    title
    lead
    authors {
      name
    }
    image {
      ...ImageRef
    }
  }
}
    ${ImageRefFragmentDoc}`;
export const PeerRefFragmentDoc = gql`
    fragment PeerRef on Peer {
  id
  name
  slug
  hostURL
}
    `;
export const FullPeerProfileFragmentDoc = gql`
    fragment FullPeerProfile on PeerProfile {
  name
  hostURL
  themeColor
  logo {
    ...ImageRef
  }
  callToActionText
  callToActionURL
}
    ${ImageRefFragmentDoc}`;
export const PeerWithProfileFragmentDoc = gql`
    fragment PeerWithProfile on Peer {
  ...PeerRef
  profile {
    ...FullPeerProfile
  }
}
    ${PeerRefFragmentDoc}
${FullPeerProfileFragmentDoc}`;
export const PageRefFragmentDoc = gql`
    fragment PageRef on Page {
  id
  createdAt
  modifiedAt
  draft {
    revision
  }
  pending {
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
    title
    description
    image {
      ...ImageRef
    }
  }
}
    ${ImageRefFragmentDoc}`;
export const FullTeaserFragmentDoc = gql`
    fragment FullTeaser on Teaser {
  ... on ArticleTeaser {
    style
    image {
      ...ImageRef
    }
    preTitle
    title
    lead
    article {
      ...ArticleRef
    }
  }
  ... on PeerArticleTeaser {
    style
    image {
      ...ImageRef
    }
    preTitle
    title
    lead
    peer {
      ...PeerWithProfile
    }
    articleID
    article {
      ...ArticleRef
    }
  }
  ... on PageTeaser {
    style
    image {
      ...ImageRef
    }
    preTitle
    title
    lead
    page {
      ...PageRef
    }
  }
}
    ${ImageRefFragmentDoc}
${ArticleRefFragmentDoc}
${PeerWithProfileFragmentDoc}
${PageRefFragmentDoc}`;
export const FullBlockFragmentDoc = gql`
    fragment FullBlock on Block {
  __typename
  ... on TitleBlock {
    title
    lead
  }
  ... on RichTextBlock {
    richText
  }
  ... on QuoteBlock {
    quote
    author
  }
  ... on LinkPageBreakBlock {
    text
    linkText
    linkURL
    styleOption
    richText
    linkTarget
    hideButton
    templateOption
    layoutOption
    image {
      ...ImageRef
    }
  }
  ... on ImageBlock {
    caption
    image {
      ...ImageRef
    }
  }
  ... on ImageGalleryBlock {
    images {
      caption
      image {
        ...ImageRef
      }
    }
  }
  ... on ListicleBlock {
    items {
      title
      image {
        ...ImageRef
      }
      richText
    }
  }
  ... on FacebookPostBlock {
    userID
    postID
  }
  ... on FacebookVideoBlock {
    userID
    videoID
  }
  ... on InstagramPostBlock {
    postID
  }
  ... on TwitterTweetBlock {
    userID
    tweetID
  }
  ... on VimeoVideoBlock {
    videoID
  }
  ... on YouTubeVideoBlock {
    videoID
  }
  ... on SoundCloudTrackBlock {
    trackID
  }
  ... on EmbedBlock {
    url
    title
    width
    height
    styleCustom
  }
  ... on TeaserGridBlock {
    teasers {
      ...FullTeaser
    }
    numColumns
  }
}
    ${ImageRefFragmentDoc}
${FullTeaserFragmentDoc}`;
export const FullPermissionFragmentDoc = gql`
    fragment FullPermission on Permission {
  id
  description
  deprecated
}
    `;
export const FullUserRoleFragmentDoc = gql`
    fragment FullUserRole on UserRole {
  id
  name
  description
  systemRole
  permissions {
    ...FullPermission
  }
}
    ${FullPermissionFragmentDoc}`;
export const FullPaymentProviderFragmentDoc = gql`
    fragment FullPaymentProvider on PaymentProvider {
  id
  name
}
    `;
export const FullPaymentMethodFragmentDoc = gql`
    fragment FullPaymentMethod on PaymentMethod {
  id
  name
  createdAt
  modifiedAt
  paymentProvider {
    ...FullPaymentProvider
  }
  description
  active
}
    ${FullPaymentProviderFragmentDoc}`;
export const MemberPlanRefFragmentDoc = gql`
    fragment MemberPlanRef on MemberPlan {
  id
  name
  slug
  active
  image {
    ...ImageRef
  }
}
    ${ImageRefFragmentDoc}`;
export const FullMemberPlanFragmentDoc = gql`
    fragment FullMemberPlan on MemberPlan {
  description
  amountPerMonthMin
  availablePaymentMethods {
    paymentMethods {
      ...FullPaymentMethod
    }
    paymentPeriodicities
    forceAutoRenewal
  }
  ...MemberPlanRef
}
    ${FullPaymentMethodFragmentDoc}
${MemberPlanRefFragmentDoc}`;
export const FullUserSubscriptionFragmentDoc = gql`
    fragment FullUserSubscription on UserSubscription {
  memberPlan {
    ...FullMemberPlan
  }
  paymentPeriodicity
  monthlyAmount
  autoRenew
  startsAt
  paidUntil
  paymentMethod {
    ...FullPaymentMethod
  }
  deactivatedAt
}
    ${FullMemberPlanFragmentDoc}
${FullPaymentMethodFragmentDoc}`;
export const FullUserFragmentDoc = gql`
    fragment FullUser on User {
  id
  createdAt
  modifiedAt
  name
  preferredName
  address {
    streetAddress
    zipCode
    city
    country
  }
  active
  lastLogin
  properties {
    key
    value
    public
  }
  email
  roles {
    ...FullUserRole
  }
  subscription {
    ...FullUserSubscription
  }
}
    ${FullUserRoleFragmentDoc}
${FullUserSubscriptionFragmentDoc}`;
export const FullCommentFragmentDoc = gql`
    fragment FullComment on Comment {
  id
  state
  rejectionReason
  user {
    ...FullUser
  }
  revisions {
    text
    createdAt
  }
  createdAt
  modifiedAt
}
    ${FullUserFragmentDoc}`;
export const ContentListRefFragmentDoc = gql`
    fragment ContentListRef on ContentModelSummary {
  id
  title
  shared
  contentType
  revision
  state
  createdAt
  modifiedAt
  publicationDate
  dePublicationDate
}
    `;
export const FullImageFragmentDoc = gql`
    fragment FullImage on Image {
  id
  createdAt
  modifiedAt
  filename
  extension
  width
  height
  fileSize
  description
  tags
  author
  source
  license
  focalPoint {
    x
    y
  }
  ...ImageRef
}
    ${ImageRefFragmentDoc}`;
export const FullNavigationFragmentDoc = gql`
    fragment FullNavigation on Navigation {
  id
  key
  name
  links {
    __typename
    ... on PageNavigationLink {
      label
      page {
        ...PageRef
      }
    }
    ... on ArticleNavigationLink {
      label
      article {
        ...ArticleRef
      }
    }
    ... on ExternalNavigationLink {
      label
      url
    }
  }
}
    ${PageRefFragmentDoc}
${ArticleRefFragmentDoc}`;
export const MutationPageFragmentDoc = gql`
    fragment MutationPage on Page {
  id
  draft {
    publishedAt
    updatedAt
    revision
  }
  pending {
    publishAt
    revision
  }
  published {
    publishedAt
    updatedAt
    revision
  }
  latest {
    publishedAt
    updatedAt
    revision
  }
}
    `;
export const TokenRefFragmentDoc = gql`
    fragment TokenRef on Token {
  id
  name
}
    `;
export const ArticleListDocument = gql`
    query ArticleList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int, $skip: Int, $order: SortOrder, $sort: ArticleSort) {
  articles(filter: {title: $filter}, after: $after, before: $before, first: $first, last: $last, skip: $skip, order: $order, sort: $sort) {
    nodes {
      ...ArticleRef
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${ArticleRefFragmentDoc}`;

/**
 * __useArticleListQuery__
 *
 * To run a query within a React component, call `useArticleListQuery` and pass it any options that fit your needs.
 * When your component renders, `useArticleListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArticleListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      skip: // value for 'skip'
 *      order: // value for 'order'
 *      sort: // value for 'sort'
 *   },
 * });
 */
export function useArticleListQuery(baseOptions?: Apollo.QueryHookOptions<ArticleListQuery, ArticleListQueryVariables>) {
        return Apollo.useQuery<ArticleListQuery, ArticleListQueryVariables>(ArticleListDocument, baseOptions);
      }
export function useArticleListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ArticleListQuery, ArticleListQueryVariables>) {
          return Apollo.useLazyQuery<ArticleListQuery, ArticleListQueryVariables>(ArticleListDocument, baseOptions);
        }
export type ArticleListQueryHookResult = ReturnType<typeof useArticleListQuery>;
export type ArticleListLazyQueryHookResult = ReturnType<typeof useArticleListLazyQuery>;
export type ArticleListQueryResult = Apollo.QueryResult<ArticleListQuery, ArticleListQueryVariables>;
export const PeerArticleListDocument = gql`
    query PeerArticleList($filter: String, $after: ID, $first: Int) {
  peerArticles(first: $first, after: $after, filter: {title: $filter}) {
    nodes {
      peer {
        ...PeerWithProfile
      }
      article {
        ...ArticleRef
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
    totalCount
  }
}
    ${PeerWithProfileFragmentDoc}
${ArticleRefFragmentDoc}`;

/**
 * __usePeerArticleListQuery__
 *
 * To run a query within a React component, call `usePeerArticleListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerArticleListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerArticleListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *   },
 * });
 */
export function usePeerArticleListQuery(baseOptions?: Apollo.QueryHookOptions<PeerArticleListQuery, PeerArticleListQueryVariables>) {
        return Apollo.useQuery<PeerArticleListQuery, PeerArticleListQueryVariables>(PeerArticleListDocument, baseOptions);
      }
export function usePeerArticleListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerArticleListQuery, PeerArticleListQueryVariables>) {
          return Apollo.useLazyQuery<PeerArticleListQuery, PeerArticleListQueryVariables>(PeerArticleListDocument, baseOptions);
        }
export type PeerArticleListQueryHookResult = ReturnType<typeof usePeerArticleListQuery>;
export type PeerArticleListLazyQueryHookResult = ReturnType<typeof usePeerArticleListLazyQuery>;
export type PeerArticleListQueryResult = Apollo.QueryResult<PeerArticleListQuery, PeerArticleListQueryVariables>;
export const CreateArticleDocument = gql`
    mutation CreateArticle($input: ArticleInput!) {
  createArticle(input: $input) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type CreateArticleMutationFn = Apollo.MutationFunction<CreateArticleMutation, CreateArticleMutationVariables>;

/**
 * __useCreateArticleMutation__
 *
 * To run a mutation, you first call `useCreateArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createArticleMutation, { data, loading, error }] = useCreateArticleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateArticleMutation(baseOptions?: Apollo.MutationHookOptions<CreateArticleMutation, CreateArticleMutationVariables>) {
        return Apollo.useMutation<CreateArticleMutation, CreateArticleMutationVariables>(CreateArticleDocument, baseOptions);
      }
export type CreateArticleMutationHookResult = ReturnType<typeof useCreateArticleMutation>;
export type CreateArticleMutationResult = Apollo.MutationResult<CreateArticleMutation>;
export type CreateArticleMutationOptions = Apollo.BaseMutationOptions<CreateArticleMutation, CreateArticleMutationVariables>;
export const UpdateArticleDocument = gql`
    mutation UpdateArticle($id: ID!, $input: ArticleInput!) {
  updateArticle(id: $id, input: $input) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type UpdateArticleMutationFn = Apollo.MutationFunction<UpdateArticleMutation, UpdateArticleMutationVariables>;

/**
 * __useUpdateArticleMutation__
 *
 * To run a mutation, you first call `useUpdateArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateArticleMutation, { data, loading, error }] = useUpdateArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateArticleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateArticleMutation, UpdateArticleMutationVariables>) {
        return Apollo.useMutation<UpdateArticleMutation, UpdateArticleMutationVariables>(UpdateArticleDocument, baseOptions);
      }
export type UpdateArticleMutationHookResult = ReturnType<typeof useUpdateArticleMutation>;
export type UpdateArticleMutationResult = Apollo.MutationResult<UpdateArticleMutation>;
export type UpdateArticleMutationOptions = Apollo.BaseMutationOptions<UpdateArticleMutation, UpdateArticleMutationVariables>;
export const PublishArticleDocument = gql`
    mutation PublishArticle($id: ID!, $publishAt: DateTime!, $publishedAt: DateTime!, $updatedAt: DateTime!) {
  publishArticle(id: $id, publishAt: $publishAt, publishedAt: $publishedAt, updatedAt: $updatedAt) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type PublishArticleMutationFn = Apollo.MutationFunction<PublishArticleMutation, PublishArticleMutationVariables>;

/**
 * __usePublishArticleMutation__
 *
 * To run a mutation, you first call `usePublishArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePublishArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [publishArticleMutation, { data, loading, error }] = usePublishArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      publishAt: // value for 'publishAt'
 *      publishedAt: // value for 'publishedAt'
 *      updatedAt: // value for 'updatedAt'
 *   },
 * });
 */
export function usePublishArticleMutation(baseOptions?: Apollo.MutationHookOptions<PublishArticleMutation, PublishArticleMutationVariables>) {
        return Apollo.useMutation<PublishArticleMutation, PublishArticleMutationVariables>(PublishArticleDocument, baseOptions);
      }
export type PublishArticleMutationHookResult = ReturnType<typeof usePublishArticleMutation>;
export type PublishArticleMutationResult = Apollo.MutationResult<PublishArticleMutation>;
export type PublishArticleMutationOptions = Apollo.BaseMutationOptions<PublishArticleMutation, PublishArticleMutationVariables>;
export const UnpublishArticleDocument = gql`
    mutation UnpublishArticle($id: ID!) {
  unpublishArticle(id: $id) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type UnpublishArticleMutationFn = Apollo.MutationFunction<UnpublishArticleMutation, UnpublishArticleMutationVariables>;

/**
 * __useUnpublishArticleMutation__
 *
 * To run a mutation, you first call `useUnpublishArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpublishArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpublishArticleMutation, { data, loading, error }] = useUnpublishArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnpublishArticleMutation(baseOptions?: Apollo.MutationHookOptions<UnpublishArticleMutation, UnpublishArticleMutationVariables>) {
        return Apollo.useMutation<UnpublishArticleMutation, UnpublishArticleMutationVariables>(UnpublishArticleDocument, baseOptions);
      }
export type UnpublishArticleMutationHookResult = ReturnType<typeof useUnpublishArticleMutation>;
export type UnpublishArticleMutationResult = Apollo.MutationResult<UnpublishArticleMutation>;
export type UnpublishArticleMutationOptions = Apollo.BaseMutationOptions<UnpublishArticleMutation, UnpublishArticleMutationVariables>;
export const DeleteArticleDocument = gql`
    mutation DeleteArticle($id: ID!) {
  deleteArticle(id: $id)
}
    `;
export type DeleteArticleMutationFn = Apollo.MutationFunction<DeleteArticleMutation, DeleteArticleMutationVariables>;

/**
 * __useDeleteArticleMutation__
 *
 * To run a mutation, you first call `useDeleteArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteArticleMutation, { data, loading, error }] = useDeleteArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteArticleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteArticleMutation, DeleteArticleMutationVariables>) {
        return Apollo.useMutation<DeleteArticleMutation, DeleteArticleMutationVariables>(DeleteArticleDocument, baseOptions);
      }
export type DeleteArticleMutationHookResult = ReturnType<typeof useDeleteArticleMutation>;
export type DeleteArticleMutationResult = Apollo.MutationResult<DeleteArticleMutation>;
export type DeleteArticleMutationOptions = Apollo.BaseMutationOptions<DeleteArticleMutation, DeleteArticleMutationVariables>;
export const DuplicateArticleDocument = gql`
    mutation DuplicateArticle($id: ID!) {
  duplicateArticle(id: $id) {
    ...MutationArticle
  }
}
    ${MutationArticleFragmentDoc}`;
export type DuplicateArticleMutationFn = Apollo.MutationFunction<DuplicateArticleMutation, DuplicateArticleMutationVariables>;

/**
 * __useDuplicateArticleMutation__
 *
 * To run a mutation, you first call `useDuplicateArticleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDuplicateArticleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [duplicateArticleMutation, { data, loading, error }] = useDuplicateArticleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDuplicateArticleMutation(baseOptions?: Apollo.MutationHookOptions<DuplicateArticleMutation, DuplicateArticleMutationVariables>) {
        return Apollo.useMutation<DuplicateArticleMutation, DuplicateArticleMutationVariables>(DuplicateArticleDocument, baseOptions);
      }
export type DuplicateArticleMutationHookResult = ReturnType<typeof useDuplicateArticleMutation>;
export type DuplicateArticleMutationResult = Apollo.MutationResult<DuplicateArticleMutation>;
export type DuplicateArticleMutationOptions = Apollo.BaseMutationOptions<DuplicateArticleMutation, DuplicateArticleMutationVariables>;
export const ArticlePreviewLinkDocument = gql`
    query ArticlePreviewLink($id: ID!, $hours: Int!) {
  articlePreviewLink(id: $id, hours: $hours)
}
    `;

/**
 * __useArticlePreviewLinkQuery__
 *
 * To run a query within a React component, call `useArticlePreviewLinkQuery` and pass it any options that fit your needs.
 * When your component renders, `useArticlePreviewLinkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArticlePreviewLinkQuery({
 *   variables: {
 *      id: // value for 'id'
 *      hours: // value for 'hours'
 *   },
 * });
 */
export function useArticlePreviewLinkQuery(baseOptions?: Apollo.QueryHookOptions<ArticlePreviewLinkQuery, ArticlePreviewLinkQueryVariables>) {
        return Apollo.useQuery<ArticlePreviewLinkQuery, ArticlePreviewLinkQueryVariables>(ArticlePreviewLinkDocument, baseOptions);
      }
export function useArticlePreviewLinkLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ArticlePreviewLinkQuery, ArticlePreviewLinkQueryVariables>) {
          return Apollo.useLazyQuery<ArticlePreviewLinkQuery, ArticlePreviewLinkQueryVariables>(ArticlePreviewLinkDocument, baseOptions);
        }
export type ArticlePreviewLinkQueryHookResult = ReturnType<typeof useArticlePreviewLinkQuery>;
export type ArticlePreviewLinkLazyQueryHookResult = ReturnType<typeof useArticlePreviewLinkLazyQuery>;
export type ArticlePreviewLinkQueryResult = Apollo.QueryResult<ArticlePreviewLinkQuery, ArticlePreviewLinkQueryVariables>;
export const ArticleDocument = gql`
    query Article($id: ID!) {
  article(id: $id) {
    id
    shared
    pending {
      publishAt
    }
    published {
      publishedAt
      updatedAt
    }
    latest {
      publishedAt
      updatedAt
      revision
      slug
      preTitle
      title
      lead
      seoTitle
      image {
        ...ImageRef
      }
      tags
      properties {
        key
        value
        public
      }
      authors {
        ...AuthorRef
      }
      hideAuthor
      breaking
      socialMediaTitle
      socialMediaDescription
      socialMediaAuthors {
        ...AuthorRef
      }
      socialMediaImage {
        ...ImageRef
      }
      blocks {
        ...FullBlock
      }
    }
  }
}
    ${ImageRefFragmentDoc}
${AuthorRefFragmentDoc}
${FullBlockFragmentDoc}`;

/**
 * __useArticleQuery__
 *
 * To run a query within a React component, call `useArticleQuery` and pass it any options that fit your needs.
 * When your component renders, `useArticleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArticleQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useArticleQuery(baseOptions?: Apollo.QueryHookOptions<ArticleQuery, ArticleQueryVariables>) {
        return Apollo.useQuery<ArticleQuery, ArticleQueryVariables>(ArticleDocument, baseOptions);
      }
export function useArticleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ArticleQuery, ArticleQueryVariables>) {
          return Apollo.useLazyQuery<ArticleQuery, ArticleQueryVariables>(ArticleDocument, baseOptions);
        }
export type ArticleQueryHookResult = ReturnType<typeof useArticleQuery>;
export type ArticleLazyQueryHookResult = ReturnType<typeof useArticleLazyQuery>;
export type ArticleQueryResult = Apollo.QueryResult<ArticleQuery, ArticleQueryVariables>;
export const CreateSessionDocument = gql`
    mutation CreateSession($email: String!, $password: String!) {
  createSession(email: $email, password: $password) {
    user {
      email
      roles {
        ...FullUserRole
      }
    }
    token
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateSessionMutationFn = Apollo.MutationFunction<CreateSessionMutation, CreateSessionMutationVariables>;

/**
 * __useCreateSessionMutation__
 *
 * To run a mutation, you first call `useCreateSessionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSessionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSessionMutation, { data, loading, error }] = useCreateSessionMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useCreateSessionMutation(baseOptions?: Apollo.MutationHookOptions<CreateSessionMutation, CreateSessionMutationVariables>) {
        return Apollo.useMutation<CreateSessionMutation, CreateSessionMutationVariables>(CreateSessionDocument, baseOptions);
      }
export type CreateSessionMutationHookResult = ReturnType<typeof useCreateSessionMutation>;
export type CreateSessionMutationResult = Apollo.MutationResult<CreateSessionMutation>;
export type CreateSessionMutationOptions = Apollo.BaseMutationOptions<CreateSessionMutation, CreateSessionMutationVariables>;
export const GetAuthProvidersDocument = gql`
    query GetAuthProviders($redirectUri: String!) {
  authProviders(redirectUri: $redirectUri) {
    name
    url
  }
}
    `;

/**
 * __useGetAuthProvidersQuery__
 *
 * To run a query within a React component, call `useGetAuthProvidersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAuthProvidersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAuthProvidersQuery({
 *   variables: {
 *      redirectUri: // value for 'redirectUri'
 *   },
 * });
 */
export function useGetAuthProvidersQuery(baseOptions?: Apollo.QueryHookOptions<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>) {
        return Apollo.useQuery<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>(GetAuthProvidersDocument, baseOptions);
      }
export function useGetAuthProvidersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>) {
          return Apollo.useLazyQuery<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>(GetAuthProvidersDocument, baseOptions);
        }
export type GetAuthProvidersQueryHookResult = ReturnType<typeof useGetAuthProvidersQuery>;
export type GetAuthProvidersLazyQueryHookResult = ReturnType<typeof useGetAuthProvidersLazyQuery>;
export type GetAuthProvidersQueryResult = Apollo.QueryResult<GetAuthProvidersQuery, GetAuthProvidersQueryVariables>;
export const CreateSessionWithOAuth2CodeDocument = gql`
    mutation CreateSessionWithOAuth2Code($redirectUri: String!, $name: String!, $code: String!) {
  createSessionWithOAuth2Code(redirectUri: $redirectUri, name: $name, code: $code) {
    user {
      email
      roles {
        ...FullUserRole
      }
    }
    token
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateSessionWithOAuth2CodeMutationFn = Apollo.MutationFunction<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>;

/**
 * __useCreateSessionWithOAuth2CodeMutation__
 *
 * To run a mutation, you first call `useCreateSessionWithOAuth2CodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSessionWithOAuth2CodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSessionWithOAuth2CodeMutation, { data, loading, error }] = useCreateSessionWithOAuth2CodeMutation({
 *   variables: {
 *      redirectUri: // value for 'redirectUri'
 *      name: // value for 'name'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useCreateSessionWithOAuth2CodeMutation(baseOptions?: Apollo.MutationHookOptions<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>) {
        return Apollo.useMutation<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>(CreateSessionWithOAuth2CodeDocument, baseOptions);
      }
export type CreateSessionWithOAuth2CodeMutationHookResult = ReturnType<typeof useCreateSessionWithOAuth2CodeMutation>;
export type CreateSessionWithOAuth2CodeMutationResult = Apollo.MutationResult<CreateSessionWithOAuth2CodeMutation>;
export type CreateSessionWithOAuth2CodeMutationOptions = Apollo.BaseMutationOptions<CreateSessionWithOAuth2CodeMutation, CreateSessionWithOAuth2CodeMutationVariables>;
export const CreateSessionWithJwtDocument = gql`
    mutation CreateSessionWithJWT($jwt: String!) {
  createSessionWithJWT(jwt: $jwt) {
    user {
      email
      roles {
        ...FullUserRole
      }
    }
    token
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateSessionWithJwtMutationFn = Apollo.MutationFunction<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>;

/**
 * __useCreateSessionWithJwtMutation__
 *
 * To run a mutation, you first call `useCreateSessionWithJwtMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSessionWithJwtMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSessionWithJwtMutation, { data, loading, error }] = useCreateSessionWithJwtMutation({
 *   variables: {
 *      jwt: // value for 'jwt'
 *   },
 * });
 */
export function useCreateSessionWithJwtMutation(baseOptions?: Apollo.MutationHookOptions<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>) {
        return Apollo.useMutation<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>(CreateSessionWithJwtDocument, baseOptions);
      }
export type CreateSessionWithJwtMutationHookResult = ReturnType<typeof useCreateSessionWithJwtMutation>;
export type CreateSessionWithJwtMutationResult = Apollo.MutationResult<CreateSessionWithJwtMutation>;
export type CreateSessionWithJwtMutationOptions = Apollo.BaseMutationOptions<CreateSessionWithJwtMutation, CreateSessionWithJwtMutationVariables>;
export const AuthorListDocument = gql`
    query AuthorList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  authors(filter: {name: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...FullAuthor
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullAuthorFragmentDoc}`;

/**
 * __useAuthorListQuery__
 *
 * To run a query within a React component, call `useAuthorListQuery` and pass it any options that fit your needs.
 * When your component renders, `useAuthorListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAuthorListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useAuthorListQuery(baseOptions?: Apollo.QueryHookOptions<AuthorListQuery, AuthorListQueryVariables>) {
        return Apollo.useQuery<AuthorListQuery, AuthorListQueryVariables>(AuthorListDocument, baseOptions);
      }
export function useAuthorListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AuthorListQuery, AuthorListQueryVariables>) {
          return Apollo.useLazyQuery<AuthorListQuery, AuthorListQueryVariables>(AuthorListDocument, baseOptions);
        }
export type AuthorListQueryHookResult = ReturnType<typeof useAuthorListQuery>;
export type AuthorListLazyQueryHookResult = ReturnType<typeof useAuthorListLazyQuery>;
export type AuthorListQueryResult = Apollo.QueryResult<AuthorListQuery, AuthorListQueryVariables>;
export const AuthorDocument = gql`
    query Author($id: ID!) {
  author(id: $id) {
    ...FullAuthor
  }
}
    ${FullAuthorFragmentDoc}`;

/**
 * __useAuthorQuery__
 *
 * To run a query within a React component, call `useAuthorQuery` and pass it any options that fit your needs.
 * When your component renders, `useAuthorQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAuthorQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAuthorQuery(baseOptions?: Apollo.QueryHookOptions<AuthorQuery, AuthorQueryVariables>) {
        return Apollo.useQuery<AuthorQuery, AuthorQueryVariables>(AuthorDocument, baseOptions);
      }
export function useAuthorLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AuthorQuery, AuthorQueryVariables>) {
          return Apollo.useLazyQuery<AuthorQuery, AuthorQueryVariables>(AuthorDocument, baseOptions);
        }
export type AuthorQueryHookResult = ReturnType<typeof useAuthorQuery>;
export type AuthorLazyQueryHookResult = ReturnType<typeof useAuthorLazyQuery>;
export type AuthorQueryResult = Apollo.QueryResult<AuthorQuery, AuthorQueryVariables>;
export const CreateAuthorDocument = gql`
    mutation CreateAuthor($input: AuthorInput!) {
  createAuthor(input: $input) {
    ...FullAuthor
  }
}
    ${FullAuthorFragmentDoc}`;
export type CreateAuthorMutationFn = Apollo.MutationFunction<CreateAuthorMutation, CreateAuthorMutationVariables>;

/**
 * __useCreateAuthorMutation__
 *
 * To run a mutation, you first call `useCreateAuthorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAuthorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAuthorMutation, { data, loading, error }] = useCreateAuthorMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAuthorMutation(baseOptions?: Apollo.MutationHookOptions<CreateAuthorMutation, CreateAuthorMutationVariables>) {
        return Apollo.useMutation<CreateAuthorMutation, CreateAuthorMutationVariables>(CreateAuthorDocument, baseOptions);
      }
export type CreateAuthorMutationHookResult = ReturnType<typeof useCreateAuthorMutation>;
export type CreateAuthorMutationResult = Apollo.MutationResult<CreateAuthorMutation>;
export type CreateAuthorMutationOptions = Apollo.BaseMutationOptions<CreateAuthorMutation, CreateAuthorMutationVariables>;
export const UpdateAuthorDocument = gql`
    mutation UpdateAuthor($id: ID!, $input: AuthorInput!) {
  updateAuthor(id: $id, input: $input) {
    ...FullAuthor
  }
}
    ${FullAuthorFragmentDoc}`;
export type UpdateAuthorMutationFn = Apollo.MutationFunction<UpdateAuthorMutation, UpdateAuthorMutationVariables>;

/**
 * __useUpdateAuthorMutation__
 *
 * To run a mutation, you first call `useUpdateAuthorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAuthorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAuthorMutation, { data, loading, error }] = useUpdateAuthorMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateAuthorMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAuthorMutation, UpdateAuthorMutationVariables>) {
        return Apollo.useMutation<UpdateAuthorMutation, UpdateAuthorMutationVariables>(UpdateAuthorDocument, baseOptions);
      }
export type UpdateAuthorMutationHookResult = ReturnType<typeof useUpdateAuthorMutation>;
export type UpdateAuthorMutationResult = Apollo.MutationResult<UpdateAuthorMutation>;
export type UpdateAuthorMutationOptions = Apollo.BaseMutationOptions<UpdateAuthorMutation, UpdateAuthorMutationVariables>;
export const DeleteAuthorDocument = gql`
    mutation DeleteAuthor($id: ID!) {
  deleteAuthor(id: $id)
}
    `;
export type DeleteAuthorMutationFn = Apollo.MutationFunction<DeleteAuthorMutation, DeleteAuthorMutationVariables>;

/**
 * __useDeleteAuthorMutation__
 *
 * To run a mutation, you first call `useDeleteAuthorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAuthorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAuthorMutation, { data, loading, error }] = useDeleteAuthorMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteAuthorMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAuthorMutation, DeleteAuthorMutationVariables>) {
        return Apollo.useMutation<DeleteAuthorMutation, DeleteAuthorMutationVariables>(DeleteAuthorDocument, baseOptions);
      }
export type DeleteAuthorMutationHookResult = ReturnType<typeof useDeleteAuthorMutation>;
export type DeleteAuthorMutationResult = Apollo.MutationResult<DeleteAuthorMutation>;
export type DeleteAuthorMutationOptions = Apollo.BaseMutationOptions<DeleteAuthorMutation, DeleteAuthorMutationVariables>;
export const CommentListDocument = gql`
    query CommentList($after: ID, $before: ID, $first: Int, $last: Int, $skip: Int, $order: SortOrder, $sort: CommentSort) {
  comments(after: $after, before: $before, first: $first, last: $last, skip: $skip, order: $order, sort: $sort) {
    nodes {
      ...FullComment
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullCommentFragmentDoc}`;

/**
 * __useCommentListQuery__
 *
 * To run a query within a React component, call `useCommentListQuery` and pass it any options that fit your needs.
 * When your component renders, `useCommentListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCommentListQuery({
 *   variables: {
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      skip: // value for 'skip'
 *      order: // value for 'order'
 *      sort: // value for 'sort'
 *   },
 * });
 */
export function useCommentListQuery(baseOptions?: Apollo.QueryHookOptions<CommentListQuery, CommentListQueryVariables>) {
        return Apollo.useQuery<CommentListQuery, CommentListQueryVariables>(CommentListDocument, baseOptions);
      }
export function useCommentListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CommentListQuery, CommentListQueryVariables>) {
          return Apollo.useLazyQuery<CommentListQuery, CommentListQueryVariables>(CommentListDocument, baseOptions);
        }
export type CommentListQueryHookResult = ReturnType<typeof useCommentListQuery>;
export type CommentListLazyQueryHookResult = ReturnType<typeof useCommentListLazyQuery>;
export type CommentListQueryResult = Apollo.QueryResult<CommentListQuery, CommentListQueryVariables>;
export const ApproveCommentDocument = gql`
    mutation ApproveComment($id: ID!) {
  approveComment(id: $id) {
    state
  }
}
    `;
export type ApproveCommentMutationFn = Apollo.MutationFunction<ApproveCommentMutation, ApproveCommentMutationVariables>;

/**
 * __useApproveCommentMutation__
 *
 * To run a mutation, you first call `useApproveCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveCommentMutation, { data, loading, error }] = useApproveCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useApproveCommentMutation(baseOptions?: Apollo.MutationHookOptions<ApproveCommentMutation, ApproveCommentMutationVariables>) {
        return Apollo.useMutation<ApproveCommentMutation, ApproveCommentMutationVariables>(ApproveCommentDocument, baseOptions);
      }
export type ApproveCommentMutationHookResult = ReturnType<typeof useApproveCommentMutation>;
export type ApproveCommentMutationResult = Apollo.MutationResult<ApproveCommentMutation>;
export type ApproveCommentMutationOptions = Apollo.BaseMutationOptions<ApproveCommentMutation, ApproveCommentMutationVariables>;
export const RejectCommentDocument = gql`
    mutation RejectComment($id: ID!, $rejectionReason: CommentRejectionReason!) {
  rejectComment(id: $id, rejectionReason: $rejectionReason) {
    state
    rejectionReason
  }
}
    `;
export type RejectCommentMutationFn = Apollo.MutationFunction<RejectCommentMutation, RejectCommentMutationVariables>;

/**
 * __useRejectCommentMutation__
 *
 * To run a mutation, you first call `useRejectCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRejectCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rejectCommentMutation, { data, loading, error }] = useRejectCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      rejectionReason: // value for 'rejectionReason'
 *   },
 * });
 */
export function useRejectCommentMutation(baseOptions?: Apollo.MutationHookOptions<RejectCommentMutation, RejectCommentMutationVariables>) {
        return Apollo.useMutation<RejectCommentMutation, RejectCommentMutationVariables>(RejectCommentDocument, baseOptions);
      }
export type RejectCommentMutationHookResult = ReturnType<typeof useRejectCommentMutation>;
export type RejectCommentMutationResult = Apollo.MutationResult<RejectCommentMutation>;
export type RejectCommentMutationOptions = Apollo.BaseMutationOptions<RejectCommentMutation, RejectCommentMutationVariables>;
export const RequestChangesOnCommentDocument = gql`
    mutation RequestChangesOnComment($id: ID!, $rejectionReason: CommentRejectionReason!) {
  requestChangesOnComment(id: $id, rejectionReason: $rejectionReason) {
    state
    rejectionReason
  }
}
    `;
export type RequestChangesOnCommentMutationFn = Apollo.MutationFunction<RequestChangesOnCommentMutation, RequestChangesOnCommentMutationVariables>;

/**
 * __useRequestChangesOnCommentMutation__
 *
 * To run a mutation, you first call `useRequestChangesOnCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRequestChangesOnCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [requestChangesOnCommentMutation, { data, loading, error }] = useRequestChangesOnCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      rejectionReason: // value for 'rejectionReason'
 *   },
 * });
 */
export function useRequestChangesOnCommentMutation(baseOptions?: Apollo.MutationHookOptions<RequestChangesOnCommentMutation, RequestChangesOnCommentMutationVariables>) {
        return Apollo.useMutation<RequestChangesOnCommentMutation, RequestChangesOnCommentMutationVariables>(RequestChangesOnCommentDocument, baseOptions);
      }
export type RequestChangesOnCommentMutationHookResult = ReturnType<typeof useRequestChangesOnCommentMutation>;
export type RequestChangesOnCommentMutationResult = Apollo.MutationResult<RequestChangesOnCommentMutation>;
export type RequestChangesOnCommentMutationOptions = Apollo.BaseMutationOptions<RequestChangesOnCommentMutation, RequestChangesOnCommentMutationVariables>;
export const ContentListDocument = gql`
    query ContentList($type: contentTypeEnum!, $context: contentContextEnum, $filter: String, $after: ID, $first: Int) {
  content {
    _all {
      list(type: $type, context: $context, first: $first, after: $after, filter: {title: $filter}) {
        nodes {
          peer {
            id
            name
          }
          content {
            ...ContentListRef
          }
        }
        pageInfo {
          startCursor
          endCursor
          hasNextPage
          hasPreviousPage
        }
        totalCount
      }
    }
  }
}
    ${ContentListRefFragmentDoc}`;

/**
 * __useContentListQuery__
 *
 * To run a query within a React component, call `useContentListQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentListQuery({
 *   variables: {
 *      type: // value for 'type'
 *      context: // value for 'context'
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      first: // value for 'first'
 *   },
 * });
 */
export function useContentListQuery(baseOptions?: Apollo.QueryHookOptions<ContentListQuery, ContentListQueryVariables>) {
        return Apollo.useQuery<ContentListQuery, ContentListQueryVariables>(ContentListDocument, baseOptions);
      }
export function useContentListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentListQuery, ContentListQueryVariables>) {
          return Apollo.useLazyQuery<ContentListQuery, ContentListQueryVariables>(ContentListDocument, baseOptions);
        }
export type ContentListQueryHookResult = ReturnType<typeof useContentListQuery>;
export type ContentListLazyQueryHookResult = ReturnType<typeof useContentListLazyQuery>;
export type ContentListQueryResult = Apollo.QueryResult<ContentListQuery, ContentListQueryVariables>;
export const ContentGetDocument = gql`
    query ContentGet($id: ID!) {
  content {
    _all {
      read(id: $id) {
        ...ContentListRef
      }
    }
  }
}
    ${ContentListRefFragmentDoc}`;

/**
 * __useContentGetQuery__
 *
 * To run a query within a React component, call `useContentGetQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentGetQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentGetQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useContentGetQuery(baseOptions?: Apollo.QueryHookOptions<ContentGetQuery, ContentGetQueryVariables>) {
        return Apollo.useQuery<ContentGetQuery, ContentGetQueryVariables>(ContentGetDocument, baseOptions);
      }
export function useContentGetLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentGetQuery, ContentGetQueryVariables>) {
          return Apollo.useLazyQuery<ContentGetQuery, ContentGetQueryVariables>(ContentGetDocument, baseOptions);
        }
export type ContentGetQueryHookResult = ReturnType<typeof useContentGetQuery>;
export type ContentGetLazyQueryHookResult = ReturnType<typeof useContentGetLazyQuery>;
export type ContentGetQueryResult = Apollo.QueryResult<ContentGetQuery, ContentGetQueryVariables>;
export const PublishContentDocument = gql`
    mutation PublishContent($id: ID!, $publishAt: DateTime!, $publishedAt: DateTime!, $updatedAt: DateTime!) {
  content {
    _all {
      publish(id: $id, publishAt: $publishAt, publishedAt: $publishedAt, updatedAt: $updatedAt) {
        id
        pending {
          publishAt
        }
        published {
          publishedAt
        }
      }
    }
  }
}
    `;
export type PublishContentMutationFn = Apollo.MutationFunction<PublishContentMutation, PublishContentMutationVariables>;

/**
 * __usePublishContentMutation__
 *
 * To run a mutation, you first call `usePublishContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePublishContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [publishContentMutation, { data, loading, error }] = usePublishContentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      publishAt: // value for 'publishAt'
 *      publishedAt: // value for 'publishedAt'
 *      updatedAt: // value for 'updatedAt'
 *   },
 * });
 */
export function usePublishContentMutation(baseOptions?: Apollo.MutationHookOptions<PublishContentMutation, PublishContentMutationVariables>) {
        return Apollo.useMutation<PublishContentMutation, PublishContentMutationVariables>(PublishContentDocument, baseOptions);
      }
export type PublishContentMutationHookResult = ReturnType<typeof usePublishContentMutation>;
export type PublishContentMutationResult = Apollo.MutationResult<PublishContentMutation>;
export type PublishContentMutationOptions = Apollo.BaseMutationOptions<PublishContentMutation, PublishContentMutationVariables>;
export const UnpublishContentDocument = gql`
    mutation UnpublishContent($id: ID!) {
  content {
    _all {
      unpublish(id: $id) {
        id
        pending {
          publishAt
        }
        published {
          publishedAt
        }
      }
    }
  }
}
    `;
export type UnpublishContentMutationFn = Apollo.MutationFunction<UnpublishContentMutation, UnpublishContentMutationVariables>;

/**
 * __useUnpublishContentMutation__
 *
 * To run a mutation, you first call `useUnpublishContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpublishContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpublishContentMutation, { data, loading, error }] = useUnpublishContentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnpublishContentMutation(baseOptions?: Apollo.MutationHookOptions<UnpublishContentMutation, UnpublishContentMutationVariables>) {
        return Apollo.useMutation<UnpublishContentMutation, UnpublishContentMutationVariables>(UnpublishContentDocument, baseOptions);
      }
export type UnpublishContentMutationHookResult = ReturnType<typeof useUnpublishContentMutation>;
export type UnpublishContentMutationResult = Apollo.MutationResult<UnpublishContentMutation>;
export type UnpublishContentMutationOptions = Apollo.BaseMutationOptions<UnpublishContentMutation, UnpublishContentMutationVariables>;
export const DeleteContentDocument = gql`
    mutation DeleteContent($id: ID!) {
  content {
    _all {
      delete(id: $id)
    }
  }
}
    `;
export type DeleteContentMutationFn = Apollo.MutationFunction<DeleteContentMutation, DeleteContentMutationVariables>;

/**
 * __useDeleteContentMutation__
 *
 * To run a mutation, you first call `useDeleteContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteContentMutation, { data, loading, error }] = useDeleteContentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteContentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteContentMutation, DeleteContentMutationVariables>) {
        return Apollo.useMutation<DeleteContentMutation, DeleteContentMutationVariables>(DeleteContentDocument, baseOptions);
      }
export type DeleteContentMutationHookResult = ReturnType<typeof useDeleteContentMutation>;
export type DeleteContentMutationResult = Apollo.MutationResult<DeleteContentMutation>;
export type DeleteContentMutationOptions = Apollo.BaseMutationOptions<DeleteContentMutation, DeleteContentMutationVariables>;
export const ConfigDocument = gql`
    query Config {
  config {
    content {
      id
      identifier
      namePlural
      nameSingular
      schema
    }
    languages {
      defaultLanguageId
      languages {
        id
        tag
        description
      }
    }
  }
}
    `;

/**
 * __useConfigQuery__
 *
 * To run a query within a React component, call `useConfigQuery` and pass it any options that fit your needs.
 * When your component renders, `useConfigQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConfigQuery({
 *   variables: {
 *   },
 * });
 */
export function useConfigQuery(baseOptions?: Apollo.QueryHookOptions<ConfigQuery, ConfigQueryVariables>) {
        return Apollo.useQuery<ConfigQuery, ConfigQueryVariables>(ConfigDocument, baseOptions);
      }
export function useConfigLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConfigQuery, ConfigQueryVariables>) {
          return Apollo.useLazyQuery<ConfigQuery, ConfigQueryVariables>(ConfigDocument, baseOptions);
        }
export type ConfigQueryHookResult = ReturnType<typeof useConfigQuery>;
export type ConfigLazyQueryHookResult = ReturnType<typeof useConfigLazyQuery>;
export type ConfigQueryResult = Apollo.QueryResult<ConfigQuery, ConfigQueryVariables>;
export const ImageListDocument = gql`
    query ImageList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  images(filter: {title: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...ImageRef
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
  }
}
    ${ImageRefFragmentDoc}`;

/**
 * __useImageListQuery__
 *
 * To run a query within a React component, call `useImageListQuery` and pass it any options that fit your needs.
 * When your component renders, `useImageListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImageListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useImageListQuery(baseOptions?: Apollo.QueryHookOptions<ImageListQuery, ImageListQueryVariables>) {
        return Apollo.useQuery<ImageListQuery, ImageListQueryVariables>(ImageListDocument, baseOptions);
      }
export function useImageListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImageListQuery, ImageListQueryVariables>) {
          return Apollo.useLazyQuery<ImageListQuery, ImageListQueryVariables>(ImageListDocument, baseOptions);
        }
export type ImageListQueryHookResult = ReturnType<typeof useImageListQuery>;
export type ImageListLazyQueryHookResult = ReturnType<typeof useImageListLazyQuery>;
export type ImageListQueryResult = Apollo.QueryResult<ImageListQuery, ImageListQueryVariables>;
export const ImageDocument = gql`
    query Image($id: ID!) {
  image(id: $id) {
    ...FullImage
  }
}
    ${FullImageFragmentDoc}`;

/**
 * __useImageQuery__
 *
 * To run a query within a React component, call `useImageQuery` and pass it any options that fit your needs.
 * When your component renders, `useImageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useImageQuery(baseOptions?: Apollo.QueryHookOptions<ImageQuery, ImageQueryVariables>) {
        return Apollo.useQuery<ImageQuery, ImageQueryVariables>(ImageDocument, baseOptions);
      }
export function useImageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImageQuery, ImageQueryVariables>) {
          return Apollo.useLazyQuery<ImageQuery, ImageQueryVariables>(ImageDocument, baseOptions);
        }
export type ImageQueryHookResult = ReturnType<typeof useImageQuery>;
export type ImageLazyQueryHookResult = ReturnType<typeof useImageLazyQuery>;
export type ImageQueryResult = Apollo.QueryResult<ImageQuery, ImageQueryVariables>;
export const UploadImageDocument = gql`
    mutation UploadImage($input: UploadImageInput!) {
  uploadImage(input: $input) {
    ...ImageRef
  }
}
    ${ImageRefFragmentDoc}`;
export type UploadImageMutationFn = Apollo.MutationFunction<UploadImageMutation, UploadImageMutationVariables>;

/**
 * __useUploadImageMutation__
 *
 * To run a mutation, you first call `useUploadImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadImageMutation, { data, loading, error }] = useUploadImageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUploadImageMutation(baseOptions?: Apollo.MutationHookOptions<UploadImageMutation, UploadImageMutationVariables>) {
        return Apollo.useMutation<UploadImageMutation, UploadImageMutationVariables>(UploadImageDocument, baseOptions);
      }
export type UploadImageMutationHookResult = ReturnType<typeof useUploadImageMutation>;
export type UploadImageMutationResult = Apollo.MutationResult<UploadImageMutation>;
export type UploadImageMutationOptions = Apollo.BaseMutationOptions<UploadImageMutation, UploadImageMutationVariables>;
export const UpdateImageDocument = gql`
    mutation UpdateImage($id: ID!, $input: UpdateImageInput!) {
  updateImage(id: $id, input: $input) {
    ...FullImage
  }
}
    ${FullImageFragmentDoc}`;
export type UpdateImageMutationFn = Apollo.MutationFunction<UpdateImageMutation, UpdateImageMutationVariables>;

/**
 * __useUpdateImageMutation__
 *
 * To run a mutation, you first call `useUpdateImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateImageMutation, { data, loading, error }] = useUpdateImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateImageMutation(baseOptions?: Apollo.MutationHookOptions<UpdateImageMutation, UpdateImageMutationVariables>) {
        return Apollo.useMutation<UpdateImageMutation, UpdateImageMutationVariables>(UpdateImageDocument, baseOptions);
      }
export type UpdateImageMutationHookResult = ReturnType<typeof useUpdateImageMutation>;
export type UpdateImageMutationResult = Apollo.MutationResult<UpdateImageMutation>;
export type UpdateImageMutationOptions = Apollo.BaseMutationOptions<UpdateImageMutation, UpdateImageMutationVariables>;
export const DeleteImageDocument = gql`
    mutation DeleteImage($id: ID!) {
  deleteImage(id: $id)
}
    `;
export type DeleteImageMutationFn = Apollo.MutationFunction<DeleteImageMutation, DeleteImageMutationVariables>;

/**
 * __useDeleteImageMutation__
 *
 * To run a mutation, you first call `useDeleteImageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteImageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteImageMutation, { data, loading, error }] = useDeleteImageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteImageMutation(baseOptions?: Apollo.MutationHookOptions<DeleteImageMutation, DeleteImageMutationVariables>) {
        return Apollo.useMutation<DeleteImageMutation, DeleteImageMutationVariables>(DeleteImageDocument, baseOptions);
      }
export type DeleteImageMutationHookResult = ReturnType<typeof useDeleteImageMutation>;
export type DeleteImageMutationResult = Apollo.MutationResult<DeleteImageMutation>;
export type DeleteImageMutationOptions = Apollo.BaseMutationOptions<DeleteImageMutation, DeleteImageMutationVariables>;
export const MemberPlanListDocument = gql`
    query MemberPlanList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  memberPlans(filter: {name: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...FullMemberPlan
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullMemberPlanFragmentDoc}`;

/**
 * __useMemberPlanListQuery__
 *
 * To run a query within a React component, call `useMemberPlanListQuery` and pass it any options that fit your needs.
 * When your component renders, `useMemberPlanListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMemberPlanListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useMemberPlanListQuery(baseOptions?: Apollo.QueryHookOptions<MemberPlanListQuery, MemberPlanListQueryVariables>) {
        return Apollo.useQuery<MemberPlanListQuery, MemberPlanListQueryVariables>(MemberPlanListDocument, baseOptions);
      }
export function useMemberPlanListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MemberPlanListQuery, MemberPlanListQueryVariables>) {
          return Apollo.useLazyQuery<MemberPlanListQuery, MemberPlanListQueryVariables>(MemberPlanListDocument, baseOptions);
        }
export type MemberPlanListQueryHookResult = ReturnType<typeof useMemberPlanListQuery>;
export type MemberPlanListLazyQueryHookResult = ReturnType<typeof useMemberPlanListLazyQuery>;
export type MemberPlanListQueryResult = Apollo.QueryResult<MemberPlanListQuery, MemberPlanListQueryVariables>;
export const MemberPlanDocument = gql`
    query MemberPlan($id: ID!) {
  memberPlan(id: $id) {
    ...FullMemberPlan
  }
}
    ${FullMemberPlanFragmentDoc}`;

/**
 * __useMemberPlanQuery__
 *
 * To run a query within a React component, call `useMemberPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useMemberPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMemberPlanQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMemberPlanQuery(baseOptions?: Apollo.QueryHookOptions<MemberPlanQuery, MemberPlanQueryVariables>) {
        return Apollo.useQuery<MemberPlanQuery, MemberPlanQueryVariables>(MemberPlanDocument, baseOptions);
      }
export function useMemberPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MemberPlanQuery, MemberPlanQueryVariables>) {
          return Apollo.useLazyQuery<MemberPlanQuery, MemberPlanQueryVariables>(MemberPlanDocument, baseOptions);
        }
export type MemberPlanQueryHookResult = ReturnType<typeof useMemberPlanQuery>;
export type MemberPlanLazyQueryHookResult = ReturnType<typeof useMemberPlanLazyQuery>;
export type MemberPlanQueryResult = Apollo.QueryResult<MemberPlanQuery, MemberPlanQueryVariables>;
export const CreateMemberPlanDocument = gql`
    mutation CreateMemberPlan($input: MemberPlanInput!) {
  createMemberPlan(input: $input) {
    ...FullMemberPlan
  }
}
    ${FullMemberPlanFragmentDoc}`;
export type CreateMemberPlanMutationFn = Apollo.MutationFunction<CreateMemberPlanMutation, CreateMemberPlanMutationVariables>;

/**
 * __useCreateMemberPlanMutation__
 *
 * To run a mutation, you first call `useCreateMemberPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateMemberPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createMemberPlanMutation, { data, loading, error }] = useCreateMemberPlanMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateMemberPlanMutation(baseOptions?: Apollo.MutationHookOptions<CreateMemberPlanMutation, CreateMemberPlanMutationVariables>) {
        return Apollo.useMutation<CreateMemberPlanMutation, CreateMemberPlanMutationVariables>(CreateMemberPlanDocument, baseOptions);
      }
export type CreateMemberPlanMutationHookResult = ReturnType<typeof useCreateMemberPlanMutation>;
export type CreateMemberPlanMutationResult = Apollo.MutationResult<CreateMemberPlanMutation>;
export type CreateMemberPlanMutationOptions = Apollo.BaseMutationOptions<CreateMemberPlanMutation, CreateMemberPlanMutationVariables>;
export const UpdateMemberPlanDocument = gql`
    mutation UpdateMemberPlan($id: ID!, $input: MemberPlanInput!) {
  updateMemberPlan(id: $id, input: $input) {
    ...FullMemberPlan
  }
}
    ${FullMemberPlanFragmentDoc}`;
export type UpdateMemberPlanMutationFn = Apollo.MutationFunction<UpdateMemberPlanMutation, UpdateMemberPlanMutationVariables>;

/**
 * __useUpdateMemberPlanMutation__
 *
 * To run a mutation, you first call `useUpdateMemberPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMemberPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMemberPlanMutation, { data, loading, error }] = useUpdateMemberPlanMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMemberPlanMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMemberPlanMutation, UpdateMemberPlanMutationVariables>) {
        return Apollo.useMutation<UpdateMemberPlanMutation, UpdateMemberPlanMutationVariables>(UpdateMemberPlanDocument, baseOptions);
      }
export type UpdateMemberPlanMutationHookResult = ReturnType<typeof useUpdateMemberPlanMutation>;
export type UpdateMemberPlanMutationResult = Apollo.MutationResult<UpdateMemberPlanMutation>;
export type UpdateMemberPlanMutationOptions = Apollo.BaseMutationOptions<UpdateMemberPlanMutation, UpdateMemberPlanMutationVariables>;
export const DeleteMemberPlanDocument = gql`
    mutation DeleteMemberPlan($id: ID!) {
  deleteMemberPlan(id: $id)
}
    `;
export type DeleteMemberPlanMutationFn = Apollo.MutationFunction<DeleteMemberPlanMutation, DeleteMemberPlanMutationVariables>;

/**
 * __useDeleteMemberPlanMutation__
 *
 * To run a mutation, you first call `useDeleteMemberPlanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteMemberPlanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteMemberPlanMutation, { data, loading, error }] = useDeleteMemberPlanMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteMemberPlanMutation(baseOptions?: Apollo.MutationHookOptions<DeleteMemberPlanMutation, DeleteMemberPlanMutationVariables>) {
        return Apollo.useMutation<DeleteMemberPlanMutation, DeleteMemberPlanMutationVariables>(DeleteMemberPlanDocument, baseOptions);
      }
export type DeleteMemberPlanMutationHookResult = ReturnType<typeof useDeleteMemberPlanMutation>;
export type DeleteMemberPlanMutationResult = Apollo.MutationResult<DeleteMemberPlanMutation>;
export type DeleteMemberPlanMutationOptions = Apollo.BaseMutationOptions<DeleteMemberPlanMutation, DeleteMemberPlanMutationVariables>;
export const NavigationListDocument = gql`
    query NavigationList {
  navigations {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;

/**
 * __useNavigationListQuery__
 *
 * To run a query within a React component, call `useNavigationListQuery` and pass it any options that fit your needs.
 * When your component renders, `useNavigationListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNavigationListQuery({
 *   variables: {
 *   },
 * });
 */
export function useNavigationListQuery(baseOptions?: Apollo.QueryHookOptions<NavigationListQuery, NavigationListQueryVariables>) {
        return Apollo.useQuery<NavigationListQuery, NavigationListQueryVariables>(NavigationListDocument, baseOptions);
      }
export function useNavigationListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NavigationListQuery, NavigationListQueryVariables>) {
          return Apollo.useLazyQuery<NavigationListQuery, NavigationListQueryVariables>(NavigationListDocument, baseOptions);
        }
export type NavigationListQueryHookResult = ReturnType<typeof useNavigationListQuery>;
export type NavigationListLazyQueryHookResult = ReturnType<typeof useNavigationListLazyQuery>;
export type NavigationListQueryResult = Apollo.QueryResult<NavigationListQuery, NavigationListQueryVariables>;
export const NavigationDocument = gql`
    query Navigation($id: ID!) {
  navigation(id: $id) {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;

/**
 * __useNavigationQuery__
 *
 * To run a query within a React component, call `useNavigationQuery` and pass it any options that fit your needs.
 * When your component renders, `useNavigationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNavigationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useNavigationQuery(baseOptions?: Apollo.QueryHookOptions<NavigationQuery, NavigationQueryVariables>) {
        return Apollo.useQuery<NavigationQuery, NavigationQueryVariables>(NavigationDocument, baseOptions);
      }
export function useNavigationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NavigationQuery, NavigationQueryVariables>) {
          return Apollo.useLazyQuery<NavigationQuery, NavigationQueryVariables>(NavigationDocument, baseOptions);
        }
export type NavigationQueryHookResult = ReturnType<typeof useNavigationQuery>;
export type NavigationLazyQueryHookResult = ReturnType<typeof useNavigationLazyQuery>;
export type NavigationQueryResult = Apollo.QueryResult<NavigationQuery, NavigationQueryVariables>;
export const CreateNavigationDocument = gql`
    mutation CreateNavigation($input: NavigationInput!) {
  createNavigation(input: $input) {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;
export type CreateNavigationMutationFn = Apollo.MutationFunction<CreateNavigationMutation, CreateNavigationMutationVariables>;

/**
 * __useCreateNavigationMutation__
 *
 * To run a mutation, you first call `useCreateNavigationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNavigationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNavigationMutation, { data, loading, error }] = useCreateNavigationMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateNavigationMutation(baseOptions?: Apollo.MutationHookOptions<CreateNavigationMutation, CreateNavigationMutationVariables>) {
        return Apollo.useMutation<CreateNavigationMutation, CreateNavigationMutationVariables>(CreateNavigationDocument, baseOptions);
      }
export type CreateNavigationMutationHookResult = ReturnType<typeof useCreateNavigationMutation>;
export type CreateNavigationMutationResult = Apollo.MutationResult<CreateNavigationMutation>;
export type CreateNavigationMutationOptions = Apollo.BaseMutationOptions<CreateNavigationMutation, CreateNavigationMutationVariables>;
export const UpdateNavigationDocument = gql`
    mutation UpdateNavigation($id: ID!, $input: NavigationInput!) {
  updateNavigation(id: $id, input: $input) {
    ...FullNavigation
  }
}
    ${FullNavigationFragmentDoc}`;
export type UpdateNavigationMutationFn = Apollo.MutationFunction<UpdateNavigationMutation, UpdateNavigationMutationVariables>;

/**
 * __useUpdateNavigationMutation__
 *
 * To run a mutation, you first call `useUpdateNavigationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateNavigationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateNavigationMutation, { data, loading, error }] = useUpdateNavigationMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateNavigationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateNavigationMutation, UpdateNavigationMutationVariables>) {
        return Apollo.useMutation<UpdateNavigationMutation, UpdateNavigationMutationVariables>(UpdateNavigationDocument, baseOptions);
      }
export type UpdateNavigationMutationHookResult = ReturnType<typeof useUpdateNavigationMutation>;
export type UpdateNavigationMutationResult = Apollo.MutationResult<UpdateNavigationMutation>;
export type UpdateNavigationMutationOptions = Apollo.BaseMutationOptions<UpdateNavigationMutation, UpdateNavigationMutationVariables>;
export const DeleteNavigationDocument = gql`
    mutation DeleteNavigation($id: ID!) {
  deleteNavigation(id: $id)
}
    `;
export type DeleteNavigationMutationFn = Apollo.MutationFunction<DeleteNavigationMutation, DeleteNavigationMutationVariables>;

/**
 * __useDeleteNavigationMutation__
 *
 * To run a mutation, you first call `useDeleteNavigationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNavigationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNavigationMutation, { data, loading, error }] = useDeleteNavigationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteNavigationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNavigationMutation, DeleteNavigationMutationVariables>) {
        return Apollo.useMutation<DeleteNavigationMutation, DeleteNavigationMutationVariables>(DeleteNavigationDocument, baseOptions);
      }
export type DeleteNavigationMutationHookResult = ReturnType<typeof useDeleteNavigationMutation>;
export type DeleteNavigationMutationResult = Apollo.MutationResult<DeleteNavigationMutation>;
export type DeleteNavigationMutationOptions = Apollo.BaseMutationOptions<DeleteNavigationMutation, DeleteNavigationMutationVariables>;
export const PageListDocument = gql`
    query PageList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int, $skip: Int, $order: SortOrder, $sort: PageSort) {
  pages(filter: {title: $filter}, after: $after, before: $before, first: $first, last: $last, skip: $skip, order: $order, sort: $sort) {
    nodes {
      ...PageRef
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${PageRefFragmentDoc}`;

/**
 * __usePageListQuery__
 *
 * To run a query within a React component, call `usePageListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePageListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePageListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      skip: // value for 'skip'
 *      order: // value for 'order'
 *      sort: // value for 'sort'
 *   },
 * });
 */
export function usePageListQuery(baseOptions?: Apollo.QueryHookOptions<PageListQuery, PageListQueryVariables>) {
        return Apollo.useQuery<PageListQuery, PageListQueryVariables>(PageListDocument, baseOptions);
      }
export function usePageListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PageListQuery, PageListQueryVariables>) {
          return Apollo.useLazyQuery<PageListQuery, PageListQueryVariables>(PageListDocument, baseOptions);
        }
export type PageListQueryHookResult = ReturnType<typeof usePageListQuery>;
export type PageListLazyQueryHookResult = ReturnType<typeof usePageListLazyQuery>;
export type PageListQueryResult = Apollo.QueryResult<PageListQuery, PageListQueryVariables>;
export const CreatePageDocument = gql`
    mutation CreatePage($input: PageInput!) {
  createPage(input: $input) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type CreatePageMutationFn = Apollo.MutationFunction<CreatePageMutation, CreatePageMutationVariables>;

/**
 * __useCreatePageMutation__
 *
 * To run a mutation, you first call `useCreatePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPageMutation, { data, loading, error }] = useCreatePageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePageMutation(baseOptions?: Apollo.MutationHookOptions<CreatePageMutation, CreatePageMutationVariables>) {
        return Apollo.useMutation<CreatePageMutation, CreatePageMutationVariables>(CreatePageDocument, baseOptions);
      }
export type CreatePageMutationHookResult = ReturnType<typeof useCreatePageMutation>;
export type CreatePageMutationResult = Apollo.MutationResult<CreatePageMutation>;
export type CreatePageMutationOptions = Apollo.BaseMutationOptions<CreatePageMutation, CreatePageMutationVariables>;
export const UpdatePageDocument = gql`
    mutation UpdatePage($id: ID!, $input: PageInput!) {
  updatePage(id: $id, input: $input) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type UpdatePageMutationFn = Apollo.MutationFunction<UpdatePageMutation, UpdatePageMutationVariables>;

/**
 * __useUpdatePageMutation__
 *
 * To run a mutation, you first call `useUpdatePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePageMutation, { data, loading, error }] = useUpdatePageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePageMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePageMutation, UpdatePageMutationVariables>) {
        return Apollo.useMutation<UpdatePageMutation, UpdatePageMutationVariables>(UpdatePageDocument, baseOptions);
      }
export type UpdatePageMutationHookResult = ReturnType<typeof useUpdatePageMutation>;
export type UpdatePageMutationResult = Apollo.MutationResult<UpdatePageMutation>;
export type UpdatePageMutationOptions = Apollo.BaseMutationOptions<UpdatePageMutation, UpdatePageMutationVariables>;
export const PublishPageDocument = gql`
    mutation PublishPage($id: ID!, $publishAt: DateTime, $publishedAt: DateTime, $updatedAt: DateTime) {
  publishPage(id: $id, publishAt: $publishAt, publishedAt: $publishedAt, updatedAt: $updatedAt) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type PublishPageMutationFn = Apollo.MutationFunction<PublishPageMutation, PublishPageMutationVariables>;

/**
 * __usePublishPageMutation__
 *
 * To run a mutation, you first call `usePublishPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePublishPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [publishPageMutation, { data, loading, error }] = usePublishPageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      publishAt: // value for 'publishAt'
 *      publishedAt: // value for 'publishedAt'
 *      updatedAt: // value for 'updatedAt'
 *   },
 * });
 */
export function usePublishPageMutation(baseOptions?: Apollo.MutationHookOptions<PublishPageMutation, PublishPageMutationVariables>) {
        return Apollo.useMutation<PublishPageMutation, PublishPageMutationVariables>(PublishPageDocument, baseOptions);
      }
export type PublishPageMutationHookResult = ReturnType<typeof usePublishPageMutation>;
export type PublishPageMutationResult = Apollo.MutationResult<PublishPageMutation>;
export type PublishPageMutationOptions = Apollo.BaseMutationOptions<PublishPageMutation, PublishPageMutationVariables>;
export const UnpublishPageDocument = gql`
    mutation UnpublishPage($id: ID!) {
  unpublishPage(id: $id) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type UnpublishPageMutationFn = Apollo.MutationFunction<UnpublishPageMutation, UnpublishPageMutationVariables>;

/**
 * __useUnpublishPageMutation__
 *
 * To run a mutation, you first call `useUnpublishPageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpublishPageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpublishPageMutation, { data, loading, error }] = useUnpublishPageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnpublishPageMutation(baseOptions?: Apollo.MutationHookOptions<UnpublishPageMutation, UnpublishPageMutationVariables>) {
        return Apollo.useMutation<UnpublishPageMutation, UnpublishPageMutationVariables>(UnpublishPageDocument, baseOptions);
      }
export type UnpublishPageMutationHookResult = ReturnType<typeof useUnpublishPageMutation>;
export type UnpublishPageMutationResult = Apollo.MutationResult<UnpublishPageMutation>;
export type UnpublishPageMutationOptions = Apollo.BaseMutationOptions<UnpublishPageMutation, UnpublishPageMutationVariables>;
export const DeletePageDocument = gql`
    mutation DeletePage($id: ID!) {
  deletePage(id: $id)
}
    `;
export type DeletePageMutationFn = Apollo.MutationFunction<DeletePageMutation, DeletePageMutationVariables>;

/**
 * __useDeletePageMutation__
 *
 * To run a mutation, you first call `useDeletePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePageMutation, { data, loading, error }] = useDeletePageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePageMutation(baseOptions?: Apollo.MutationHookOptions<DeletePageMutation, DeletePageMutationVariables>) {
        return Apollo.useMutation<DeletePageMutation, DeletePageMutationVariables>(DeletePageDocument, baseOptions);
      }
export type DeletePageMutationHookResult = ReturnType<typeof useDeletePageMutation>;
export type DeletePageMutationResult = Apollo.MutationResult<DeletePageMutation>;
export type DeletePageMutationOptions = Apollo.BaseMutationOptions<DeletePageMutation, DeletePageMutationVariables>;
export const DuplicatePageDocument = gql`
    mutation DuplicatePage($id: ID!) {
  duplicatePage(id: $id) {
    ...MutationPage
  }
}
    ${MutationPageFragmentDoc}`;
export type DuplicatePageMutationFn = Apollo.MutationFunction<DuplicatePageMutation, DuplicatePageMutationVariables>;

/**
 * __useDuplicatePageMutation__
 *
 * To run a mutation, you first call `useDuplicatePageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDuplicatePageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [duplicatePageMutation, { data, loading, error }] = useDuplicatePageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDuplicatePageMutation(baseOptions?: Apollo.MutationHookOptions<DuplicatePageMutation, DuplicatePageMutationVariables>) {
        return Apollo.useMutation<DuplicatePageMutation, DuplicatePageMutationVariables>(DuplicatePageDocument, baseOptions);
      }
export type DuplicatePageMutationHookResult = ReturnType<typeof useDuplicatePageMutation>;
export type DuplicatePageMutationResult = Apollo.MutationResult<DuplicatePageMutation>;
export type DuplicatePageMutationOptions = Apollo.BaseMutationOptions<DuplicatePageMutation, DuplicatePageMutationVariables>;
export const PageDocument = gql`
    query Page($id: ID!) {
  page(id: $id) {
    id
    pending {
      publishAt
    }
    published {
      publishedAt
      updatedAt
    }
    latest {
      publishedAt
      updatedAt
      slug
      title
      description
      image {
        ...ImageRef
      }
      tags
      properties {
        key
        value
        public
      }
      socialMediaTitle
      socialMediaDescription
      socialMediaImage {
        ...ImageRef
      }
      blocks {
        ...FullBlock
      }
    }
  }
}
    ${ImageRefFragmentDoc}
${FullBlockFragmentDoc}`;

/**
 * __usePageQuery__
 *
 * To run a query within a React component, call `usePageQuery` and pass it any options that fit your needs.
 * When your component renders, `usePageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePageQuery(baseOptions?: Apollo.QueryHookOptions<PageQuery, PageQueryVariables>) {
        return Apollo.useQuery<PageQuery, PageQueryVariables>(PageDocument, baseOptions);
      }
export function usePageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PageQuery, PageQueryVariables>) {
          return Apollo.useLazyQuery<PageQuery, PageQueryVariables>(PageDocument, baseOptions);
        }
export type PageQueryHookResult = ReturnType<typeof usePageQuery>;
export type PageLazyQueryHookResult = ReturnType<typeof usePageLazyQuery>;
export type PageQueryResult = Apollo.QueryResult<PageQuery, PageQueryVariables>;
export const PaymentProviderListDocument = gql`
    query PaymentProviderList {
  paymentProviders {
    ...FullPaymentProvider
  }
}
    ${FullPaymentProviderFragmentDoc}`;

/**
 * __usePaymentProviderListQuery__
 *
 * To run a query within a React component, call `usePaymentProviderListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentProviderListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentProviderListQuery({
 *   variables: {
 *   },
 * });
 */
export function usePaymentProviderListQuery(baseOptions?: Apollo.QueryHookOptions<PaymentProviderListQuery, PaymentProviderListQueryVariables>) {
        return Apollo.useQuery<PaymentProviderListQuery, PaymentProviderListQueryVariables>(PaymentProviderListDocument, baseOptions);
      }
export function usePaymentProviderListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentProviderListQuery, PaymentProviderListQueryVariables>) {
          return Apollo.useLazyQuery<PaymentProviderListQuery, PaymentProviderListQueryVariables>(PaymentProviderListDocument, baseOptions);
        }
export type PaymentProviderListQueryHookResult = ReturnType<typeof usePaymentProviderListQuery>;
export type PaymentProviderListLazyQueryHookResult = ReturnType<typeof usePaymentProviderListLazyQuery>;
export type PaymentProviderListQueryResult = Apollo.QueryResult<PaymentProviderListQuery, PaymentProviderListQueryVariables>;
export const PaymentMethodListDocument = gql`
    query PaymentMethodList {
  paymentMethods {
    ...FullPaymentMethod
  }
}
    ${FullPaymentMethodFragmentDoc}`;

/**
 * __usePaymentMethodListQuery__
 *
 * To run a query within a React component, call `usePaymentMethodListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentMethodListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentMethodListQuery({
 *   variables: {
 *   },
 * });
 */
export function usePaymentMethodListQuery(baseOptions?: Apollo.QueryHookOptions<PaymentMethodListQuery, PaymentMethodListQueryVariables>) {
        return Apollo.useQuery<PaymentMethodListQuery, PaymentMethodListQueryVariables>(PaymentMethodListDocument, baseOptions);
      }
export function usePaymentMethodListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentMethodListQuery, PaymentMethodListQueryVariables>) {
          return Apollo.useLazyQuery<PaymentMethodListQuery, PaymentMethodListQueryVariables>(PaymentMethodListDocument, baseOptions);
        }
export type PaymentMethodListQueryHookResult = ReturnType<typeof usePaymentMethodListQuery>;
export type PaymentMethodListLazyQueryHookResult = ReturnType<typeof usePaymentMethodListLazyQuery>;
export type PaymentMethodListQueryResult = Apollo.QueryResult<PaymentMethodListQuery, PaymentMethodListQueryVariables>;
export const PaymentMethodDocument = gql`
    query PaymentMethod($id: ID!) {
  paymentMethod(id: $id) {
    ...FullPaymentMethod
  }
}
    ${FullPaymentMethodFragmentDoc}`;

/**
 * __usePaymentMethodQuery__
 *
 * To run a query within a React component, call `usePaymentMethodQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentMethodQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentMethodQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePaymentMethodQuery(baseOptions?: Apollo.QueryHookOptions<PaymentMethodQuery, PaymentMethodQueryVariables>) {
        return Apollo.useQuery<PaymentMethodQuery, PaymentMethodQueryVariables>(PaymentMethodDocument, baseOptions);
      }
export function usePaymentMethodLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentMethodQuery, PaymentMethodQueryVariables>) {
          return Apollo.useLazyQuery<PaymentMethodQuery, PaymentMethodQueryVariables>(PaymentMethodDocument, baseOptions);
        }
export type PaymentMethodQueryHookResult = ReturnType<typeof usePaymentMethodQuery>;
export type PaymentMethodLazyQueryHookResult = ReturnType<typeof usePaymentMethodLazyQuery>;
export type PaymentMethodQueryResult = Apollo.QueryResult<PaymentMethodQuery, PaymentMethodQueryVariables>;
export const CreatePaymentMethodDocument = gql`
    mutation CreatePaymentMethod($input: PaymentMethodInput!) {
  createPaymentMethod(input: $input) {
    ...FullPaymentMethod
  }
}
    ${FullPaymentMethodFragmentDoc}`;
export type CreatePaymentMethodMutationFn = Apollo.MutationFunction<CreatePaymentMethodMutation, CreatePaymentMethodMutationVariables>;

/**
 * __useCreatePaymentMethodMutation__
 *
 * To run a mutation, you first call `useCreatePaymentMethodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePaymentMethodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPaymentMethodMutation, { data, loading, error }] = useCreatePaymentMethodMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePaymentMethodMutation(baseOptions?: Apollo.MutationHookOptions<CreatePaymentMethodMutation, CreatePaymentMethodMutationVariables>) {
        return Apollo.useMutation<CreatePaymentMethodMutation, CreatePaymentMethodMutationVariables>(CreatePaymentMethodDocument, baseOptions);
      }
export type CreatePaymentMethodMutationHookResult = ReturnType<typeof useCreatePaymentMethodMutation>;
export type CreatePaymentMethodMutationResult = Apollo.MutationResult<CreatePaymentMethodMutation>;
export type CreatePaymentMethodMutationOptions = Apollo.BaseMutationOptions<CreatePaymentMethodMutation, CreatePaymentMethodMutationVariables>;
export const UpdatePaymentMethodDocument = gql`
    mutation UpdatePaymentMethod($id: ID!, $input: PaymentMethodInput!) {
  updatePaymentMethod(id: $id, input: $input) {
    ...FullPaymentMethod
  }
}
    ${FullPaymentMethodFragmentDoc}`;
export type UpdatePaymentMethodMutationFn = Apollo.MutationFunction<UpdatePaymentMethodMutation, UpdatePaymentMethodMutationVariables>;

/**
 * __useUpdatePaymentMethodMutation__
 *
 * To run a mutation, you first call `useUpdatePaymentMethodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePaymentMethodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePaymentMethodMutation, { data, loading, error }] = useUpdatePaymentMethodMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePaymentMethodMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePaymentMethodMutation, UpdatePaymentMethodMutationVariables>) {
        return Apollo.useMutation<UpdatePaymentMethodMutation, UpdatePaymentMethodMutationVariables>(UpdatePaymentMethodDocument, baseOptions);
      }
export type UpdatePaymentMethodMutationHookResult = ReturnType<typeof useUpdatePaymentMethodMutation>;
export type UpdatePaymentMethodMutationResult = Apollo.MutationResult<UpdatePaymentMethodMutation>;
export type UpdatePaymentMethodMutationOptions = Apollo.BaseMutationOptions<UpdatePaymentMethodMutation, UpdatePaymentMethodMutationVariables>;
export const DeletePaymentMethodDocument = gql`
    mutation DeletePaymentMethod($id: ID!) {
  deletePaymentMethod(id: $id)
}
    `;
export type DeletePaymentMethodMutationFn = Apollo.MutationFunction<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>;

/**
 * __useDeletePaymentMethodMutation__
 *
 * To run a mutation, you first call `useDeletePaymentMethodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePaymentMethodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePaymentMethodMutation, { data, loading, error }] = useDeletePaymentMethodMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePaymentMethodMutation(baseOptions?: Apollo.MutationHookOptions<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>) {
        return Apollo.useMutation<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>(DeletePaymentMethodDocument, baseOptions);
      }
export type DeletePaymentMethodMutationHookResult = ReturnType<typeof useDeletePaymentMethodMutation>;
export type DeletePaymentMethodMutationResult = Apollo.MutationResult<DeletePaymentMethodMutation>;
export type DeletePaymentMethodMutationOptions = Apollo.BaseMutationOptions<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>;
export const PeerProfileDocument = gql`
    query PeerProfile {
  peerProfile {
    ...FullPeerProfile
  }
}
    ${FullPeerProfileFragmentDoc}`;

/**
 * __usePeerProfileQuery__
 *
 * To run a query within a React component, call `usePeerProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerProfileQuery({
 *   variables: {
 *   },
 * });
 */
export function usePeerProfileQuery(baseOptions?: Apollo.QueryHookOptions<PeerProfileQuery, PeerProfileQueryVariables>) {
        return Apollo.useQuery<PeerProfileQuery, PeerProfileQueryVariables>(PeerProfileDocument, baseOptions);
      }
export function usePeerProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerProfileQuery, PeerProfileQueryVariables>) {
          return Apollo.useLazyQuery<PeerProfileQuery, PeerProfileQueryVariables>(PeerProfileDocument, baseOptions);
        }
export type PeerProfileQueryHookResult = ReturnType<typeof usePeerProfileQuery>;
export type PeerProfileLazyQueryHookResult = ReturnType<typeof usePeerProfileLazyQuery>;
export type PeerProfileQueryResult = Apollo.QueryResult<PeerProfileQuery, PeerProfileQueryVariables>;
export const UpdatePeerProfileDocument = gql`
    mutation UpdatePeerProfile($input: PeerProfileInput!) {
  updatePeerProfile(input: $input) {
    ...FullPeerProfile
  }
}
    ${FullPeerProfileFragmentDoc}`;
export type UpdatePeerProfileMutationFn = Apollo.MutationFunction<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>;

/**
 * __useUpdatePeerProfileMutation__
 *
 * To run a mutation, you first call `useUpdatePeerProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePeerProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePeerProfileMutation, { data, loading, error }] = useUpdatePeerProfileMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePeerProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>) {
        return Apollo.useMutation<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>(UpdatePeerProfileDocument, baseOptions);
      }
export type UpdatePeerProfileMutationHookResult = ReturnType<typeof useUpdatePeerProfileMutation>;
export type UpdatePeerProfileMutationResult = Apollo.MutationResult<UpdatePeerProfileMutation>;
export type UpdatePeerProfileMutationOptions = Apollo.BaseMutationOptions<UpdatePeerProfileMutation, UpdatePeerProfileMutationVariables>;
export const PeerListDocument = gql`
    query PeerList {
  peers {
    ...PeerWithProfile
  }
}
    ${PeerWithProfileFragmentDoc}`;

/**
 * __usePeerListQuery__
 *
 * To run a query within a React component, call `usePeerListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerListQuery({
 *   variables: {
 *   },
 * });
 */
export function usePeerListQuery(baseOptions?: Apollo.QueryHookOptions<PeerListQuery, PeerListQueryVariables>) {
        return Apollo.useQuery<PeerListQuery, PeerListQueryVariables>(PeerListDocument, baseOptions);
      }
export function usePeerListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerListQuery, PeerListQueryVariables>) {
          return Apollo.useLazyQuery<PeerListQuery, PeerListQueryVariables>(PeerListDocument, baseOptions);
        }
export type PeerListQueryHookResult = ReturnType<typeof usePeerListQuery>;
export type PeerListLazyQueryHookResult = ReturnType<typeof usePeerListLazyQuery>;
export type PeerListQueryResult = Apollo.QueryResult<PeerListQuery, PeerListQueryVariables>;
export const PeerDocument = gql`
    query Peer($id: ID!) {
  peer(id: $id) {
    ...PeerRef
  }
}
    ${PeerRefFragmentDoc}`;

/**
 * __usePeerQuery__
 *
 * To run a query within a React component, call `usePeerQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePeerQuery(baseOptions?: Apollo.QueryHookOptions<PeerQuery, PeerQueryVariables>) {
        return Apollo.useQuery<PeerQuery, PeerQueryVariables>(PeerDocument, baseOptions);
      }
export function usePeerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeerQuery, PeerQueryVariables>) {
          return Apollo.useLazyQuery<PeerQuery, PeerQueryVariables>(PeerDocument, baseOptions);
        }
export type PeerQueryHookResult = ReturnType<typeof usePeerQuery>;
export type PeerLazyQueryHookResult = ReturnType<typeof usePeerLazyQuery>;
export type PeerQueryResult = Apollo.QueryResult<PeerQuery, PeerQueryVariables>;
export const CreatePeerDocument = gql`
    mutation CreatePeer($input: CreatePeerInput!) {
  createPeer(input: $input) {
    ...PeerRef
  }
}
    ${PeerRefFragmentDoc}`;
export type CreatePeerMutationFn = Apollo.MutationFunction<CreatePeerMutation, CreatePeerMutationVariables>;

/**
 * __useCreatePeerMutation__
 *
 * To run a mutation, you first call `useCreatePeerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePeerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPeerMutation, { data, loading, error }] = useCreatePeerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePeerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePeerMutation, CreatePeerMutationVariables>) {
        return Apollo.useMutation<CreatePeerMutation, CreatePeerMutationVariables>(CreatePeerDocument, baseOptions);
      }
export type CreatePeerMutationHookResult = ReturnType<typeof useCreatePeerMutation>;
export type CreatePeerMutationResult = Apollo.MutationResult<CreatePeerMutation>;
export type CreatePeerMutationOptions = Apollo.BaseMutationOptions<CreatePeerMutation, CreatePeerMutationVariables>;
export const UpdatePeerDocument = gql`
    mutation UpdatePeer($id: ID!, $input: UpdatePeerInput!) {
  updatePeer(id: $id, input: $input) {
    ...PeerRef
  }
}
    ${PeerRefFragmentDoc}`;
export type UpdatePeerMutationFn = Apollo.MutationFunction<UpdatePeerMutation, UpdatePeerMutationVariables>;

/**
 * __useUpdatePeerMutation__
 *
 * To run a mutation, you first call `useUpdatePeerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePeerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePeerMutation, { data, loading, error }] = useUpdatePeerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePeerMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePeerMutation, UpdatePeerMutationVariables>) {
        return Apollo.useMutation<UpdatePeerMutation, UpdatePeerMutationVariables>(UpdatePeerDocument, baseOptions);
      }
export type UpdatePeerMutationHookResult = ReturnType<typeof useUpdatePeerMutation>;
export type UpdatePeerMutationResult = Apollo.MutationResult<UpdatePeerMutation>;
export type UpdatePeerMutationOptions = Apollo.BaseMutationOptions<UpdatePeerMutation, UpdatePeerMutationVariables>;
export const DeletePeerDocument = gql`
    mutation DeletePeer($id: ID!) {
  deletePeer(id: $id)
}
    `;
export type DeletePeerMutationFn = Apollo.MutationFunction<DeletePeerMutation, DeletePeerMutationVariables>;

/**
 * __useDeletePeerMutation__
 *
 * To run a mutation, you first call `useDeletePeerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePeerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePeerMutation, { data, loading, error }] = useDeletePeerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePeerMutation(baseOptions?: Apollo.MutationHookOptions<DeletePeerMutation, DeletePeerMutationVariables>) {
        return Apollo.useMutation<DeletePeerMutation, DeletePeerMutationVariables>(DeletePeerDocument, baseOptions);
      }
export type DeletePeerMutationHookResult = ReturnType<typeof useDeletePeerMutation>;
export type DeletePeerMutationResult = Apollo.MutationResult<DeletePeerMutation>;
export type DeletePeerMutationOptions = Apollo.BaseMutationOptions<DeletePeerMutation, DeletePeerMutationVariables>;
export const TokenListDocument = gql`
    query TokenList {
  tokens {
    ...TokenRef
  }
}
    ${TokenRefFragmentDoc}`;

/**
 * __useTokenListQuery__
 *
 * To run a query within a React component, call `useTokenListQuery` and pass it any options that fit your needs.
 * When your component renders, `useTokenListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTokenListQuery({
 *   variables: {
 *   },
 * });
 */
export function useTokenListQuery(baseOptions?: Apollo.QueryHookOptions<TokenListQuery, TokenListQueryVariables>) {
        return Apollo.useQuery<TokenListQuery, TokenListQueryVariables>(TokenListDocument, baseOptions);
      }
export function useTokenListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TokenListQuery, TokenListQueryVariables>) {
          return Apollo.useLazyQuery<TokenListQuery, TokenListQueryVariables>(TokenListDocument, baseOptions);
        }
export type TokenListQueryHookResult = ReturnType<typeof useTokenListQuery>;
export type TokenListLazyQueryHookResult = ReturnType<typeof useTokenListLazyQuery>;
export type TokenListQueryResult = Apollo.QueryResult<TokenListQuery, TokenListQueryVariables>;
export const CreateTokenDocument = gql`
    mutation CreateToken($input: TokenInput!) {
  createToken(input: $input) {
    id
    name
    token
  }
}
    `;
export type CreateTokenMutationFn = Apollo.MutationFunction<CreateTokenMutation, CreateTokenMutationVariables>;

/**
 * __useCreateTokenMutation__
 *
 * To run a mutation, you first call `useCreateTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTokenMutation, { data, loading, error }] = useCreateTokenMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTokenMutation(baseOptions?: Apollo.MutationHookOptions<CreateTokenMutation, CreateTokenMutationVariables>) {
        return Apollo.useMutation<CreateTokenMutation, CreateTokenMutationVariables>(CreateTokenDocument, baseOptions);
      }
export type CreateTokenMutationHookResult = ReturnType<typeof useCreateTokenMutation>;
export type CreateTokenMutationResult = Apollo.MutationResult<CreateTokenMutation>;
export type CreateTokenMutationOptions = Apollo.BaseMutationOptions<CreateTokenMutation, CreateTokenMutationVariables>;
export const DeleteTokenDocument = gql`
    mutation DeleteToken($id: ID!) {
  deleteToken(id: $id)
}
    `;
export type DeleteTokenMutationFn = Apollo.MutationFunction<DeleteTokenMutation, DeleteTokenMutationVariables>;

/**
 * __useDeleteTokenMutation__
 *
 * To run a mutation, you first call `useDeleteTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTokenMutation, { data, loading, error }] = useDeleteTokenMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteTokenMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTokenMutation, DeleteTokenMutationVariables>) {
        return Apollo.useMutation<DeleteTokenMutation, DeleteTokenMutationVariables>(DeleteTokenDocument, baseOptions);
      }
export type DeleteTokenMutationHookResult = ReturnType<typeof useDeleteTokenMutation>;
export type DeleteTokenMutationResult = Apollo.MutationResult<DeleteTokenMutation>;
export type DeleteTokenMutationOptions = Apollo.BaseMutationOptions<DeleteTokenMutation, DeleteTokenMutationVariables>;
export const UserListDocument = gql`
    query UserList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int, $skip: Int, $order: SortOrder, $sort: UserSort) {
  users(filter: {text: $filter}, after: $after, before: $before, first: $first, last: $last, skip: $skip, order: $order, sort: $sort) {
    nodes {
      ...FullUser
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullUserFragmentDoc}`;

/**
 * __useUserListQuery__
 *
 * To run a query within a React component, call `useUserListQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *      skip: // value for 'skip'
 *      order: // value for 'order'
 *      sort: // value for 'sort'
 *   },
 * });
 */
export function useUserListQuery(baseOptions?: Apollo.QueryHookOptions<UserListQuery, UserListQueryVariables>) {
        return Apollo.useQuery<UserListQuery, UserListQueryVariables>(UserListDocument, baseOptions);
      }
export function useUserListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserListQuery, UserListQueryVariables>) {
          return Apollo.useLazyQuery<UserListQuery, UserListQueryVariables>(UserListDocument, baseOptions);
        }
export type UserListQueryHookResult = ReturnType<typeof useUserListQuery>;
export type UserListLazyQueryHookResult = ReturnType<typeof useUserListLazyQuery>;
export type UserListQueryResult = Apollo.QueryResult<UserListQuery, UserListQueryVariables>;
export const UserDocument = gql`
    query User($id: ID!) {
  user(id: $id) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserQuery(baseOptions?: Apollo.QueryHookOptions<UserQuery, UserQueryVariables>) {
        return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
      }
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
          return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
        }
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export const CreateUserDocument = gql`
    mutation CreateUser($input: UserInput!, $password: String!) {
  createUser(input: $input, password: $password) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;
export type CreateUserMutationFn = Apollo.MutationFunction<CreateUserMutation, CreateUserMutationVariables>;

/**
 * __useCreateUserMutation__
 *
 * To run a mutation, you first call `useCreateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserMutation, { data, loading, error }] = useCreateUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useCreateUserMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserMutation, CreateUserMutationVariables>) {
        return Apollo.useMutation<CreateUserMutation, CreateUserMutationVariables>(CreateUserDocument, baseOptions);
      }
export type CreateUserMutationHookResult = ReturnType<typeof useCreateUserMutation>;
export type CreateUserMutationResult = Apollo.MutationResult<CreateUserMutation>;
export type CreateUserMutationOptions = Apollo.BaseMutationOptions<CreateUserMutation, CreateUserMutationVariables>;
export const UpdateUserDocument = gql`
    mutation UpdateUser($id: ID!, $input: UserInput!) {
  updateUser(id: $id, input: $input) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;
export type UpdateUserMutationFn = Apollo.MutationFunction<UpdateUserMutation, UpdateUserMutationVariables>;

/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserMutation, UpdateUserMutationVariables>) {
        return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, baseOptions);
      }
export type UpdateUserMutationHookResult = ReturnType<typeof useUpdateUserMutation>;
export type UpdateUserMutationResult = Apollo.MutationResult<UpdateUserMutation>;
export type UpdateUserMutationOptions = Apollo.BaseMutationOptions<UpdateUserMutation, UpdateUserMutationVariables>;
export const UpdateUserSubscriptionDocument = gql`
    mutation UpdateUserSubscription($userID: ID!, $input: UserSubscriptionInput!) {
  updateUserSubscription(userID: $userID, input: $input) {
    ...FullUserSubscription
  }
}
    ${FullUserSubscriptionFragmentDoc}`;
export type UpdateUserSubscriptionMutationFn = Apollo.MutationFunction<UpdateUserSubscriptionMutation, UpdateUserSubscriptionMutationVariables>;

/**
 * __useUpdateUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpdateUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserSubscriptionMutation, { data, loading, error }] = useUpdateUserSubscriptionMutation({
 *   variables: {
 *      userID: // value for 'userID'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserSubscriptionMutation, UpdateUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<UpdateUserSubscriptionMutation, UpdateUserSubscriptionMutationVariables>(UpdateUserSubscriptionDocument, baseOptions);
      }
export type UpdateUserSubscriptionMutationHookResult = ReturnType<typeof useUpdateUserSubscriptionMutation>;
export type UpdateUserSubscriptionMutationResult = Apollo.MutationResult<UpdateUserSubscriptionMutation>;
export type UpdateUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpdateUserSubscriptionMutation, UpdateUserSubscriptionMutationVariables>;
export const ResetUserPasswordDocument = gql`
    mutation ResetUserPassword($id: ID!, $password: String!) {
  resetUserPassword(id: $id, password: $password) {
    ...FullUser
  }
}
    ${FullUserFragmentDoc}`;
export type ResetUserPasswordMutationFn = Apollo.MutationFunction<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>;

/**
 * __useResetUserPasswordMutation__
 *
 * To run a mutation, you first call `useResetUserPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetUserPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetUserPasswordMutation, { data, loading, error }] = useResetUserPasswordMutation({
 *   variables: {
 *      id: // value for 'id'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useResetUserPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>) {
        return Apollo.useMutation<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>(ResetUserPasswordDocument, baseOptions);
      }
export type ResetUserPasswordMutationHookResult = ReturnType<typeof useResetUserPasswordMutation>;
export type ResetUserPasswordMutationResult = Apollo.MutationResult<ResetUserPasswordMutation>;
export type ResetUserPasswordMutationOptions = Apollo.BaseMutationOptions<ResetUserPasswordMutation, ResetUserPasswordMutationVariables>;
export const DeleteUserDocument = gql`
    mutation DeleteUser($id: ID!) {
  deleteUser(id: $id)
}
    `;
export type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>) {
        return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, baseOptions);
      }
export type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export const DeleteUserSubscriptionDocument = gql`
    mutation DeleteUserSubscription($userID: ID!) {
  deleteUserSubscription(userID: $userID)
}
    `;
export type DeleteUserSubscriptionMutationFn = Apollo.MutationFunction<DeleteUserSubscriptionMutation, DeleteUserSubscriptionMutationVariables>;

/**
 * __useDeleteUserSubscriptionMutation__
 *
 * To run a mutation, you first call `useDeleteUserSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserSubscriptionMutation, { data, loading, error }] = useDeleteUserSubscriptionMutation({
 *   variables: {
 *      userID: // value for 'userID'
 *   },
 * });
 */
export function useDeleteUserSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserSubscriptionMutation, DeleteUserSubscriptionMutationVariables>) {
        return Apollo.useMutation<DeleteUserSubscriptionMutation, DeleteUserSubscriptionMutationVariables>(DeleteUserSubscriptionDocument, baseOptions);
      }
export type DeleteUserSubscriptionMutationHookResult = ReturnType<typeof useDeleteUserSubscriptionMutation>;
export type DeleteUserSubscriptionMutationResult = Apollo.MutationResult<DeleteUserSubscriptionMutation>;
export type DeleteUserSubscriptionMutationOptions = Apollo.BaseMutationOptions<DeleteUserSubscriptionMutation, DeleteUserSubscriptionMutationVariables>;
export const UserRoleListDocument = gql`
    query UserRoleList($filter: String, $after: ID, $before: ID, $first: Int, $last: Int) {
  userRoles(filter: {name: $filter}, after: $after, before: $before, first: $first, last: $last) {
    nodes {
      ...FullUserRole
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullUserRoleFragmentDoc}`;

/**
 * __useUserRoleListQuery__
 *
 * To run a query within a React component, call `useUserRoleListQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserRoleListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserRoleListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      after: // value for 'after'
 *      before: // value for 'before'
 *      first: // value for 'first'
 *      last: // value for 'last'
 *   },
 * });
 */
export function useUserRoleListQuery(baseOptions?: Apollo.QueryHookOptions<UserRoleListQuery, UserRoleListQueryVariables>) {
        return Apollo.useQuery<UserRoleListQuery, UserRoleListQueryVariables>(UserRoleListDocument, baseOptions);
      }
export function useUserRoleListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserRoleListQuery, UserRoleListQueryVariables>) {
          return Apollo.useLazyQuery<UserRoleListQuery, UserRoleListQueryVariables>(UserRoleListDocument, baseOptions);
        }
export type UserRoleListQueryHookResult = ReturnType<typeof useUserRoleListQuery>;
export type UserRoleListLazyQueryHookResult = ReturnType<typeof useUserRoleListLazyQuery>;
export type UserRoleListQueryResult = Apollo.QueryResult<UserRoleListQuery, UserRoleListQueryVariables>;
export const PermissionListDocument = gql`
    query PermissionList {
  permissions {
    ...FullPermission
  }
}
    ${FullPermissionFragmentDoc}`;

/**
 * __usePermissionListQuery__
 *
 * To run a query within a React component, call `usePermissionListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePermissionListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePermissionListQuery({
 *   variables: {
 *   },
 * });
 */
export function usePermissionListQuery(baseOptions?: Apollo.QueryHookOptions<PermissionListQuery, PermissionListQueryVariables>) {
        return Apollo.useQuery<PermissionListQuery, PermissionListQueryVariables>(PermissionListDocument, baseOptions);
      }
export function usePermissionListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PermissionListQuery, PermissionListQueryVariables>) {
          return Apollo.useLazyQuery<PermissionListQuery, PermissionListQueryVariables>(PermissionListDocument, baseOptions);
        }
export type PermissionListQueryHookResult = ReturnType<typeof usePermissionListQuery>;
export type PermissionListLazyQueryHookResult = ReturnType<typeof usePermissionListLazyQuery>;
export type PermissionListQueryResult = Apollo.QueryResult<PermissionListQuery, PermissionListQueryVariables>;
export const UserRoleDocument = gql`
    query UserRole($id: ID!) {
  userRole(id: $id) {
    ...FullUserRole
  }
}
    ${FullUserRoleFragmentDoc}`;

/**
 * __useUserRoleQuery__
 *
 * To run a query within a React component, call `useUserRoleQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserRoleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserRoleQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserRoleQuery(baseOptions?: Apollo.QueryHookOptions<UserRoleQuery, UserRoleQueryVariables>) {
        return Apollo.useQuery<UserRoleQuery, UserRoleQueryVariables>(UserRoleDocument, baseOptions);
      }
export function useUserRoleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserRoleQuery, UserRoleQueryVariables>) {
          return Apollo.useLazyQuery<UserRoleQuery, UserRoleQueryVariables>(UserRoleDocument, baseOptions);
        }
export type UserRoleQueryHookResult = ReturnType<typeof useUserRoleQuery>;
export type UserRoleLazyQueryHookResult = ReturnType<typeof useUserRoleLazyQuery>;
export type UserRoleQueryResult = Apollo.QueryResult<UserRoleQuery, UserRoleQueryVariables>;
export const CreateUserRoleDocument = gql`
    mutation CreateUserRole($input: UserRoleInput!) {
  createUserRole(input: $input) {
    ...FullUserRole
  }
}
    ${FullUserRoleFragmentDoc}`;
export type CreateUserRoleMutationFn = Apollo.MutationFunction<CreateUserRoleMutation, CreateUserRoleMutationVariables>;

/**
 * __useCreateUserRoleMutation__
 *
 * To run a mutation, you first call `useCreateUserRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserRoleMutation, { data, loading, error }] = useCreateUserRoleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateUserRoleMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserRoleMutation, CreateUserRoleMutationVariables>) {
        return Apollo.useMutation<CreateUserRoleMutation, CreateUserRoleMutationVariables>(CreateUserRoleDocument, baseOptions);
      }
export type CreateUserRoleMutationHookResult = ReturnType<typeof useCreateUserRoleMutation>;
export type CreateUserRoleMutationResult = Apollo.MutationResult<CreateUserRoleMutation>;
export type CreateUserRoleMutationOptions = Apollo.BaseMutationOptions<CreateUserRoleMutation, CreateUserRoleMutationVariables>;
export const UpdateUserRoleDocument = gql`
    mutation UpdateUserRole($id: ID!, $input: UserRoleInput!) {
  updateUserRole(id: $id, input: $input) {
    ...FullUserRole
  }
}
    ${FullUserRoleFragmentDoc}`;
export type UpdateUserRoleMutationFn = Apollo.MutationFunction<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>;

/**
 * __useUpdateUserRoleMutation__
 *
 * To run a mutation, you first call `useUpdateUserRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserRoleMutation, { data, loading, error }] = useUpdateUserRoleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateUserRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>) {
        return Apollo.useMutation<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>(UpdateUserRoleDocument, baseOptions);
      }
export type UpdateUserRoleMutationHookResult = ReturnType<typeof useUpdateUserRoleMutation>;
export type UpdateUserRoleMutationResult = Apollo.MutationResult<UpdateUserRoleMutation>;
export type UpdateUserRoleMutationOptions = Apollo.BaseMutationOptions<UpdateUserRoleMutation, UpdateUserRoleMutationVariables>;
export const DeleteUserRoleDocument = gql`
    mutation DeleteUserRole($id: ID!) {
  deleteUserRole(id: $id)
}
    `;
export type DeleteUserRoleMutationFn = Apollo.MutationFunction<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>;

/**
 * __useDeleteUserRoleMutation__
 *
 * To run a mutation, you first call `useDeleteUserRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserRoleMutation, { data, loading, error }] = useDeleteUserRoleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserRoleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>) {
        return Apollo.useMutation<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>(DeleteUserRoleDocument, baseOptions);
      }
export type DeleteUserRoleMutationHookResult = ReturnType<typeof useDeleteUserRoleMutation>;
export type DeleteUserRoleMutationResult = Apollo.MutationResult<DeleteUserRoleMutation>;
export type DeleteUserRoleMutationOptions = Apollo.BaseMutationOptions<DeleteUserRoleMutation, DeleteUserRoleMutationVariables>;