generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = "mongodb://localhost:27017/wepublish"
}

type MetadataProperty {
  key    String
  value  String
  public Boolean
}

type ArticleRevision {
  preTitle               String?
  title                  String?
  lead                   String?
  seoTitle               String?
  slug                   String?
  tags                   String[]
  canonicalUrl           String?
  properties             MetadataProperty[]
  imageID                String?
  authorIDs              String[]
  breaking               Boolean
  blocks                 Json[]
  hideAuthor             Boolean
  socialMediaTitle       String?
  socialMediaDescription String?
  socialMediaAuthorIDs   String[]
  socialMediaImageID     String?

  revision    Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime? @db.Date //@updatedAt
  publishAt   DateTime? @db.Date
  publishedAt DateTime? @db.Date
}

model Article {
  id         String           @id @default(cuid()) @map("_id")
  createdAt  DateTime         @default(now())
  modifiedAt DateTime         @db.Date //@updatedAt
  published  ArticleRevision?
  pending    ArticleRevision?
  draft      ArticleRevision?
  shared     Boolean

  @@index([createdAt], map: "createdAt_-1")
  @@index([modifiedAt], map: "modifiedAt_-1")
  @@index([published.publishedAt], map: "published.publishedAt_-1")
  @@index([published.updatedAt], map: "published.updatedAt_-1")
  @@index([pending.publishAt], map: "pending.publishAt_-1")
  @@index([draft.tags], map: "draft.tags_1")
  @@index([pending.tags], map: "pending.tags_1")
  @@index([published.tags], map: "published.tags_1")
  @@map("articles")
}

model ArticleHistory {
  id        String            @id @default(cuid()) @map("_id")
  revisions ArticleRevision[]

  @@map("articles.history")
}

type AuthorsLinks {
  title String
  url   String
}

model Author {
  id         String         @id @default(cuid()) @map("_id")
  createdAt  DateTime       @default(now())
  modifiedAt DateTime       @db.Date //@updatedAt
  name       String
  slug       String         @unique(map: "slug_1")
  jobTitle   String?
  imageID    String?
  links      AuthorsLinks[]
  bio        Json[]

  image Image? @relation(fields: [imageID], references: [id])
  @@index([createdAt], map: "createdAt_-1")
  @@index([modifiedAt], map: "modifiedAt_-1")
  @@index([name], map: "name_1")
  @@map("authors")
}

type ImagesFocalPoint {
  x Float
  y Float
}

model Image {
  id          String            @id @default(cuid()) @map("_id")
  createdAt   DateTime          @default(now())
  description String?
  extension   String
  fileSize    Int
  filename    String?
  focalPoint  ImagesFocalPoint?
  format      String
  license     String?
  link        String
  mimeType    String
  modifiedAt  DateTime          @db.Date //@updatedAt
  source      String?
  tags        String[]
  title       String?
  height      Int
  width       Int

  Author      Author[]
  MemberPlan  MemberPlan[]
  PeerProfile PeerProfile[]

  @@index([createdAt], map: "createdAt_-1")
  @@index([modifiedAt], map: "modifiedAt_-1")
  @@index([title], map: "title_1")
  @@index([tags], map: "tags_1")
}

enum CommentItemType {
  article  @map("article")
  page     @map("page")
}

enum CommentRejectionReason {
  misconduct  @map("misconduct")
  spam        @map("spam")
}

type CommentsRevisions {
  text      Json
  createdAt DateTime @default(now())
}

enum CommentState {
  approved            @map("approved")
  pendingApproval     @map("pendingApproval")
  pendingUserChanges  @map("pendingUserChanges")
  rejected            @map("rejected")
}

model Comment {
  id              String                  @id @default(cuid()) @map("_id")
  createdAt       DateTime                @default(now())
  modifiedAt      DateTime                @db.Date // @updatedAt
  userID          String?
  itemID          String
  itemType        CommentItemType
  parentID        String?                 @unique
  revisions       CommentsRevisions[]
  rejectionReason CommentRejectionReason?
  state           CommentState

  user   User?    @relation(fields: [userID], references: [id])
  parent Comment? @relation("CommentRelation", fields: [parentID], references: [id], onDelete: NoAction, onUpdate: NoAction)
  child  Comment? @relation("CommentRelation")
  @@index([createdAt], map: "createdAt_-1")
  @@index([revisions.createdAt], map: "revisions.createdAt_-1")
  @@map("comments")
}

type InvoiceItem {
  createdAt   DateTime @default(now())
  modifiedAt  DateTime @db.Date // @updatedAt
  name        String
  description String?
  quantity    Int
  amount      Int
}

model Invoice {
  id                        String        @id @default(cuid()) @map("_id")
  createdAt                 DateTime      @default(now())
  modifiedAt                DateTime      @db.Date // @updatedAt
  mail                      String
  dueAt                     DateTime      @db.Date
  subscriptionID            String
  description               String?
  paidAt                    DateTime?     @db.Date
  canceledAt                DateTime?     @db.Date
  sentReminderAt            DateTime?     @db.Date
  items                     InvoiceItem[]
  userID                    String?
  manuallySetAsPaidByUserId String?

  subscription Subscription @relation(fields: [subscriptionID], references: [id])
  user         User?        @relation(fields: [userID], references: [id])
  @@map("invoices")
}

enum MailLogState {
  submitted  @map("submitted")
  accepted   @map("accepted")
  delivered  @map("delivered")
  deferred   @map("deferred")
  bounced    @map("bounced")
  rejected   @map("rejecte")
}

model MailLog {
  id             String       @id @default(cuid()) @map("_id")
  createdAt      DateTime     @default(now())
  modifiedAt     DateTime     @db.Date // @updatedAt
  recipient      String
  subject        String
  state          MailLogState
  mailData       String?
  mailProviderID String

  @@index([subject], map: "subject_1")
  @@map("mail.log")
}

enum PaymentPeriodicity {
  monthly    @map("monthly")
  quarterly  @map("quarterly")
  biannual   @map("biannual")
  yearly     @map("yearly")
}

type AvailablePaymentMethod {
  paymentMethodIDs     String[]
  paymentPeriodicities PaymentPeriodicity[]
  forceAutoRenewal     Boolean
}

model MemberPlan {
  id                      String                   @id @default(cuid()) @map("_id")
  createdAt               DateTime                 @default(now())
  modifiedAt              DateTime                 @db.Date // @updatedAt
  name                    String
  slug                    String
  tags                    String[]
  imageID                 String?
  description             Json[]
  active                  Boolean
  amountPerMonthMin       Float
  availablePaymentMethods AvailablePaymentMethod[]

  image        Image?         @relation(fields: [imageID], references: [id])
  Subscription Subscription[]
  @@index([name], map: "name_1")
  @@map("member.plans")
}

model Migration {
  id        String   @id @default(cuid()) @map("_id")
  createdAt DateTime @default(now())
  version   Int      @unique(map: "version_1")

  @@map("migrations")
}

type NavigationLink {
  label     String
  type      String
  url       String?
  pageID    String?
  articleID String?
}

model Navigation {
  id         String           @id @default(cuid()) @map("_id")
  createdAt  DateTime         @default(now())
  modifiedAt DateTime         @db.Date //@updatedAt
  key        String           @unique(map: "key_1")
  links      NavigationLink[]
  name       String

  @@index([createdAt], map: "createdAt_-1")
  @@index([modifiedAt], map: "modifiedAt_-1")
  @@index([name], map: "name_1")
  @@map("navigations")
}

type PageRevision {
  revision               Int
  createdAt              DateTime           @default(now())
  updatedAt              DateTime?          @db.Date //@updatedAt
  publishedAt            DateTime?          @db.Date
  publishAt              DateTime?          @db.Date
  slug                   String
  title                  String
  description            String?
  tags                   String[]
  properties             MetadataProperty[]
  imageID                String?
  socialMediaTitle       String?
  socialMediaDescription String?
  socialMediaImageID     String?
  blocks                 Json[]
}

model Page {
  id         String        @id @default(cuid()) @map("_id")
  createdAt  DateTime      @default(now())
  modifiedAt DateTime      @db.Date //@updatedAt
  published  PageRevision?
  pending    PageRevision?
  draft      PageRevision?

  @@index([createdAt], map: "createdAt_-1")
  @@index([modifiedAt], map: "modifiedAt_-1")
  @@index([published.publishedAt], map: "published.publishedAt_-1")
  @@index([published.updatedAt], map: "published.updatedAt_-1")
  @@index([pending.publishAt], map: "pending.publishAt_-1")
  @@index([draft.tags], map: "draft.tags_1")
  @@index([pending.tags], map: "pending.tags_1")
  @@index([published.tags], map: "published.tags_1")
  @@map("pages")
}

model PaymentMethod {
  id                String   @id @default(cuid()) @map("_id")
  createdAt         DateTime @default(now())
  modifiedAt        DateTime @db.Date //@updatedAt
  name              String
  slug              String
  description       String
  paymentProviderID String
  active            Boolean

  Subscription Subscription[]
  Payment      Payment[]
  @@index([name], map: "name_1")
  @@map("payment.methods")
}

enum PaymentState {
  created             @map("created")
  submitted           @map("submitted")
  requiresUserAction  @map("requiresUserAction")
  processing          @map("processing")
  paid                @map("paid")
  canceled            @map("canceled")
  declined            @map("declined")
}

model Payment {
  id              String       @id @default(cuid()) @map("_id")
  createdAt       DateTime     @default(now())
  modifiedAt      DateTime     @db.Date //@updatedAt
  invoiceID       String
  state           PaymentState
  paymentMethodID String
  intentID        String?
  intentSecret    String?
  intentData      String?
  paymentData     String?

  paymentMethod PaymentMethod @relation(fields: [paymentMethodID], references: [id])
  @@index([intentID], map: "intentID_1")
  @@map("payments")
}

model PeerProfile {
  id                   String  @id @default(cuid()) @map("_id")
  name                 String
  logoID               String?
  themeColor           String
  themeFontColor       String
  callToActionURL      String
  callToActionText     Json[]
  callToActionImageURL String?
  callToActionImageID  String?

  logo Image? @relation(fields: [logoID], references: [id])
  @@map("peerProfiles")
}

model Peer {
  id         String   @id @default(cuid()) @map("_id")
  createdAt  DateTime @default(now())
  modifiedAt DateTime @db.Date //@updatedAt
  name       String
  slug       String   @unique(map: "slug_1")
  hostURL    String
  token      String

  @@map("peers")
}

model Token {
  id         String   @id @default(cuid()) @map("_id")
  createdAt  DateTime @default(now())
  modifiedAt DateTime @db.Date //@updatedAt
  name       String   @unique(map: "name_1")
  token      String
  roleIDs    String[]

  @@map("tokens")
}

model Session {
  id        String   @id @default(cuid()) @map("_id")
  createdAt DateTime @default(now())
  expiresAt DateTime @db.Date
  token     String   @unique(map: "token_1")
  userID    String

  user User @relation(fields: [userID], references: [id])
  @@index([userID], map: "userID_1")
  @@index([expiresAt], map: "expiresAt_1")
  @@map("sessions")
}

type SubscriptionPeriod {
  id                 String
  createdAt          DateTime           @default(now())
  startsAt           DateTime           @db.Date
  endsAt             DateTime           @db.Date
  paymentPeriodicity PaymentPeriodicity
  amount             Float
  invoiceID          String
}

enum SubscriptionDeactivationReason {
  none                 @map("none")
  userSelfDeactivated  @map("userSelfDeactivated")
  invoiceNotPaid       @map("invoiceNotPaid")
}

type SubscriptionDeactivation {
  date   DateTime                       @db.Date
  reason SubscriptionDeactivationReason
}

model Subscription {
  id                 String                    @id @default(cuid()) @map("_id")
  createdAt          DateTime                  @default(now())
  modifiedAt         DateTime                  @db.Date //@updatedAt
  userID             String
  memberPlanID       String
  paymentPeriodicity PaymentPeriodicity
  monthlyAmount      Float
  autoRenew          Boolean
  startsAt           DateTime                  @db.Date
  paidUntil          DateTime?                 @db.Date
  periods            SubscriptionPeriod[]
  paymentMethodID    String
  properties         MetadataProperty[]
  deactivation       SubscriptionDeactivation?

  paymentMethod PaymentMethod @relation(fields: [paymentMethodID], references: [id])
  memberPlan    MemberPlan    @relation(fields: [memberPlanID], references: [id])
  user          User          @relation(fields: [userID], references: [id])
  Invoice       Invoice[]
  @@map("subscriptions")
}

type UserAddress {
  company        String?
  streetAddress  String
  streetAddress2 String?
  zipCode        String
  city           String
  country        String
}

type UserOAuth2Account {
  type              String
  provider          String
  providerAccountId String
  refreshToken      String?
  accessToken       String
  expiresAt         Int
  tokenType         String
  scope             String
  idToken           String
  oauthTokenSecret  String?
  oauthToken        String?
  sessionState      String?
}

type PaymentProviderCustomer {
  paymentProviderID String
  customerID        String
}

model User {
  id                       String                    @id @default(cuid()) @map("_id")
  createdAt                DateTime                  @default(now())
  modifiedAt               DateTime                  @db.Date //@updatedAt
  email                    String                    @unique(map: "email_1")
  emailVerifiedAt          DateTime?                 @db.Date
  name                     String
  firstName                String?
  preferredName            String?
  address                  UserAddress?
  password                 String
  oauth2Accounts           UserOAuth2Account[]
  active                   Boolean
  lastLogin                DateTime?                 @db.Date
  properties               MetadataProperty[]
  roleIDs                  String[]
  paymentProviderCustomers PaymentProviderCustomer[]

  Comment      Comment[]
  Session      Session[]
  Subscription Subscription[]
  Invoice      Invoice[]
  @@map("users")
}

model UserRole {
  id            String   @id @map("_id")
  createdAt     DateTime @default(now())
  modifiedAt    DateTime @db.Date //@updatedAt
  description   String?
  name          String   @unique(map: "name_1")
  permissionIDs String[]
  systemRole    Boolean

  @@map("users.roles")
}
