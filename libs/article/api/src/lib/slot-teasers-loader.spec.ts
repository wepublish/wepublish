import { Test, TestingModule } from '@nestjs/testing';
import {
  SlotTeasersLoader,
  BlockType,
  BaseBlock,
  TeaserType,
  BlockWithAlignment,
  FlexBlock,
  TeaserSlotType,
  isFlexBlock,
  isTeaserSlotsBlock,
  Teaser,
} from '@wepublish/block-content/api';
import { EventService } from '@wepublish/event/api';
import { ArticleService } from './article.service';
import { ArticleTeaser, TeaserSlotsBlock } from '@wepublish/website/api';
import nanoid from 'nanoid';

/*
 *
 *
 *
 *  TESTS FOR SLOT TEASERS LOADER
 *  lib/block-content/api/src/lib/teaser/slot-teasers-loader.ts
 *
 *  block-content-api project had to be ingored in ./nxignore because of
 *  circular dependency issues therefore these tests are located in article-api project.
 *
 *
 */

// make sure ids generated by nanoid are predictable for testing purposes
jest.mock('nanoid', () => {
  let counter = -1;
  return () => {
    counter++;
    return `mock_nanoid_${counter}`;
  };
});

const mockFlexBlock = ({
  blockStyle = undefined,
  blocks = [] as BlockWithAlignment[],
} = {}) =>
  ({
    type: BlockType.FlexBlock,
    blockStyle,
    blocks,
  }) as unknown as FlexBlock;

const mockTeaserSlotsBlock = () => {
  return {
    autofillConfig: {
      __typename: 'TeaserSlotsBlockAutofillConfig',
      tagIds: [],
      enabled: true,
      numberOfTeasers: 8,
      sort: null,
      teaserType: 'article' as TeaserType.Article, // explicit lowercase string to match enum value
      filter: {
        __typename: 'TeaserListBlockFilter',
        tags: ['test-tag-id'],
        tagObjects: [
          {
            __typename: 'Tag',
            id: nanoid(),
            tag: `lorem-ipsum`,
          },
        ],
      },
    },
    slots: [
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
    ],
    type: BlockType.TeaserSlots,
  } as unknown as BaseBlock<BlockType>;
};

const mockTeaserSlotsBlockWithManualTeaser = () => {
  return {
    autofillConfig: {
      __typename: 'TeaserSlotsBlockAutofillConfig',
      tagIds: [],
      enabled: true,
      numberOfTeasers: 1,
      sort: null,
      teaserType: 'article' as TeaserType.Article, // explicit lowercase string to match enum value
      filter: {
        __typename: 'TeaserListBlockFilter',
        tags: ['test-tag-id'],
        tagObjects: [
          {
            __typename: 'Tag',
            id: nanoid(),
            tag: `lorem-ipsum`,
          },
        ],
      },
    },
    slots: [
      {
        type: TeaserSlotType.Manual,
        teaser: {
          type: TeaserType.Article,
          articleID: 'article_pool_100',
        } as unknown as typeof Teaser,
      },
      {
        type: TeaserSlotType.Autofill,
      },
    ],
    type: BlockType.TeaserSlots,
  } as unknown as BaseBlock<BlockType>;
};

const mockBlockWithAlignment = ({
  alignment = {
    i: nanoid(),
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    static: false,
  },
  block = mockTeaserSlotsBlock() as unknown as BaseBlock<BlockType>,
} = {}): BlockWithAlignment =>
  ({
    alignment,
    block,
  }) as unknown as BlockWithAlignment;

type TeaserWithAlignment = {
  alignment: {
    i: string;
    x: number;
    y: number;
    w: number;
    h: number;
    static: boolean;
  };
  teaser: BaseBlock<BlockType>;
};

const mockTeaserWithAlignment = ({
  alignment = {
    i: nanoid(),
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    static: false,
  },
  teaser = mockTeaserSlotsBlock() as unknown as BaseBlock<BlockType>,
} = {}): TeaserWithAlignment =>
  ({
    alignment,
    teaser,
  }) as unknown as TeaserWithAlignment;

const mockTeaserGridFlexBlock = ({
  blockStyle = undefined,
  flexTeasers = [] as TeaserWithAlignment[],
} = {}) =>
  ({
    type: BlockType.TeaserGridFlex,
    blockStyle,
    flexTeasers,
  }) as unknown as FlexBlock;

const mockArticleTeaser = ({ articleID = 'mock_article_id' } = {}) =>
  ({
    type: TeaserType.Article,
    articleID,
  }) as unknown as ArticleTeaser;

const revisionBlocks: BaseBlock<BlockType>[] = [
  mockFlexBlock({
    blocks: [
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlockWithManualTeaser() }),
    ],
  }),
  mockTeaserSlotsBlock() as unknown as BaseBlock<BlockType>,
  // teasers in grid-flex-block must not be repeated in teaser-slots-blocks
  mockTeaserGridFlexBlock({
    flexTeasers: [
      mockTeaserWithAlignment({
        teaser: mockArticleTeaser({
          articleID: 'article_pool_66',
        }) as unknown as BaseBlock<BlockType>,
      }),
      mockTeaserWithAlignment({
        teaser: mockArticleTeaser({
          articleID: 'article_pool_67',
        }) as unknown as BaseBlock<BlockType>,
      }),
    ],
  }) as unknown as BaseBlock<BlockType>,
  mockFlexBlock({
    blocks: [
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
      mockBlockWithAlignment({ block: mockTeaserSlotsBlock() }),
    ],
  }),
];

const mockEventService = {
  getEvents: jest.fn().mockResolvedValue({ nodes: [] }),
};

// simulate database with a fixed pool of articles
const ARTICLE_POOL = Array.from({ length: 150 }, (_, i) => ({
  id: `article_pool_${i + 1}`,
  title: `Article ${i + 1}`,
}));

const mockArticleService = {
  getArticles: jest.fn().mockImplementation(async ({ take, filter }) => {
    const excludedIds = filter?.excludeIds || [];

    // simulate async database delay with random timing to expose race conditions while loading teasers
    await new Promise(resolve => setTimeout(resolve, Math.random() * 50));

    // simulate database: return articles from pool that are NOT in excludeIds
    const availableArticles = ARTICLE_POOL.filter(
      a => !excludedIds.includes(a.id)
    );
    const articles = availableArticles.slice(0, take);

    return { nodes: articles };
  }),
};

describe('SlotTeasersLoader', () => {
  let service: SlotTeasersLoader;

  beforeEach(async () => {
    jest.clearAllMocks();
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SlotTeasersLoader,
        { provide: EventService, useValue: mockEventService },
        { provide: ArticleService, useValue: mockArticleService },
      ],
    }).compile();

    service = await module.resolve<SlotTeasersLoader>(SlotTeasersLoader);
  });

  const extractTeasers = (block: TeaserSlotsBlock): string[] => {
    const teaserIds: string[] = [];
    for (const t of block.teasers) {
      if (t && t.type === TeaserType.Article) {
        const teaser = t as ArticleTeaser;
        const id = teaser.article?.id || teaser.articleID;
        if (id) {
          teaserIds.push(id);
        }
      }
    }
    return teaserIds;
  };

  const processBlock = (block: BaseBlock<BlockType>) => {
    if (isFlexBlock(block)) {
      const teaserIds: string[] = [];
      for (const nestedBlock of (block as FlexBlock).blocks) {
        teaserIds.push(
          ...processBlock(
            (nestedBlock as BlockWithAlignment).block as BaseBlock<BlockType>
          )
        );
      }
      return teaserIds;
    }

    if (isTeaserSlotsBlock(block)) {
      return extractTeasers(block as unknown as TeaserSlotsBlock);
    }

    return [];
  };

  it('should return unique teasers', async () => {
    const result = await service.loadSlotTeasersIntoBlocks(revisionBlocks);
    const shouldBeUniqueTeaserIds: string[] = [];

    for (const block of result as BaseBlock<BlockType>[]) {
      shouldBeUniqueTeaserIds.push(...processBlock(block));
    }

    //console.log('shouldBeUniqueTeaserIds:', shouldBeUniqueTeaserIds);

    const unique = (x: string, i: number, arr: string[]) =>
      arr.indexOf(x) === i;

    const naturalSortAsc = (a: string, b: string) =>
      ('' + a).localeCompare(b, undefined, {
        numeric: true,
        sensitivity: 'base',
      });

    const filteredTeaserIds = shouldBeUniqueTeaserIds.filter(unique);
    const sortedTeaserIds = [...shouldBeUniqueTeaserIds].sort(naturalSortAsc);
    // in the sorted array, move id of manually added teaser (id 'article_pool_100')...
    // ...to its expected position (after 'article_pool_56')
    const manualTeaserId = 'article_pool_100';
    const indexOfManualTeaser = sortedTeaserIds.indexOf(manualTeaserId);
    if (indexOfManualTeaser > -1) {
      sortedTeaserIds.splice(indexOfManualTeaser, 1);
      const expectedIndex = shouldBeUniqueTeaserIds.indexOf(manualTeaserId);
      sortedTeaserIds.splice(expectedIndex, 0, manualTeaserId);
    }

    const hasItem66 = shouldBeUniqueTeaserIds.some(
      item => item === 'article_pool_66'
    );
    const hasItem67 = shouldBeUniqueTeaserIds.some(
      item => item === 'article_pool_67'
    );

    // teasers from grid-flex-block should not be repeated in autofilled teaser-slots-blocks
    expect(hasItem66).toBe(false);
    expect(hasItem67).toBe(false);

    //      1 teaser-slots-block x 8 slots --> 8 teasers
    // +    1 flex-blocks
    // +      7 teaser-slots-blocks x 8 slots --> 56 teasers
    // +      1 teaser-slots-blocks x (1 manual slot + 1 autofill slot) --> 2 teasers
    // +    1 flex-blocks x 7 teaser-slots-blocks x 8 slots --> 56 teasers
    // --------------------------------------------------------
    // =  122 teasers expected
    //
    expect(shouldBeUniqueTeaserIds.length).toEqual(122);

    // teaser ids should be in the order they were loaded into blocks
    expect(sortedTeaserIds.join(',')).toEqual(
      shouldBeUniqueTeaserIds.join(',')
    );

    // all ids should be unique
    expect(filteredTeaserIds).toEqual(shouldBeUniqueTeaserIds);

    // snapshot test the full structure
    expect(result).toMatchSnapshot();
  });
});
