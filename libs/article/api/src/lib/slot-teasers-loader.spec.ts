import { Test, TestingModule } from '@nestjs/testing';
import {
  SlotTeasersLoader,
  BlockType,
  BaseBlock,
  TeaserType,
  BlockWithAlignment,
  FlexBlock,
  TeaserSlotType,
} from '@wepublish/block-content/api';
import { EventService } from '@wepublish/event/api';
import { ArticleService } from './article.service';
import { ArticleTeaser, TeaserSlotsBlock } from '@wepublish/website/api';
import nanoid from 'nanoid';

/*
 *
 *
 *
 *  TESTS FOR SLOT TEASERS LOADER
 *  lib/block-content/api/src/lib/teaser/slot-teasers-loader.ts
 *
 *  block-content-api project had to be ingored in ./nxignore because of
 *  circular dependency issues therefore these tests are located in article-api project.
 *
 *
 */

// make sure ids generated by nanoid are predictable for testing purposes
jest.mock('nanoid', () => {
  let counter = -1;
  return () => {
    counter++;
    return `mock_nanoid_${counter}`;
  };
});

const mockFlexBock = ({
  blockStyle = undefined,
  blocks = [] as BlockWithAlignment[],
} = {}) =>
  ({
    type: BlockType.FlexBlock,
    blockStyle,
    blocks,
  }) as unknown as FlexBlock;

const mockTeaserSlotsBlock = () => {
  return {
    autofillConfig: {
      __typename: 'TeaserSlotsBlockAutofillConfig',
      tagIds: [],
      enabled: true,
      numberOfTeasers: 8,
      sort: null,
      teaserType: 'article' as TeaserType.Article, // explicit lowercase string to match enum value
      filter: {
        __typename: 'TeaserListBlockFilter',
        tags: ['test-tag-id'],
        tagObjects: [
          {
            __typename: 'Tag',
            id: nanoid(),
            tag: `lorem-ipsum`,
          },
        ],
      },
    },
    slots: [
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
      {
        type: TeaserSlotType.Autofill,
      },
    ],
    type: BlockType.TeaserSlots,
  } as unknown as TeaserSlotsBlock;
};

const mockNestedBlock = ({
  alignment = {
    i: nanoid(),
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    static: false,
  },
  block = mockTeaserSlotsBlock(),
} = {}) =>
  ({
    alignment,
    block,
  }) as unknown as BlockWithAlignment;

const revisionBlocks: BaseBlock<BlockType>[] = [
  mockFlexBock({
    blocks: [
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
    ],
  }),
  mockFlexBock({
    blocks: [
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
      mockNestedBlock({ block: mockTeaserSlotsBlock() }),
    ],
  }),
];

const mockEventService = {
  getEvents: jest.fn().mockResolvedValue({ nodes: [] }),
};

// simulate database with a fixed pool of articles
const ARTICLE_POOL = Array.from({ length: 100 }, (_, i) => ({
  id: `article_pool_${i + 1}`,
  title: `Article ${i + 1}`,
}));

const mockArticleService = {
  getArticles: jest.fn().mockImplementation(async ({ take, filter }) => {
    const excludedIds = filter?.excludeIds || [];

    // simulate async database delay with random timing to expose race conditions while loading teasers
    await new Promise(resolve => setTimeout(resolve, Math.random() * 50));

    // simulate database: return articles from pool that are NOT in excludeIds
    const availableArticles = ARTICLE_POOL.filter(
      a => !excludedIds.includes(a.id)
    );
    const articles = availableArticles.slice(0, take);

    return { nodes: articles };
  }),
};

describe('SlotTeasersLoader', () => {
  let service: SlotTeasersLoader;

  beforeEach(async () => {
    jest.clearAllMocks();
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SlotTeasersLoader,
        { provide: EventService, useValue: mockEventService },
        { provide: ArticleService, useValue: mockArticleService },
      ],
    }).compile();

    service = await module.resolve<SlotTeasersLoader>(SlotTeasersLoader);
  });

  it('should return unique teasers', async () => {
    const result = await service.loadSlotTeasersIntoBlocks(revisionBlocks);

    const fB = result[0] as unknown as FlexBlock;
    const shouldBeUniqueTeaserIds: string[] = [];
    for (const nestedBlock of fB.blocks) {
      const block = (nestedBlock as BlockWithAlignment)
        .block as TeaserSlotsBlock;

      for (const t of block.teasers) {
        if (t && t.type === TeaserType.Article) {
          const teaser = t as ArticleTeaser;
          const id = teaser.article?.id || teaser.articleID;
          if (id) {
            shouldBeUniqueTeaserIds.push(id);
          }
        }
      }
    }

    // console.log('shouldBeUniqueTeaserIds:', shouldBeUniqueTeaserIds);

    const unique = (x: string, i: number, arr: string[]) =>
      arr.indexOf(x) === i;

    const naturalSortAsc = (a: string, b: string) =>
      ('' + a).localeCompare(b, undefined, {
        numeric: true,
        sensitivity: 'base',
      });

    const filteredTeaserIds = shouldBeUniqueTeaserIds.filter(unique);
    const sortedTeaserIds = [...shouldBeUniqueTeaserIds].sort(naturalSortAsc);

    expect(filteredTeaserIds.length).toEqual(56); // 7 teaser-slots-blocks x 8 slots = 56 teasers expected
    expect(sortedTeaserIds.join(',')).toEqual(
      shouldBeUniqueTeaserIds.join(',')
    ); // teaser ids should be in ascending order
    expect(filteredTeaserIds).toEqual(shouldBeUniqueTeaserIds); // all ids should be unique
    expect(result).toMatchSnapshot(); // snapshot test the full structure
  });
});
