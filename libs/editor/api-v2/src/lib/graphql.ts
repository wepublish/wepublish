// THIS FILE IS AUTOGENERATED
import {Node} from 'slate'
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: string;
};

export type Consent = {
  __typename?: 'Consent';
  createdAt: Scalars['DateTime'];
  defaultValue: Scalars['Boolean'];
  id: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['String'];
};

export type ConsentFilter = {
  defaultValue?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
};

export type ConsentInput = {
  defaultValue: Scalars['Boolean'];
  name: Scalars['String'];
  slug: Scalars['String'];
};

export type DashboardInvoice = {
  __typename?: 'DashboardInvoice';
  amount: Scalars['Int'];
  dueAt: Scalars['DateTime'];
  memberPlan?: Maybe<Scalars['String']>;
  paidAt?: Maybe<Scalars['DateTime']>;
};

export type DashboardSubscription = {
  __typename?: 'DashboardSubscription';
  deactivationDate?: Maybe<Scalars['DateTime']>;
  endsAt?: Maybe<Scalars['DateTime']>;
  memberPlan: Scalars['String'];
  monthlyAmount: Scalars['Int'];
  paymentPeriodicity: PaymentPeriodicity;
  reasonForDeactivation?: Maybe<SubscriptionDeactivationReason>;
  renewsAt?: Maybe<Scalars['DateTime']>;
  startsAt: Scalars['DateTime'];
};

export type MailProviderModel = {
  __typename?: 'MailProviderModel';
  name: Scalars['String'];
};

export type MailTemplateRef = {
  __typename?: 'MailTemplateRef';
  id: Scalars['String'];
  name: Scalars['String'];
};

export type MailTemplateWithUrlAndStatusModel = {
  __typename?: 'MailTemplateWithUrlAndStatusModel';
  description?: Maybe<Scalars['String']>;
  externalMailTemplateId: Scalars['String'];
  id: Scalars['String'];
  name: Scalars['String'];
  remoteMissing: Scalars['Boolean'];
  status: Scalars['String'];
  url: Scalars['String'];
};

export type MemberPlanRef = {
  __typename?: 'MemberPlanRef';
  id: Scalars['String'];
  name: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Create a new consent. */
  createConsent: Consent;
  createSubscriptionFlow: Array<SubscriptionFlowModel>;
  createSubscriptionInterval: Array<SubscriptionFlowModel>;
  /**
   * Creates a new userConsent based on input.
   * Returns created userConsent.
   */
  createUserConsent: UserConsent;
  /** Deletes an existing consent. */
  deleteConsent: Consent;
  deleteSubscriptionFlow: Array<SubscriptionFlowModel>;
  deleteSubscriptionInterval: Array<SubscriptionFlowModel>;
  /**
   * Delete an existing userConsent by id.
   * Returns deleted userConsent.
   */
  deleteUserConsent: UserConsent;
  syncTemplates?: Maybe<Scalars['Boolean']>;
  testSystemMail: Array<SystemMailModel>;
  /** Updates an existing consent. */
  updateConsent: Consent;
  updateSubscriptionFlow: Array<SubscriptionFlowModel>;
  updateSubscriptionInterval: Array<SubscriptionFlowModel>;
  updateSubscriptionIntervals: Array<SubscriptionFlowModel>;
  updateSystemMail: Array<SystemMailModel>;
  /**
   * Updates an existing userConsent based on input.
   * Returns updated userConsent.
   */
  updateUserConsent: UserConsent;
};


export type MutationCreateConsentArgs = {
  consent: ConsentInput;
};


export type MutationCreateSubscriptionFlowArgs = {
  subscriptionFlow: SubscriptionFlowModelCreateInput;
};


export type MutationCreateSubscriptionIntervalArgs = {
  subscriptionInterval: SubscriptionIntervalCreateInput;
};


export type MutationCreateUserConsentArgs = {
  userConsent: UserConsentInput;
};


export type MutationDeleteConsentArgs = {
  id: Scalars['String'];
};


export type MutationDeleteSubscriptionFlowArgs = {
  subscriptionFlowId: Scalars['String'];
};


export type MutationDeleteSubscriptionIntervalArgs = {
  subscriptionInterval: SubscriptionIntervalDeleteInput;
};


export type MutationDeleteUserConsentArgs = {
  id: Scalars['String'];
};


export type MutationTestSystemMailArgs = {
  systemMail: SystemMailTestInput;
};


export type MutationUpdateConsentArgs = {
  consent: ConsentInput;
  id: Scalars['String'];
};


export type MutationUpdateSubscriptionFlowArgs = {
  subscriptionFlow: SubscriptionFlowModelUpdateInput;
};


export type MutationUpdateSubscriptionIntervalArgs = {
  subscriptionInterval: SubscriptionIntervalUpdateInput;
};


export type MutationUpdateSubscriptionIntervalsArgs = {
  subscriptionIntervals: Array<SubscriptionIntervalUpdateInput>;
};


export type MutationUpdateSystemMailArgs = {
  systemMail: SystemMailUpdateInput;
};


export type MutationUpdateUserConsentArgs = {
  id: Scalars['String'];
  userConsent: UpdateUserConsentInput;
};

export type PaymentMethodRef = {
  __typename?: 'PaymentMethodRef';
  id: Scalars['String'];
  name: Scalars['String'];
};

export enum PaymentPeriodicity {
  Biannual = 'biannual',
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Yearly = 'yearly'
}

export type Query = {
  __typename?: 'Query';
  /**
   * Returns all active subscribers.
   * Includes subscribers with a cancelled but not run out subscription.
   */
  activeSubscribers: Array<DashboardSubscription>;
  /** Returns a consent by id. */
  consent: Consent;
  /** Returns all consents. */
  consents: Array<Consent>;
  /**
   * Returns the expected revenue for the time period given.
   * Excludes cancelled or manually set as paid invoices.
   */
  expectedRevenue: Array<DashboardInvoice>;
  getSystemMails: Array<SystemMailModel>;
  mailTemplates: Array<MailTemplateWithUrlAndStatusModel>;
  /**
   * Returns all new deactivations in a given timeframe.
   * This considers the time the deactivation was made, not when the subscription runs out.
   */
  newDeactivations: Array<DashboardSubscription>;
  /**
   * Returns all new subscribers in a given timeframe.
   * Includes already deactivated ones.
   */
  newSubscribers: Array<DashboardSubscription>;
  paymentMethods: Array<PaymentMethodRef>;
  provider: MailProviderModel;
  /** Returns all renewing subscribers in a given timeframe. */
  renewingSubscribers: Array<DashboardSubscription>;
  /**
   * Returns the revenue generated for the time period given.
   * Only includes paid invoices that have not been manually paid.
   */
  revenue: Array<DashboardInvoice>;
  subscriptionFlows: Array<SubscriptionFlowModel>;
  /** Returns a single userConsent by id. */
  userConsent: UserConsent;
  /** Returns a list of userConsents. Possible to filter. */
  userConsents: Array<UserConsent>;
  versionInformation: VersionInformation;
};


export type QueryConsentArgs = {
  id: Scalars['String'];
};


export type QueryConsentsArgs = {
  filter?: InputMaybe<ConsentFilter>;
};


export type QueryExpectedRevenueArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryNewDeactivationsArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryNewSubscribersArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryRenewingSubscribersArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryRevenueArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QuerySubscriptionFlowsArgs = {
  defaultFlowOnly: Scalars['Boolean'];
  memberPlanId?: InputMaybe<Scalars['String']>;
};


export type QueryUserConsentArgs = {
  id: Scalars['String'];
};


export type QueryUserConsentsArgs = {
  filter?: InputMaybe<UserConsentFilter>;
};

export enum SubscriptionDeactivationReason {
  InvoiceNotPaid = 'invoiceNotPaid',
  None = 'none',
  UserSelfDeactivated = 'userSelfDeactivated'
}

export enum SubscriptionEvent {
  Custom = 'CUSTOM',
  DeactivationByUser = 'DEACTIVATION_BY_USER',
  DeactivationUnpaid = 'DEACTIVATION_UNPAID',
  InvoiceCreation = 'INVOICE_CREATION',
  RenewalFailed = 'RENEWAL_FAILED',
  RenewalSuccess = 'RENEWAL_SUCCESS',
  Subscribe = 'SUBSCRIBE'
}

export type SubscriptionFlowModel = {
  __typename?: 'SubscriptionFlowModel';
  autoRenewal: Array<Scalars['Boolean']>;
  default: Scalars['Boolean'];
  id: Scalars['String'];
  intervals: Array<SubscriptionInterval>;
  memberPlan?: Maybe<MemberPlanRef>;
  numberOfSubscriptions: Scalars['Int'];
  paymentMethods: Array<PaymentMethodRef>;
  periodicities: Array<PaymentPeriodicity>;
};

export type SubscriptionFlowModelCreateInput = {
  autoRenewal: Array<Scalars['Boolean']>;
  memberPlanId: Scalars['String'];
  paymentMethodIds: Array<Scalars['String']>;
  periodicities: Array<PaymentPeriodicity>;
};

export type SubscriptionFlowModelUpdateInput = {
  autoRenewal: Array<Scalars['Boolean']>;
  id: Scalars['String'];
  paymentMethodIds: Array<Scalars['String']>;
  periodicities: Array<PaymentPeriodicity>;
};

export type SubscriptionInterval = {
  __typename?: 'SubscriptionInterval';
  daysAwayFromEnding?: Maybe<Scalars['Int']>;
  event: SubscriptionEvent;
  id: Scalars['String'];
  mailTemplate?: Maybe<MailTemplateRef>;
};

export type SubscriptionIntervalCreateInput = {
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  event: SubscriptionEvent;
  mailTemplateId?: InputMaybe<Scalars['String']>;
  subscriptionFlowId: Scalars['String'];
};

export type SubscriptionIntervalDeleteInput = {
  id: Scalars['String'];
};

export type SubscriptionIntervalUpdateInput = {
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  id: Scalars['String'];
  mailTemplateId?: InputMaybe<Scalars['String']>;
};

export type SystemMailModel = {
  __typename?: 'SystemMailModel';
  event: UserEvent;
  mailTemplate?: Maybe<MailTemplateRef>;
};

export type SystemMailTestInput = {
  event: UserEvent;
};

export type SystemMailUpdateInput = {
  event: UserEvent;
  mailTemplateId: Scalars['String'];
};

export type UpdateUserConsentInput = {
  value: Scalars['Boolean'];
};

export type User = {
  __typename?: 'User';
  active: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  email: Scalars['String'];
  emailVerifiedAt?: Maybe<Scalars['DateTime']>;
  firstName?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  lastLogin?: Maybe<Scalars['DateTime']>;
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  password: Scalars['String'];
  preferredName?: Maybe<Scalars['String']>;
  roleIDs: Array<Scalars['String']>;
  userImageID?: Maybe<Scalars['String']>;
};

export type UserConsent = {
  __typename?: 'UserConsent';
  consent: Consent;
  createdAt: Scalars['DateTime'];
  id: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  user: User;
  value: Scalars['Boolean'];
};

export type UserConsentFilter = {
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['Boolean']>;
};

export type UserConsentInput = {
  consentId: Scalars['String'];
  userId: Scalars['String'];
  value: Scalars['Boolean'];
};

export enum UserEvent {
  AccountCreation = 'ACCOUNT_CREATION',
  LoginLink = 'LOGIN_LINK',
  PasswordReset = 'PASSWORD_RESET',
  TestMail = 'TEST_MAIL'
}

export type VersionInformation = {
  __typename?: 'VersionInformation';
  version: Scalars['String'];
};

export type ConsentsQueryVariables = Exact<{ [key: string]: never; }>;


export type ConsentsQuery = { __typename?: 'Query', consents: Array<{ __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }> };

export type ConsentQueryVariables = Exact<{
  id: Scalars['String'];
}>;


export type ConsentQuery = { __typename?: 'Query', consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string } };

export type CreateConsentMutationVariables = Exact<{
  consent: ConsentInput;
}>;


export type CreateConsentMutation = { __typename?: 'Mutation', createConsent: { __typename?: 'Consent', id: string, createdAt: string, modifiedAt: string, name: string, slug: string, defaultValue: boolean } };

export type UpdateConsentMutationVariables = Exact<{
  id: Scalars['String'];
  consent: ConsentInput;
}>;


export type UpdateConsentMutation = { __typename?: 'Mutation', updateConsent: { __typename?: 'Consent', id: string, createdAt: string, modifiedAt: string, name: string, slug: string, defaultValue: boolean } };

export type DeleteConsentMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteConsentMutation = { __typename?: 'Mutation', deleteConsent: { __typename?: 'Consent', id: string } };

export type UserConsentsQueryVariables = Exact<{ [key: string]: never; }>;


export type UserConsentsQuery = { __typename?: 'Query', userConsents: Array<{ __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', slug: string, id: string, name: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } }> };

export type UserConsentQueryVariables = Exact<{
  id: Scalars['String'];
}>;


export type UserConsentQuery = { __typename?: 'Query', userConsent: { __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', slug: string, id: string, name: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } } };

export type CreateUserConsentMutationVariables = Exact<{
  userConsent: UserConsentInput;
}>;


export type CreateUserConsentMutation = { __typename?: 'Mutation', createUserConsent: { __typename?: 'UserConsent', id: string, value: boolean } };

export type UpdateUserConsentMutationVariables = Exact<{
  id: Scalars['String'];
  userConsent: UpdateUserConsentInput;
}>;


export type UpdateUserConsentMutation = { __typename?: 'Mutation', updateUserConsent: { __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', slug: string, id: string, name: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } } };

export type DeleteUserConsentMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteUserConsentMutation = { __typename?: 'Mutation', deleteUserConsent: { __typename?: 'UserConsent', id: string } };

export type MailTemplateQueryVariables = Exact<{ [key: string]: never; }>;


export type MailTemplateQuery = { __typename?: 'Query', mailTemplates: Array<{ __typename?: 'MailTemplateWithUrlAndStatusModel', id: string, name: string, description?: string | null, externalMailTemplateId: string, remoteMissing: boolean, url: string, status: string }>, provider: { __typename?: 'MailProviderModel', name: string } };

export type SynchronizeMailTemplatesMutationVariables = Exact<{ [key: string]: never; }>;


export type SynchronizeMailTemplatesMutation = { __typename?: 'Mutation', syncTemplates?: boolean | null };

export type FullMailTemplateFragment = { __typename?: 'MailTemplateWithUrlAndStatusModel', id: string, name: string, description?: string | null, externalMailTemplateId: string, remoteMissing: boolean, url: string, status: string };

export type FullMailProviderFragment = { __typename?: 'MailProviderModel', name: string };

export type SubscriptionFlowsQueryVariables = Exact<{
  defaultFlowOnly: Scalars['Boolean'];
  memberPlanId?: InputMaybe<Scalars['String']>;
}>;


export type SubscriptionFlowsQuery = { __typename?: 'Query', subscriptionFlows: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type CreateSubscriptionFlowMutationVariables = Exact<{
  subscriptionFlow: SubscriptionFlowModelCreateInput;
}>;


export type CreateSubscriptionFlowMutation = { __typename?: 'Mutation', createSubscriptionFlow: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type UpdateSubscriptionFlowMutationVariables = Exact<{
  subscriptionFlow: SubscriptionFlowModelUpdateInput;
}>;


export type UpdateSubscriptionFlowMutation = { __typename?: 'Mutation', updateSubscriptionFlow: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type DeleteSubscriptionFlowMutationVariables = Exact<{
  subscriptionFlowId: Scalars['String'];
}>;


export type DeleteSubscriptionFlowMutation = { __typename?: 'Mutation', deleteSubscriptionFlow: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type CreateSubscriptionIntervalMutationVariables = Exact<{
  subscriptionInterval: SubscriptionIntervalCreateInput;
}>;


export type CreateSubscriptionIntervalMutation = { __typename?: 'Mutation', createSubscriptionInterval: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type UpdateSubscriptionIntervalsMutationVariables = Exact<{
  subscriptionIntervals: Array<SubscriptionIntervalUpdateInput> | SubscriptionIntervalUpdateInput;
}>;


export type UpdateSubscriptionIntervalsMutation = { __typename?: 'Mutation', updateSubscriptionIntervals: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type UpdateSubscriptionIntervalMutationVariables = Exact<{
  subscriptionInterval: SubscriptionIntervalUpdateInput;
}>;


export type UpdateSubscriptionIntervalMutation = { __typename?: 'Mutation', updateSubscriptionInterval: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type DeleteSubscriptionIntervalMutationVariables = Exact<{
  subscriptionInterval: SubscriptionIntervalDeleteInput;
}>;


export type DeleteSubscriptionIntervalMutation = { __typename?: 'Mutation', deleteSubscriptionInterval: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type ListPaymentMethodsQueryVariables = Exact<{ [key: string]: never; }>;


export type ListPaymentMethodsQuery = { __typename?: 'Query', paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }> };

export type SubscriptionFlowFragment = { __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlanRef', id: string, name: string } | null, paymentMethods: Array<{ __typename?: 'PaymentMethodRef', id: string, name: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> };

export type SubscriptionIntervalFragment = { __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null };

export type MailTemplateRefFragment = { __typename?: 'MailTemplateRef', id: string, name: string };

export type MemberPlanRefFragment = { __typename?: 'MemberPlanRef', id: string, name: string };

export type PaymentMethodRefFragment = { __typename?: 'PaymentMethodRef', id: string, name: string };

export type GetSystemMailsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSystemMailsQuery = { __typename?: 'Query', getSystemMails: Array<{ __typename?: 'SystemMailModel', event: UserEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> };

export type UpdateSystemMailMutationVariables = Exact<{
  systemMail: SystemMailUpdateInput;
}>;


export type UpdateSystemMailMutation = { __typename?: 'Mutation', updateSystemMail: Array<{ __typename?: 'SystemMailModel', event: UserEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> };

export type TestSystemMailMutationVariables = Exact<{
  systemMail: SystemMailTestInput;
}>;


export type TestSystemMailMutation = { __typename?: 'Mutation', testSystemMail: Array<{ __typename?: 'SystemMailModel', event: UserEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> };

export type SystemMailFragment = { __typename?: 'SystemMailModel', event: UserEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null };

export type VersionInformationQueryVariables = Exact<{ [key: string]: never; }>;


export type VersionInformationQuery = { __typename?: 'Query', versionInformation: { __typename?: 'VersionInformation', version: string } };

export const FullMailTemplateFragmentDoc = gql`
    fragment fullMailTemplate on MailTemplateWithUrlAndStatusModel {
  id
  name
  description
  externalMailTemplateId
  remoteMissing
  url
  status
}
    `;
export const FullMailProviderFragmentDoc = gql`
    fragment fullMailProvider on MailProviderModel {
  name
}
    `;
export const MemberPlanRefFragmentDoc = gql`
    fragment MemberPlanRef on MemberPlanRef {
  id
  name
}
    `;
export const PaymentMethodRefFragmentDoc = gql`
    fragment PaymentMethodRef on PaymentMethodRef {
  id
  name
}
    `;
export const MailTemplateRefFragmentDoc = gql`
    fragment MailTemplateRef on MailTemplateRef {
  id
  name
}
    `;
export const SubscriptionIntervalFragmentDoc = gql`
    fragment SubscriptionInterval on SubscriptionInterval {
  id
  daysAwayFromEnding
  event
  mailTemplate {
    ...MailTemplateRef
  }
}
    ${MailTemplateRefFragmentDoc}`;
export const SubscriptionFlowFragmentDoc = gql`
    fragment SubscriptionFlow on SubscriptionFlowModel {
  id
  default
  memberPlan {
    ...MemberPlanRef
  }
  autoRenewal
  paymentMethods {
    ...PaymentMethodRef
  }
  periodicities
  intervals {
    ...SubscriptionInterval
  }
  numberOfSubscriptions
}
    ${MemberPlanRefFragmentDoc}
${PaymentMethodRefFragmentDoc}
${SubscriptionIntervalFragmentDoc}`;
export const SystemMailFragmentDoc = gql`
    fragment SystemMail on SystemMailModel {
  event
  mailTemplate {
    ...MailTemplateRef
  }
}
    ${MailTemplateRefFragmentDoc}`;
export const ConsentsDocument = gql`
    query Consents {
  consents {
    id
    name
    slug
    defaultValue
    createdAt
    modifiedAt
  }
}
    `;

/**
 * __useConsentsQuery__
 *
 * To run a query within a React component, call `useConsentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConsentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConsentsQuery({
 *   variables: {
 *   },
 * });
 */
export function useConsentsQuery(baseOptions?: Apollo.QueryHookOptions<ConsentsQuery, ConsentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConsentsQuery, ConsentsQueryVariables>(ConsentsDocument, options);
      }
export function useConsentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConsentsQuery, ConsentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConsentsQuery, ConsentsQueryVariables>(ConsentsDocument, options);
        }
export type ConsentsQueryHookResult = ReturnType<typeof useConsentsQuery>;
export type ConsentsLazyQueryHookResult = ReturnType<typeof useConsentsLazyQuery>;
export type ConsentsQueryResult = Apollo.QueryResult<ConsentsQuery, ConsentsQueryVariables>;
export const ConsentDocument = gql`
    query consent($id: String!) {
  consent(id: $id) {
    id
    name
    slug
    defaultValue
    createdAt
    modifiedAt
  }
}
    `;

/**
 * __useConsentQuery__
 *
 * To run a query within a React component, call `useConsentQuery` and pass it any options that fit your needs.
 * When your component renders, `useConsentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConsentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useConsentQuery(baseOptions: Apollo.QueryHookOptions<ConsentQuery, ConsentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConsentQuery, ConsentQueryVariables>(ConsentDocument, options);
      }
export function useConsentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConsentQuery, ConsentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConsentQuery, ConsentQueryVariables>(ConsentDocument, options);
        }
export type ConsentQueryHookResult = ReturnType<typeof useConsentQuery>;
export type ConsentLazyQueryHookResult = ReturnType<typeof useConsentLazyQuery>;
export type ConsentQueryResult = Apollo.QueryResult<ConsentQuery, ConsentQueryVariables>;
export const CreateConsentDocument = gql`
    mutation createConsent($consent: ConsentInput!) {
  createConsent(consent: $consent) {
    id
    createdAt
    modifiedAt
    name
    slug
    defaultValue
  }
}
    `;
export type CreateConsentMutationFn = Apollo.MutationFunction<CreateConsentMutation, CreateConsentMutationVariables>;

/**
 * __useCreateConsentMutation__
 *
 * To run a mutation, you first call `useCreateConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConsentMutation, { data, loading, error }] = useCreateConsentMutation({
 *   variables: {
 *      consent: // value for 'consent'
 *   },
 * });
 */
export function useCreateConsentMutation(baseOptions?: Apollo.MutationHookOptions<CreateConsentMutation, CreateConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConsentMutation, CreateConsentMutationVariables>(CreateConsentDocument, options);
      }
export type CreateConsentMutationHookResult = ReturnType<typeof useCreateConsentMutation>;
export type CreateConsentMutationResult = Apollo.MutationResult<CreateConsentMutation>;
export type CreateConsentMutationOptions = Apollo.BaseMutationOptions<CreateConsentMutation, CreateConsentMutationVariables>;
export const UpdateConsentDocument = gql`
    mutation updateConsent($id: String!, $consent: ConsentInput!) {
  updateConsent(id: $id, consent: $consent) {
    id
    createdAt
    modifiedAt
    name
    slug
    defaultValue
  }
}
    `;
export type UpdateConsentMutationFn = Apollo.MutationFunction<UpdateConsentMutation, UpdateConsentMutationVariables>;

/**
 * __useUpdateConsentMutation__
 *
 * To run a mutation, you first call `useUpdateConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConsentMutation, { data, loading, error }] = useUpdateConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      consent: // value for 'consent'
 *   },
 * });
 */
export function useUpdateConsentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConsentMutation, UpdateConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConsentMutation, UpdateConsentMutationVariables>(UpdateConsentDocument, options);
      }
export type UpdateConsentMutationHookResult = ReturnType<typeof useUpdateConsentMutation>;
export type UpdateConsentMutationResult = Apollo.MutationResult<UpdateConsentMutation>;
export type UpdateConsentMutationOptions = Apollo.BaseMutationOptions<UpdateConsentMutation, UpdateConsentMutationVariables>;
export const DeleteConsentDocument = gql`
    mutation deleteConsent($id: String!) {
  deleteConsent(id: $id) {
    id
  }
}
    `;
export type DeleteConsentMutationFn = Apollo.MutationFunction<DeleteConsentMutation, DeleteConsentMutationVariables>;

/**
 * __useDeleteConsentMutation__
 *
 * To run a mutation, you first call `useDeleteConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteConsentMutation, { data, loading, error }] = useDeleteConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteConsentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteConsentMutation, DeleteConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteConsentMutation, DeleteConsentMutationVariables>(DeleteConsentDocument, options);
      }
export type DeleteConsentMutationHookResult = ReturnType<typeof useDeleteConsentMutation>;
export type DeleteConsentMutationResult = Apollo.MutationResult<DeleteConsentMutation>;
export type DeleteConsentMutationOptions = Apollo.BaseMutationOptions<DeleteConsentMutation, DeleteConsentMutationVariables>;
export const UserConsentsDocument = gql`
    query UserConsents {
  userConsents {
    id
    value
    createdAt
    modifiedAt
    consent {
      slug
      id
      name
    }
    user {
      id
      name
      firstName
      email
    }
  }
}
    `;

/**
 * __useUserConsentsQuery__
 *
 * To run a query within a React component, call `useUserConsentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserConsentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserConsentsQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserConsentsQuery(baseOptions?: Apollo.QueryHookOptions<UserConsentsQuery, UserConsentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserConsentsQuery, UserConsentsQueryVariables>(UserConsentsDocument, options);
      }
export function useUserConsentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserConsentsQuery, UserConsentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserConsentsQuery, UserConsentsQueryVariables>(UserConsentsDocument, options);
        }
export type UserConsentsQueryHookResult = ReturnType<typeof useUserConsentsQuery>;
export type UserConsentsLazyQueryHookResult = ReturnType<typeof useUserConsentsLazyQuery>;
export type UserConsentsQueryResult = Apollo.QueryResult<UserConsentsQuery, UserConsentsQueryVariables>;
export const UserConsentDocument = gql`
    query userConsent($id: String!) {
  userConsent(id: $id) {
    id
    value
    createdAt
    modifiedAt
    consent {
      slug
      id
      name
    }
    user {
      id
      name
      firstName
      email
    }
  }
}
    `;

/**
 * __useUserConsentQuery__
 *
 * To run a query within a React component, call `useUserConsentQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserConsentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserConsentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserConsentQuery(baseOptions: Apollo.QueryHookOptions<UserConsentQuery, UserConsentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserConsentQuery, UserConsentQueryVariables>(UserConsentDocument, options);
      }
export function useUserConsentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserConsentQuery, UserConsentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserConsentQuery, UserConsentQueryVariables>(UserConsentDocument, options);
        }
export type UserConsentQueryHookResult = ReturnType<typeof useUserConsentQuery>;
export type UserConsentLazyQueryHookResult = ReturnType<typeof useUserConsentLazyQuery>;
export type UserConsentQueryResult = Apollo.QueryResult<UserConsentQuery, UserConsentQueryVariables>;
export const CreateUserConsentDocument = gql`
    mutation createUserConsent($userConsent: UserConsentInput!) {
  createUserConsent(userConsent: $userConsent) {
    id
    value
  }
}
    `;
export type CreateUserConsentMutationFn = Apollo.MutationFunction<CreateUserConsentMutation, CreateUserConsentMutationVariables>;

/**
 * __useCreateUserConsentMutation__
 *
 * To run a mutation, you first call `useCreateUserConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserConsentMutation, { data, loading, error }] = useCreateUserConsentMutation({
 *   variables: {
 *      userConsent: // value for 'userConsent'
 *   },
 * });
 */
export function useCreateUserConsentMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserConsentMutation, CreateUserConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateUserConsentMutation, CreateUserConsentMutationVariables>(CreateUserConsentDocument, options);
      }
export type CreateUserConsentMutationHookResult = ReturnType<typeof useCreateUserConsentMutation>;
export type CreateUserConsentMutationResult = Apollo.MutationResult<CreateUserConsentMutation>;
export type CreateUserConsentMutationOptions = Apollo.BaseMutationOptions<CreateUserConsentMutation, CreateUserConsentMutationVariables>;
export const UpdateUserConsentDocument = gql`
    mutation updateUserConsent($id: String!, $userConsent: UpdateUserConsentInput!) {
  updateUserConsent(id: $id, userConsent: $userConsent) {
    id
    value
    createdAt
    modifiedAt
    consent {
      slug
      id
      name
    }
    user {
      id
      name
      firstName
      email
    }
  }
}
    `;
export type UpdateUserConsentMutationFn = Apollo.MutationFunction<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>;

/**
 * __useUpdateUserConsentMutation__
 *
 * To run a mutation, you first call `useUpdateUserConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserConsentMutation, { data, loading, error }] = useUpdateUserConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      userConsent: // value for 'userConsent'
 *   },
 * });
 */
export function useUpdateUserConsentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>(UpdateUserConsentDocument, options);
      }
export type UpdateUserConsentMutationHookResult = ReturnType<typeof useUpdateUserConsentMutation>;
export type UpdateUserConsentMutationResult = Apollo.MutationResult<UpdateUserConsentMutation>;
export type UpdateUserConsentMutationOptions = Apollo.BaseMutationOptions<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>;
export const DeleteUserConsentDocument = gql`
    mutation deleteUserConsent($id: String!) {
  deleteUserConsent(id: $id) {
    id
  }
}
    `;
export type DeleteUserConsentMutationFn = Apollo.MutationFunction<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>;

/**
 * __useDeleteUserConsentMutation__
 *
 * To run a mutation, you first call `useDeleteUserConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserConsentMutation, { data, loading, error }] = useDeleteUserConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserConsentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>(DeleteUserConsentDocument, options);
      }
export type DeleteUserConsentMutationHookResult = ReturnType<typeof useDeleteUserConsentMutation>;
export type DeleteUserConsentMutationResult = Apollo.MutationResult<DeleteUserConsentMutation>;
export type DeleteUserConsentMutationOptions = Apollo.BaseMutationOptions<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>;
export const MailTemplateDocument = gql`
    query MailTemplate {
  mailTemplates {
    ...fullMailTemplate
  }
  provider {
    ...fullMailProvider
  }
}
    ${FullMailTemplateFragmentDoc}
${FullMailProviderFragmentDoc}`;

/**
 * __useMailTemplateQuery__
 *
 * To run a query within a React component, call `useMailTemplateQuery` and pass it any options that fit your needs.
 * When your component renders, `useMailTemplateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMailTemplateQuery({
 *   variables: {
 *   },
 * });
 */
export function useMailTemplateQuery(baseOptions?: Apollo.QueryHookOptions<MailTemplateQuery, MailTemplateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MailTemplateQuery, MailTemplateQueryVariables>(MailTemplateDocument, options);
      }
export function useMailTemplateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MailTemplateQuery, MailTemplateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MailTemplateQuery, MailTemplateQueryVariables>(MailTemplateDocument, options);
        }
export type MailTemplateQueryHookResult = ReturnType<typeof useMailTemplateQuery>;
export type MailTemplateLazyQueryHookResult = ReturnType<typeof useMailTemplateLazyQuery>;
export type MailTemplateQueryResult = Apollo.QueryResult<MailTemplateQuery, MailTemplateQueryVariables>;
export const SynchronizeMailTemplatesDocument = gql`
    mutation SynchronizeMailTemplates {
  syncTemplates
}
    `;
export type SynchronizeMailTemplatesMutationFn = Apollo.MutationFunction<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>;

/**
 * __useSynchronizeMailTemplatesMutation__
 *
 * To run a mutation, you first call `useSynchronizeMailTemplatesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSynchronizeMailTemplatesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [synchronizeMailTemplatesMutation, { data, loading, error }] = useSynchronizeMailTemplatesMutation({
 *   variables: {
 *   },
 * });
 */
export function useSynchronizeMailTemplatesMutation(baseOptions?: Apollo.MutationHookOptions<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>(SynchronizeMailTemplatesDocument, options);
      }
export type SynchronizeMailTemplatesMutationHookResult = ReturnType<typeof useSynchronizeMailTemplatesMutation>;
export type SynchronizeMailTemplatesMutationResult = Apollo.MutationResult<SynchronizeMailTemplatesMutation>;
export type SynchronizeMailTemplatesMutationOptions = Apollo.BaseMutationOptions<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>;
export const SubscriptionFlowsDocument = gql`
    query SubscriptionFlows($defaultFlowOnly: Boolean!, $memberPlanId: String) {
  subscriptionFlows(
    defaultFlowOnly: $defaultFlowOnly
    memberPlanId: $memberPlanId
  ) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;

/**
 * __useSubscriptionFlowsQuery__
 *
 * To run a query within a React component, call `useSubscriptionFlowsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionFlowsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionFlowsQuery({
 *   variables: {
 *      defaultFlowOnly: // value for 'defaultFlowOnly'
 *      memberPlanId: // value for 'memberPlanId'
 *   },
 * });
 */
export function useSubscriptionFlowsQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>(SubscriptionFlowsDocument, options);
      }
export function useSubscriptionFlowsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>(SubscriptionFlowsDocument, options);
        }
export type SubscriptionFlowsQueryHookResult = ReturnType<typeof useSubscriptionFlowsQuery>;
export type SubscriptionFlowsLazyQueryHookResult = ReturnType<typeof useSubscriptionFlowsLazyQuery>;
export type SubscriptionFlowsQueryResult = Apollo.QueryResult<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>;
export const CreateSubscriptionFlowDocument = gql`
    mutation CreateSubscriptionFlow($subscriptionFlow: SubscriptionFlowModelCreateInput!) {
  createSubscriptionFlow(subscriptionFlow: $subscriptionFlow) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type CreateSubscriptionFlowMutationFn = Apollo.MutationFunction<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>;

/**
 * __useCreateSubscriptionFlowMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionFlowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionFlowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionFlowMutation, { data, loading, error }] = useCreateSubscriptionFlowMutation({
 *   variables: {
 *      subscriptionFlow: // value for 'subscriptionFlow'
 *   },
 * });
 */
export function useCreateSubscriptionFlowMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>(CreateSubscriptionFlowDocument, options);
      }
export type CreateSubscriptionFlowMutationHookResult = ReturnType<typeof useCreateSubscriptionFlowMutation>;
export type CreateSubscriptionFlowMutationResult = Apollo.MutationResult<CreateSubscriptionFlowMutation>;
export type CreateSubscriptionFlowMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>;
export const UpdateSubscriptionFlowDocument = gql`
    mutation UpdateSubscriptionFlow($subscriptionFlow: SubscriptionFlowModelUpdateInput!) {
  updateSubscriptionFlow(subscriptionFlow: $subscriptionFlow) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type UpdateSubscriptionFlowMutationFn = Apollo.MutationFunction<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>;

/**
 * __useUpdateSubscriptionFlowMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionFlowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionFlowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionFlowMutation, { data, loading, error }] = useUpdateSubscriptionFlowMutation({
 *   variables: {
 *      subscriptionFlow: // value for 'subscriptionFlow'
 *   },
 * });
 */
export function useUpdateSubscriptionFlowMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>(UpdateSubscriptionFlowDocument, options);
      }
export type UpdateSubscriptionFlowMutationHookResult = ReturnType<typeof useUpdateSubscriptionFlowMutation>;
export type UpdateSubscriptionFlowMutationResult = Apollo.MutationResult<UpdateSubscriptionFlowMutation>;
export type UpdateSubscriptionFlowMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>;
export const DeleteSubscriptionFlowDocument = gql`
    mutation DeleteSubscriptionFlow($subscriptionFlowId: String!) {
  deleteSubscriptionFlow(subscriptionFlowId: $subscriptionFlowId) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type DeleteSubscriptionFlowMutationFn = Apollo.MutationFunction<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>;

/**
 * __useDeleteSubscriptionFlowMutation__
 *
 * To run a mutation, you first call `useDeleteSubscriptionFlowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSubscriptionFlowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSubscriptionFlowMutation, { data, loading, error }] = useDeleteSubscriptionFlowMutation({
 *   variables: {
 *      subscriptionFlowId: // value for 'subscriptionFlowId'
 *   },
 * });
 */
export function useDeleteSubscriptionFlowMutation(baseOptions?: Apollo.MutationHookOptions<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>(DeleteSubscriptionFlowDocument, options);
      }
export type DeleteSubscriptionFlowMutationHookResult = ReturnType<typeof useDeleteSubscriptionFlowMutation>;
export type DeleteSubscriptionFlowMutationResult = Apollo.MutationResult<DeleteSubscriptionFlowMutation>;
export type DeleteSubscriptionFlowMutationOptions = Apollo.BaseMutationOptions<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>;
export const CreateSubscriptionIntervalDocument = gql`
    mutation CreateSubscriptionInterval($subscriptionInterval: SubscriptionIntervalCreateInput!) {
  createSubscriptionInterval(subscriptionInterval: $subscriptionInterval) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type CreateSubscriptionIntervalMutationFn = Apollo.MutationFunction<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>;

/**
 * __useCreateSubscriptionIntervalMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionIntervalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionIntervalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionIntervalMutation, { data, loading, error }] = useCreateSubscriptionIntervalMutation({
 *   variables: {
 *      subscriptionInterval: // value for 'subscriptionInterval'
 *   },
 * });
 */
export function useCreateSubscriptionIntervalMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>(CreateSubscriptionIntervalDocument, options);
      }
export type CreateSubscriptionIntervalMutationHookResult = ReturnType<typeof useCreateSubscriptionIntervalMutation>;
export type CreateSubscriptionIntervalMutationResult = Apollo.MutationResult<CreateSubscriptionIntervalMutation>;
export type CreateSubscriptionIntervalMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>;
export const UpdateSubscriptionIntervalsDocument = gql`
    mutation UpdateSubscriptionIntervals($subscriptionIntervals: [SubscriptionIntervalUpdateInput!]!) {
  updateSubscriptionIntervals(subscriptionIntervals: $subscriptionIntervals) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type UpdateSubscriptionIntervalsMutationFn = Apollo.MutationFunction<UpdateSubscriptionIntervalsMutation, UpdateSubscriptionIntervalsMutationVariables>;

/**
 * __useUpdateSubscriptionIntervalsMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionIntervalsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionIntervalsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionIntervalsMutation, { data, loading, error }] = useUpdateSubscriptionIntervalsMutation({
 *   variables: {
 *      subscriptionIntervals: // value for 'subscriptionIntervals'
 *   },
 * });
 */
export function useUpdateSubscriptionIntervalsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionIntervalsMutation, UpdateSubscriptionIntervalsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionIntervalsMutation, UpdateSubscriptionIntervalsMutationVariables>(UpdateSubscriptionIntervalsDocument, options);
      }
export type UpdateSubscriptionIntervalsMutationHookResult = ReturnType<typeof useUpdateSubscriptionIntervalsMutation>;
export type UpdateSubscriptionIntervalsMutationResult = Apollo.MutationResult<UpdateSubscriptionIntervalsMutation>;
export type UpdateSubscriptionIntervalsMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionIntervalsMutation, UpdateSubscriptionIntervalsMutationVariables>;
export const UpdateSubscriptionIntervalDocument = gql`
    mutation UpdateSubscriptionInterval($subscriptionInterval: SubscriptionIntervalUpdateInput!) {
  updateSubscriptionInterval(subscriptionInterval: $subscriptionInterval) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type UpdateSubscriptionIntervalMutationFn = Apollo.MutationFunction<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>;

/**
 * __useUpdateSubscriptionIntervalMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionIntervalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionIntervalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionIntervalMutation, { data, loading, error }] = useUpdateSubscriptionIntervalMutation({
 *   variables: {
 *      subscriptionInterval: // value for 'subscriptionInterval'
 *   },
 * });
 */
export function useUpdateSubscriptionIntervalMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>(UpdateSubscriptionIntervalDocument, options);
      }
export type UpdateSubscriptionIntervalMutationHookResult = ReturnType<typeof useUpdateSubscriptionIntervalMutation>;
export type UpdateSubscriptionIntervalMutationResult = Apollo.MutationResult<UpdateSubscriptionIntervalMutation>;
export type UpdateSubscriptionIntervalMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>;
export const DeleteSubscriptionIntervalDocument = gql`
    mutation DeleteSubscriptionInterval($subscriptionInterval: SubscriptionIntervalDeleteInput!) {
  deleteSubscriptionInterval(subscriptionInterval: $subscriptionInterval) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type DeleteSubscriptionIntervalMutationFn = Apollo.MutationFunction<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>;

/**
 * __useDeleteSubscriptionIntervalMutation__
 *
 * To run a mutation, you first call `useDeleteSubscriptionIntervalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSubscriptionIntervalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSubscriptionIntervalMutation, { data, loading, error }] = useDeleteSubscriptionIntervalMutation({
 *   variables: {
 *      subscriptionInterval: // value for 'subscriptionInterval'
 *   },
 * });
 */
export function useDeleteSubscriptionIntervalMutation(baseOptions?: Apollo.MutationHookOptions<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>(DeleteSubscriptionIntervalDocument, options);
      }
export type DeleteSubscriptionIntervalMutationHookResult = ReturnType<typeof useDeleteSubscriptionIntervalMutation>;
export type DeleteSubscriptionIntervalMutationResult = Apollo.MutationResult<DeleteSubscriptionIntervalMutation>;
export type DeleteSubscriptionIntervalMutationOptions = Apollo.BaseMutationOptions<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>;
export const ListPaymentMethodsDocument = gql`
    query ListPaymentMethods {
  paymentMethods {
    ...PaymentMethodRef
  }
}
    ${PaymentMethodRefFragmentDoc}`;

/**
 * __useListPaymentMethodsQuery__
 *
 * To run a query within a React component, call `useListPaymentMethodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListPaymentMethodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListPaymentMethodsQuery({
 *   variables: {
 *   },
 * });
 */
export function useListPaymentMethodsQuery(baseOptions?: Apollo.QueryHookOptions<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>(ListPaymentMethodsDocument, options);
      }
export function useListPaymentMethodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>(ListPaymentMethodsDocument, options);
        }
export type ListPaymentMethodsQueryHookResult = ReturnType<typeof useListPaymentMethodsQuery>;
export type ListPaymentMethodsLazyQueryHookResult = ReturnType<typeof useListPaymentMethodsLazyQuery>;
export type ListPaymentMethodsQueryResult = Apollo.QueryResult<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>;
export const GetSystemMailsDocument = gql`
    query GetSystemMails {
  getSystemMails {
    ...SystemMail
  }
}
    ${SystemMailFragmentDoc}`;

/**
 * __useGetSystemMailsQuery__
 *
 * To run a query within a React component, call `useGetSystemMailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSystemMailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSystemMailsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSystemMailsQuery(baseOptions?: Apollo.QueryHookOptions<GetSystemMailsQuery, GetSystemMailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSystemMailsQuery, GetSystemMailsQueryVariables>(GetSystemMailsDocument, options);
      }
export function useGetSystemMailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSystemMailsQuery, GetSystemMailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSystemMailsQuery, GetSystemMailsQueryVariables>(GetSystemMailsDocument, options);
        }
export type GetSystemMailsQueryHookResult = ReturnType<typeof useGetSystemMailsQuery>;
export type GetSystemMailsLazyQueryHookResult = ReturnType<typeof useGetSystemMailsLazyQuery>;
export type GetSystemMailsQueryResult = Apollo.QueryResult<GetSystemMailsQuery, GetSystemMailsQueryVariables>;
export const UpdateSystemMailDocument = gql`
    mutation UpdateSystemMail($systemMail: SystemMailUpdateInput!) {
  updateSystemMail(systemMail: $systemMail) {
    ...SystemMail
  }
}
    ${SystemMailFragmentDoc}`;
export type UpdateSystemMailMutationFn = Apollo.MutationFunction<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>;

/**
 * __useUpdateSystemMailMutation__
 *
 * To run a mutation, you first call `useUpdateSystemMailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSystemMailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSystemMailMutation, { data, loading, error }] = useUpdateSystemMailMutation({
 *   variables: {
 *      systemMail: // value for 'systemMail'
 *   },
 * });
 */
export function useUpdateSystemMailMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>(UpdateSystemMailDocument, options);
      }
export type UpdateSystemMailMutationHookResult = ReturnType<typeof useUpdateSystemMailMutation>;
export type UpdateSystemMailMutationResult = Apollo.MutationResult<UpdateSystemMailMutation>;
export type UpdateSystemMailMutationOptions = Apollo.BaseMutationOptions<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>;
export const TestSystemMailDocument = gql`
    mutation TestSystemMail($systemMail: SystemMailTestInput!) {
  testSystemMail(systemMail: $systemMail) {
    ...SystemMail
  }
}
    ${SystemMailFragmentDoc}`;
export type TestSystemMailMutationFn = Apollo.MutationFunction<TestSystemMailMutation, TestSystemMailMutationVariables>;

/**
 * __useTestSystemMailMutation__
 *
 * To run a mutation, you first call `useTestSystemMailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTestSystemMailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [testSystemMailMutation, { data, loading, error }] = useTestSystemMailMutation({
 *   variables: {
 *      systemMail: // value for 'systemMail'
 *   },
 * });
 */
export function useTestSystemMailMutation(baseOptions?: Apollo.MutationHookOptions<TestSystemMailMutation, TestSystemMailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TestSystemMailMutation, TestSystemMailMutationVariables>(TestSystemMailDocument, options);
      }
export type TestSystemMailMutationHookResult = ReturnType<typeof useTestSystemMailMutation>;
export type TestSystemMailMutationResult = Apollo.MutationResult<TestSystemMailMutation>;
export type TestSystemMailMutationOptions = Apollo.BaseMutationOptions<TestSystemMailMutation, TestSystemMailMutationVariables>;
export const VersionInformationDocument = gql`
    query VersionInformation {
  versionInformation {
    version
  }
}
    `;

/**
 * __useVersionInformationQuery__
 *
 * To run a query within a React component, call `useVersionInformationQuery` and pass it any options that fit your needs.
 * When your component renders, `useVersionInformationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVersionInformationQuery({
 *   variables: {
 *   },
 * });
 */
export function useVersionInformationQuery(baseOptions?: Apollo.QueryHookOptions<VersionInformationQuery, VersionInformationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VersionInformationQuery, VersionInformationQueryVariables>(VersionInformationDocument, options);
      }
export function useVersionInformationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VersionInformationQuery, VersionInformationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VersionInformationQuery, VersionInformationQueryVariables>(VersionInformationDocument, options);
        }
export type VersionInformationQueryHookResult = ReturnType<typeof useVersionInformationQuery>;
export type VersionInformationLazyQueryHookResult = ReturnType<typeof useVersionInformationLazyQuery>;
export type VersionInformationQueryResult = Apollo.QueryResult<VersionInformationQuery, VersionInformationQueryVariables>;
