// THIS FILE IS AUTOGENERATED
import {Node} from 'slate'
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A hexidecimal color value. */
  Color: string;
  /** A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  Date: string;
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: string;
  /** Setting Value */
  GraphQLSettingValueType: any;
  RichText: Node[];
  Slug: string;
  /** The `Upload` scalar type represents a file upload. */
  Upload: File;
  /** A valid vote value */
  VoteValue: number;
  _Any: any;
  _FieldSet: any;
  link__Import: any;
};

export type AllowedSettingVals = {
  __typename?: 'AllowedSettingVals';
  boolChoice?: Maybe<Scalars['Boolean']>;
  stringChoice?: Maybe<Array<Scalars['String']>>;
};

export type Article = {
  __typename?: 'Article';
  authors: Array<Author>;
  blocks: Array<Block>;
  breaking: Scalars['Boolean'];
  canonicalUrl?: Maybe<Scalars['String']>;
  comments: Array<Comment>;
  disableComments?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  image?: Maybe<Image>;
  lead?: Maybe<Scalars['String']>;
  likes: Scalars['Int'];
  peeredArticleURL?: Maybe<Scalars['String']>;
  preTitle?: Maybe<Scalars['String']>;
  properties: Array<PublicProperties>;
  publishedAt: Scalars['DateTime'];
  seoTitle?: Maybe<Scalars['String']>;
  slug: Scalars['Slug'];
  socialMediaAuthors: Array<Author>;
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaImage?: Maybe<Image>;
  socialMediaTitle?: Maybe<Scalars['String']>;
  tags: Array<Tag>;
  title: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  url: Scalars['String'];
};

export type ArticleConnection = {
  __typename?: 'ArticleConnection';
  nodes: Array<Article>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ArticleFilter = {
  authors?: InputMaybe<Array<Scalars['ID']>>;
  body?: InputMaybe<Scalars['String']>;
  includeHidden?: InputMaybe<Scalars['Boolean']>;
  lead?: InputMaybe<Scalars['String']>;
  preTitle?: InputMaybe<Scalars['String']>;
  publicationDateFrom?: InputMaybe<DateFilter>;
  publicationDateTo?: InputMaybe<DateFilter>;
  shared?: InputMaybe<Scalars['Boolean']>;
  tags?: InputMaybe<Array<Scalars['String']>>;
  title?: InputMaybe<Scalars['String']>;
};

export type ArticleNavigationLink = BaseNavigationLink & {
  __typename?: 'ArticleNavigationLink';
  article?: Maybe<Article>;
  label: Scalars['String'];
};

export enum ArticleSort {
  PublishedAt = 'publishedAt',
  UpdatedAt = 'updatedAt'
}

export type ArticleTeaser = {
  __typename?: 'ArticleTeaser';
  article?: Maybe<Article>;
  image?: Maybe<Image>;
  lead?: Maybe<Scalars['String']>;
  preTitle?: Maybe<Scalars['String']>;
  /** @deprecated Use block styles instead of this */
  style: TeaserStyle;
  title?: Maybe<Scalars['String']>;
};

export type AuthProvider = {
  __typename?: 'AuthProvider';
  name: Scalars['String'];
  url: Scalars['String'];
};

export type Author = {
  __typename?: 'Author';
  bio?: Maybe<Scalars['RichText']>;
  createdAt: Scalars['DateTime'];
  hideOnArticle?: Maybe<Scalars['Boolean']>;
  hideOnTeam?: Maybe<Scalars['Boolean']>;
  hideOnTeaser?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  image?: Maybe<Image>;
  jobTitle?: Maybe<Scalars['String']>;
  links?: Maybe<Array<AuthorLink>>;
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['Slug'];
  tags: Array<Tag>;
  url: Scalars['String'];
};

export type AuthorConnection = {
  __typename?: 'AuthorConnection';
  nodes: Array<Author>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type AuthorFilter = {
  hideOnTeam?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  tagIds?: InputMaybe<Array<Scalars['ID']>>;
};

export type AuthorLink = {
  __typename?: 'AuthorLink';
  title: Scalars['String'];
  url: Scalars['String'];
};

export enum AuthorSort {
  Name = 'NAME',
  CreatedAt = 'createdAt',
  ModifiedAt = 'modifiedAt'
}

export type AvailablePaymentMethod = {
  __typename?: 'AvailablePaymentMethod';
  forceAutoRenewal: Scalars['Boolean'];
  paymentMethods: Array<PaymentMethod>;
  paymentPeriodicities: Array<PaymentPeriodicity>;
};

export type Banner = {
  __typename?: 'Banner';
  actions?: Maybe<Array<BannerAction>>;
  active: Scalars['Boolean'];
  cta?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image?: Maybe<Image>;
  imageId?: Maybe<Scalars['String']>;
  showOnArticles: Scalars['Boolean'];
  showOnPages?: Maybe<Array<PageModel>>;
  text: Scalars['String'];
  title: Scalars['String'];
};

export type BannerAction = {
  __typename?: 'BannerAction';
  id: Scalars['ID'];
  label: Scalars['String'];
  role: BannerActionRole;
  style: Scalars['String'];
  url: Scalars['String'];
};

export enum BannerActionRole {
  Cancel = 'CANCEL',
  Other = 'OTHER',
  Primary = 'PRIMARY'
}

export enum BannerDocumentType {
  Article = 'ARTICLE',
  Page = 'PAGE'
}

export type BaseNavigationLink = {
  label: Scalars['String'];
};

export type BildwurfAdBlock = {
  __typename?: 'BildwurfAdBlock';
  blockStyle?: Maybe<Scalars['String']>;
  zoneID: Scalars['String'];
};

export type Block = BildwurfAdBlock | CommentBlock | EmbedBlock | EventBlock | FacebookPostBlock | FacebookVideoBlock | HtmlBlock | ImageBlock | ImageGalleryBlock | InstagramPostBlock | LinkPageBreakBlock | ListicleBlock | PolisConversationBlock | PollBlock | QuoteBlock | RichTextBlock | SoundCloudTrackBlock | TeaserGridBlock | TeaserGridFlexBlock | TeaserListBlock | TikTokVideoBlock | TitleBlock | TwitterTweetBlock | VimeoVideoBlock | YouTubeVideoBlock;

export type BlockStyle = {
  __typename?: 'BlockStyle';
  blocks: Array<BlockType>;
  createdAt: Scalars['DateTime'];
  id: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
};

export enum BlockType {
  Comment = 'Comment',
  Embed = 'Embed',
  Event = 'Event',
  Html = 'HTML',
  Image = 'Image',
  ImageGallery = 'ImageGallery',
  LinkPageBreak = 'LinkPageBreak',
  Listicle = 'Listicle',
  Poll = 'Poll',
  Quote = 'Quote',
  RichText = 'RichText',
  TeaserGrid1 = 'TeaserGrid1',
  TeaserGrid6 = 'TeaserGrid6',
  TeaserGridFlex = 'TeaserGridFlex',
  TeaserList = 'TeaserList',
  Title = 'Title'
}

export type CalculatedRating = {
  __typename?: 'CalculatedRating';
  answer: CommentRatingSystemAnswer;
  count: Scalars['Int'];
  mean: Scalars['Float'];
  total: Scalars['Int'];
};

export enum CaptchaType {
  Algebraic = 'Algebraic',
  CfTurnstile = 'CfTurnstile'
}

export type Challenge = {
  __typename?: 'Challenge';
  challenge?: Maybe<Scalars['String']>;
  challengeID?: Maybe<Scalars['String']>;
  type?: Maybe<CaptchaType>;
  validUntil?: Maybe<Scalars['Date']>;
};

export type ChallengeInput = {
  challengeID?: InputMaybe<Scalars['String']>;
  challengeSolution: Scalars['String'];
};

export type Comment = {
  __typename?: 'Comment';
  authorType: CommentAuthorType;
  calculatedRatings: Array<CalculatedRating>;
  children: Array<Comment>;
  createdAt: Scalars['DateTime'];
  featured?: Maybe<Scalars['Boolean']>;
  guestUserImage?: Maybe<Image>;
  guestUsername?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  itemID: Scalars['ID'];
  itemType: CommentItemType;
  lead?: Maybe<Scalars['String']>;
  modifiedAt?: Maybe<Scalars['DateTime']>;
  overriddenRatings: Array<OverriddenRating>;
  parentID?: Maybe<Scalars['ID']>;
  peerId?: Maybe<Scalars['ID']>;
  rejectionReason?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
  state: CommentState;
  tags: Array<Tag>;
  text?: Maybe<Scalars['RichText']>;
  title?: Maybe<Scalars['String']>;
  url: Scalars['String'];
  user?: Maybe<User>;
  userRatings: Array<CommentRating>;
};

export enum CommentAuthorType {
  Author = 'author',
  GuestUser = 'guestUser',
  Team = 'team',
  VerifiedUser = 'verifiedUser'
}

export type CommentBlock = {
  __typename?: 'CommentBlock';
  blockStyle?: Maybe<Scalars['String']>;
  comments: Array<Comment>;
};

export type CommentInput = {
  challenge?: InputMaybe<ChallengeInput>;
  guestUsername?: InputMaybe<Scalars['String']>;
  itemID: Scalars['ID'];
  itemType: CommentItemType;
  parentID?: InputMaybe<Scalars['ID']>;
  peerId?: InputMaybe<Scalars['ID']>;
  text: Scalars['RichText'];
  title?: InputMaybe<Scalars['String']>;
};

export enum CommentItemType {
  Article = 'article',
  Page = 'page',
  PeerArticle = 'peerArticle'
}

export type CommentRating = {
  __typename?: 'CommentRating';
  answer: CommentRatingSystemAnswer;
  commentId: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  disabled?: Maybe<Scalars['Boolean']>;
  fingerprint?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  userId?: Maybe<Scalars['ID']>;
  value: Scalars['Int'];
};

export type CommentRatingSystemAnswer = {
  __typename?: 'CommentRatingSystemAnswer';
  answer?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  ratingSystemId: Scalars['ID'];
  type: RatingSystemType;
};

export enum CommentSort {
  Rating = 'rating'
}

export enum CommentState {
  Approved = 'approved',
  PendingApproval = 'pendingApproval',
  PendingUserChanges = 'pendingUserChanges',
  Rejected = 'rejected'
}

export type CommentUpdateInput = {
  id: Scalars['ID'];
  lead?: InputMaybe<Scalars['String']>;
  text?: InputMaybe<Scalars['RichText']>;
  title?: InputMaybe<Scalars['String']>;
};

export type Consent = {
  __typename?: 'Consent';
  createdAt: Scalars['DateTime'];
  defaultValue: Scalars['Boolean'];
  id: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  slug: Scalars['String'];
};

export type ConsentFilter = {
  defaultValue?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
};

export type CreateBannerActionInput = {
  label: Scalars['String'];
  role: BannerActionRole;
  style: Scalars['String'];
  url: Scalars['String'];
};

export type CreateBannerInput = {
  actions?: InputMaybe<Array<CreateBannerActionInput>>;
  active: Scalars['Boolean'];
  cta?: InputMaybe<Scalars['String']>;
  imageId?: InputMaybe<Scalars['String']>;
  showOnArticles: Scalars['Boolean'];
  showOnPages?: InputMaybe<Array<PageModelInput>>;
  text: Scalars['String'];
  title: Scalars['String'];
};

export enum Currency {
  Chf = 'CHF',
  Eur = 'EUR'
}

export type CustomTeaser = {
  __typename?: 'CustomTeaser';
  contentUrl?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
  lead?: Maybe<Scalars['String']>;
  preTitle?: Maybe<Scalars['String']>;
  properties: Array<PublicProperties>;
  /** @deprecated Use block styles instead of this */
  style: TeaserStyle;
  title?: Maybe<Scalars['String']>;
};

export type DashboardInvoice = {
  __typename?: 'DashboardInvoice';
  amount: Scalars['Int'];
  dueAt: Scalars['DateTime'];
  memberPlan?: Maybe<Scalars['String']>;
  paidAt?: Maybe<Scalars['DateTime']>;
};

export type DashboardSubscription = {
  __typename?: 'DashboardSubscription';
  deactivationDate?: Maybe<Scalars['DateTime']>;
  endsAt?: Maybe<Scalars['DateTime']>;
  memberPlan: Scalars['String'];
  monthlyAmount: Scalars['Int'];
  paymentPeriodicity: PaymentPeriodicity;
  reasonForDeactivation?: Maybe<SubscriptionDeactivationReason>;
  renewsAt?: Maybe<Scalars['DateTime']>;
  startsAt: Scalars['DateTime'];
};

export type DateFilter = {
  comparison: DateFilterComparison;
  date?: InputMaybe<Scalars['DateTime']>;
};

export enum DateFilterComparison {
  Eq = 'eq',
  Gt = 'gt',
  Gte = 'gte',
  Lt = 'lt',
  Lte = 'lte'
}

export type DeletePollVotesResult = {
  __typename?: 'DeletePollVotesResult';
  count: Scalars['Int'];
};

export type EmbedBlock = {
  __typename?: 'EmbedBlock';
  blockStyle?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['Int']>;
  sandbox?: Maybe<Scalars['String']>;
  styleCustom?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
};

export type Event = {
  __typename?: 'Event';
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['RichText']>;
  endsAt?: Maybe<Scalars['DateTime']>;
  externalSourceId?: Maybe<Scalars['String']>;
  externalSourceName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image?: Maybe<Image>;
  imageId?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  page?: Maybe<Page>;
  startsAt: Scalars['DateTime'];
  status: EventStatus;
  tags: Array<Tag>;
  url: Scalars['String'];
};

export type EventBlock = {
  __typename?: 'EventBlock';
  blockStyle?: Maybe<Scalars['String']>;
  events: Array<Event>;
  filter: EventBlockFilter;
};

export type EventBlockFilter = {
  __typename?: 'EventBlockFilter';
  events?: Maybe<Array<Scalars['ID']>>;
  tags?: Maybe<Array<Scalars['ID']>>;
};

export type EventFilter = {
  from?: InputMaybe<Scalars['DateTime']>;
  location?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Array<Scalars['String']>>;
  to?: InputMaybe<Scalars['DateTime']>;
  upcomingOnly?: InputMaybe<Scalars['Boolean']>;
};

export type EventFromSource = {
  __typename?: 'EventFromSource';
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['RichText']>;
  endsAt?: Maybe<Scalars['DateTime']>;
  externalSourceId?: Maybe<Scalars['String']>;
  externalSourceName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  imageUrl?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  page?: Maybe<Page>;
  startsAt: Scalars['DateTime'];
  status: EventStatus;
};

export enum EventSort {
  CreatedAt = 'CreatedAt',
  EndsAt = 'EndsAt',
  ModifiedAt = 'ModifiedAt',
  StartsAt = 'StartsAt'
}

export enum EventStatus {
  Cancelled = 'Cancelled',
  Postponed = 'Postponed',
  Rescheduled = 'Rescheduled',
  Scheduled = 'Scheduled'
}

export type EventTeaser = {
  __typename?: 'EventTeaser';
  event?: Maybe<Event>;
  image?: Maybe<Image>;
  lead?: Maybe<Scalars['String']>;
  preTitle?: Maybe<Scalars['String']>;
  /** @deprecated Use block styles instead of this */
  style: TeaserStyle;
  title?: Maybe<Scalars['String']>;
};

export type ExternalNavigationLink = BaseNavigationLink & {
  __typename?: 'ExternalNavigationLink';
  label: Scalars['String'];
  url: Scalars['String'];
};

export type FacebookPostBlock = {
  __typename?: 'FacebookPostBlock';
  blockStyle?: Maybe<Scalars['String']>;
  postID: Scalars['String'];
  userID: Scalars['String'];
};

export type FacebookVideoBlock = {
  __typename?: 'FacebookVideoBlock';
  blockStyle?: Maybe<Scalars['String']>;
  userID: Scalars['String'];
  videoID: Scalars['String'];
};

export type FlexAlignment = {
  __typename?: 'FlexAlignment';
  h: Scalars['Int'];
  w: Scalars['Int'];
  x: Scalars['Int'];
  y: Scalars['Int'];
};

export type FlexTeaser = {
  __typename?: 'FlexTeaser';
  alignment: FlexAlignment;
  teaser?: Maybe<Teaser>;
};

export type FocalPoint = {
  __typename?: 'FocalPoint';
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type FullCommentRatingSystem = {
  __typename?: 'FullCommentRatingSystem';
  answers: Array<CommentRatingSystemAnswer>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

export type FullPoll = {
  __typename?: 'FullPoll';
  answers: Array<PollAnswerWithVoteCount>;
  closedAt?: Maybe<Scalars['DateTime']>;
  externalVoteSources: Array<PollExternalVoteSource>;
  id: Scalars['ID'];
  infoText?: Maybe<Scalars['RichText']>;
  opensAt: Scalars['DateTime'];
  question?: Maybe<Scalars['String']>;
};

export type GalleryImageEdge = {
  __typename?: 'GalleryImageEdge';
  caption?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
};

export type HtmlBlock = {
  __typename?: 'HTMLBlock';
  blockStyle?: Maybe<Scalars['String']>;
  html?: Maybe<Scalars['String']>;
};

export type Image = {
  __typename?: 'Image';
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  extension: Scalars['String'];
  fileSize: Scalars['Int'];
  filename?: Maybe<Scalars['String']>;
  focalPoint?: Maybe<FocalPoint>;
  format: Scalars['String'];
  height: Scalars['Int'];
  id: Scalars['ID'];
  license?: Maybe<Scalars['String']>;
  link?: Maybe<Scalars['String']>;
  mimeType: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  source?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  transformURL?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  width: Scalars['Int'];
};


export type ImageTransformUrlArgs = {
  input?: InputMaybe<ImageTransformation>;
};

export type ImageBlock = {
  __typename?: 'ImageBlock';
  blockStyle?: Maybe<Scalars['String']>;
  caption?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
  linkUrl?: Maybe<Scalars['String']>;
};

export type ImageGalleryBlock = {
  __typename?: 'ImageGalleryBlock';
  blockStyle?: Maybe<Scalars['String']>;
  images: Array<GalleryImageEdge>;
};

export enum ImageOutput {
  Jpeg = 'jpeg',
  Png = 'png',
  Webp = 'webp'
}

export enum ImageRotation {
  Auto = 'Auto',
  Rotate0 = 'Rotate0',
  Rotate90 = 'Rotate90',
  Rotate180 = 'Rotate180',
  Rotate270 = 'Rotate270'
}

export type ImageTransformation = {
  height?: InputMaybe<Scalars['Int']>;
  output?: InputMaybe<ImageOutput>;
  quality?: InputMaybe<Scalars['Float']>;
  rotation?: InputMaybe<ImageRotation>;
  width?: InputMaybe<Scalars['Int']>;
};

export type ImageV2 = {
  __typename?: 'ImageV2';
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['RichText']>;
  extension: Scalars['String'];
  fileSize: Scalars['Int'];
  filename?: Maybe<Scalars['String']>;
  focalPoint?: Maybe<FocalPoint>;
  format: Scalars['String'];
  height: Scalars['Int'];
  id: Scalars['ID'];
  license?: Maybe<Scalars['String']>;
  link?: Maybe<Scalars['String']>;
  mimeType: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  source?: Maybe<Scalars['String']>;
  tags: Array<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  width: Scalars['Int'];
};

export type ImportedEventFilter = {
  from?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  providers?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  to?: InputMaybe<Scalars['String']>;
};

export enum ImportedEventSort {
  CreatedAt = 'CREATED_AT',
  EndsAt = 'ENDS_AT',
  ModifiedAt = 'MODIFIED_AT',
  StartsAt = 'STARTS_AT'
}

export type ImportedEventsDocument = {
  __typename?: 'ImportedEventsDocument';
  nodes: Array<EventFromSource>;
  pageInfo: PageInfo;
  totalCount: Scalars['Float'];
};

export type InputPoint = {
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type InstagramPostBlock = {
  __typename?: 'InstagramPostBlock';
  blockStyle?: Maybe<Scalars['String']>;
  postID: Scalars['String'];
};

export type Invoice = {
  __typename?: 'Invoice';
  canceledAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  dueAt: Scalars['DateTime'];
  id: Scalars['ID'];
  items: Array<InvoiceItem>;
  mail: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  paidAt?: Maybe<Scalars['DateTime']>;
  subscription?: Maybe<Subscription>;
  subscriptionID: Scalars['ID'];
  total: Scalars['Int'];
};

export type InvoiceItem = {
  __typename?: 'InvoiceItem';
  amount: Scalars['Int'];
  createdAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  quantity: Scalars['Int'];
  total: Scalars['Int'];
};

export type LikeCreateInput = {
  articleId: Scalars['ID'];
};

export type LikeDeleteInput = {
  articleId: Scalars['ID'];
};

export type LinkPageBreakBlock = {
  __typename?: 'LinkPageBreakBlock';
  blockStyle?: Maybe<Scalars['String']>;
  hideButton: Scalars['Boolean'];
  image?: Maybe<Image>;
  /** @deprecated Use block styles instead of this */
  layoutOption?: Maybe<Scalars['String']>;
  linkTarget?: Maybe<Scalars['String']>;
  linkText?: Maybe<Scalars['String']>;
  linkURL?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
  /** @deprecated Use block styles instead of this */
  styleOption?: Maybe<Scalars['String']>;
  /** @deprecated Use block styles instead of this */
  templateOption?: Maybe<Scalars['String']>;
  text?: Maybe<Scalars['String']>;
};

export type ListicleBlock = {
  __typename?: 'ListicleBlock';
  blockStyle?: Maybe<Scalars['String']>;
  items: Array<ListicleItem>;
};

export type ListicleItem = {
  __typename?: 'ListicleItem';
  image?: Maybe<Image>;
  richText: Scalars['RichText'];
  title: Scalars['String'];
};

export type MailProviderModel = {
  __typename?: 'MailProviderModel';
  name: Scalars['String'];
};

export type MailTemplateRef = {
  __typename?: 'MailTemplateRef';
  id: Scalars['String'];
  name: Scalars['String'];
};

export type MailTemplateWithUrlAndStatusModel = {
  __typename?: 'MailTemplateWithUrlAndStatusModel';
  description?: Maybe<Scalars['String']>;
  externalMailTemplateId: Scalars['String'];
  id: Scalars['String'];
  name: Scalars['String'];
  remoteMissing: Scalars['Boolean'];
  status: Scalars['String'];
  url: Scalars['String'];
};

export type MemberPlan = {
  __typename?: 'MemberPlan';
  amountPerMonthMin: Scalars['Int'];
  amountPerMonthTarget?: Maybe<Scalars['Int']>;
  availablePaymentMethods: Array<AvailablePaymentMethod>;
  currency: Currency;
  description?: Maybe<Scalars['RichText']>;
  extendable: Scalars['Boolean'];
  failPage?: Maybe<Page>;
  failPageId?: Maybe<Scalars['ID']>;
  id: Scalars['ID'];
  image?: Maybe<Image>;
  maxCount?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  slug: Scalars['String'];
  successPage?: Maybe<Page>;
  successPageId?: Maybe<Scalars['ID']>;
  tags?: Maybe<Array<Scalars['String']>>;
};

export type MemberPlanConnection = {
  __typename?: 'MemberPlanConnection';
  nodes: Array<MemberPlan>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type MemberPlanFilter = {
  active?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};

export enum MemberPlanSort {
  CreatedAt = 'createdAt',
  ModifiedAt = 'modifiedAt'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** This mutation allows to add a comment. The input is of type CommentInput. */
  addComment: Comment;
  /** Add a like to an existing article. */
  addLike: Scalars['Int'];
  /** This mutation allows to cancel the users subscriptions. The deactivation date will be either paidUntil or now */
  cancelUserSubscription?: Maybe<Subscription>;
  createBanner: Banner;
  /** Creates a new block style. */
  createBlockStyle: BlockStyle;
  /**
   *
   *       Create a new consent.
   *
   */
  createConsent: Consent;
  /** Creates a new event. */
  createEvent: Event;
  /** This mutation allows to create payment by taking an input of type PaymentFromInvoiceInput. */
  createPaymentFromInvoice?: Maybe<Payment>;
  /** This mutation allows to create payment by referencing a subscription. */
  createPaymentFromSubscription?: Maybe<Payment>;
  createSession: SessionWithToken;
  createSessionWithJWT: SessionWithToken;
  createSessionWithOAuth2Code: SessionWithToken;
  /** Allows authenticated users to create additional subscriptions */
  createSubscription: Payment;
  /** Create a new subscription flow */
  createSubscriptionFlow: Array<SubscriptionFlowModel>;
  /** Create a subscription interval */
  createSubscriptionInterval: Array<SubscriptionFlowModel>;
  /**
   *
   *       Creates a new userConsent based on input.
   *       Returns created userConsent.
   *
   */
  createUserConsent: UserConsent;
  deleteBanner?: Maybe<Scalars['Boolean']>;
  /** Deletes an existing block style. */
  deleteBlockStyle: BlockStyle;
  /**
   *
   *       Deletes an existing consent.
   *
   */
  deleteConsent: Consent;
  /** Deletes an existing event. */
  deleteEvent: Event;
  /** Delete poll votes */
  deletePollVotes: DeletePollVotesResult;
  /** Delete an existing subscription flow */
  deleteSubscriptionFlow: Array<SubscriptionFlowModel>;
  /** Delete an existing subscription interval */
  deleteSubscriptionInterval: Array<SubscriptionFlowModel>;
  /**
   *
   *       Delete an existing userConsent by id.
   *       Returns deleted userConsent.
   *
   */
  deleteUserConsent: UserConsent;
  /** This mutation extends an subscription early */
  extendSubscription: Payment;
  /**
   *
   *       Creates and event based on data from importable events list and an id and provider.
   *       Also, uploads an image to WePublish Image library.
   *
   */
  importEvent: Scalars['String'];
  /** This mutation allows to rate a comment. Supports logged in and anonymous */
  rateComment: Comment;
  /** This mutation allows to register a new member, */
  registerMember: Registration;
  /** This mutation allows to register a new member, select a member plan, payment method and create an invoice.  */
  registerMemberAndReceivePayment: RegistrationAndPayment;
  /** Remove a like from an existing article. */
  removeLike: Scalars['Int'];
  /** This mutation revokes and deletes the active session. */
  revokeActiveSession: Scalars['Boolean'];
  /** This mutation sends a login link to the email if the user exists. Method will always return email address */
  sendWebsiteLogin: Scalars['String'];
  syncTemplates?: Maybe<Scalars['Boolean']>;
  /** Sends a test email for the given event */
  testSystemMail: Scalars['Boolean'];
  updateBanner: Banner;
  /** Updates an existing block style. */
  updateBlockStyle: BlockStyle;
  /** This mutation allows to update a comment. The input is of type CommentUpdateInput which contains the ID of the comment you want to update and the new text. */
  updateComment: Comment;
  /**
   *
   *       Updates an existing consent.
   *
   */
  updateConsent: Consent;
  /** Updates an existing event. */
  updateEvent: Event;
  /** This mutation allows to update the user's password by entering the new password. The repeated new password gives an error if the passwords don't match or if the user is not authenticated. */
  updatePassword?: Maybe<User>;
  /** This mutation allows to update the Payment Provider Customers */
  updatePaymentProviderCustomers: Array<PaymentProviderCustomer>;
  /** Updates an existing setting. */
  updateSetting: Setting;
  /** Update an existing subscription flow */
  updateSubscriptionFlow: Array<SubscriptionFlowModel>;
  /** Update an existing subscription interval */
  updateSubscriptionInterval: Array<SubscriptionFlowModel>;
  /** Updates an existing mail flow */
  updateSystemMail: Array<SystemMailModel>;
  /** This mutation allows to update the user's data by taking an input of type UserInput. */
  updateUser?: Maybe<User>;
  /**
   *
   *       Updates an existing userConsent based on input.
   *       Returns updated userConsent.
   *
   */
  updateUserConsent: UserConsent;
  /** This mutation allows to update the user's subscription by taking an input of type UserSubscription and throws an error if the user doesn't already have a subscription. Updating user subscriptions will set deactivation to null */
  updateUserSubscription?: Maybe<Subscription>;
  /** This mutation allows to upload and update the user's profile image. */
  uploadUserProfileImage?: Maybe<User>;
  /** This mutation allows to vote on a poll (or update one's decision). Supports logged in and anonymous */
  voteOnPoll?: Maybe<PollVote>;
};


export type MutationAddCommentArgs = {
  input: CommentInput;
};


export type MutationAddLikeArgs = {
  input: LikeCreateInput;
};


export type MutationCancelUserSubscriptionArgs = {
  id: Scalars['ID'];
};


export type MutationCreateBannerArgs = {
  input: CreateBannerInput;
};


export type MutationCreateBlockStyleArgs = {
  blocks: Array<BlockType>;
  name: Scalars['String'];
};


export type MutationCreateConsentArgs = {
  defaultValue: Scalars['Boolean'];
  name: Scalars['String'];
  slug: Scalars['String'];
};


export type MutationCreateEventArgs = {
  description?: InputMaybe<Scalars['RichText']>;
  endsAt?: InputMaybe<Scalars['DateTime']>;
  imageId?: InputMaybe<Scalars['String']>;
  lead?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  startsAt: Scalars['DateTime'];
  tagIds?: InputMaybe<Array<Scalars['String']>>;
};


export type MutationCreatePaymentFromInvoiceArgs = {
  input: PaymentFromInvoiceInput;
};


export type MutationCreatePaymentFromSubscriptionArgs = {
  failureURL?: InputMaybe<Scalars['String']>;
  subscriptionId?: InputMaybe<Scalars['ID']>;
  successURL?: InputMaybe<Scalars['String']>;
};


export type MutationCreateSessionArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};


export type MutationCreateSessionWithJwtArgs = {
  jwt: Scalars['String'];
};


export type MutationCreateSessionWithOAuth2CodeArgs = {
  code: Scalars['String'];
  name: Scalars['String'];
  redirectUri: Scalars['String'];
};


export type MutationCreateSubscriptionArgs = {
  autoRenew: Scalars['Boolean'];
  deactivateSubscriptionId?: InputMaybe<Scalars['ID']>;
  failureURL?: InputMaybe<Scalars['String']>;
  memberPlanID?: InputMaybe<Scalars['ID']>;
  memberPlanSlug?: InputMaybe<Scalars['Slug']>;
  monthlyAmount: Scalars['Int'];
  paymentMethodID?: InputMaybe<Scalars['ID']>;
  paymentMethodSlug?: InputMaybe<Scalars['Slug']>;
  paymentPeriodicity: PaymentPeriodicity;
  subscriptionProperties?: InputMaybe<Array<PublicPropertiesInput>>;
  successURL?: InputMaybe<Scalars['String']>;
};


export type MutationCreateSubscriptionFlowArgs = {
  autoRenewal: Array<Scalars['Boolean']>;
  memberPlanId: Scalars['String'];
  paymentMethodIds: Array<Scalars['String']>;
  periodicities: Array<PaymentPeriodicity>;
};


export type MutationCreateSubscriptionIntervalArgs = {
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  event: SubscriptionEvent;
  mailTemplateId?: InputMaybe<Scalars['String']>;
  subscriptionFlowId: Scalars['String'];
};


export type MutationCreateUserConsentArgs = {
  consentId: Scalars['String'];
  userId: Scalars['String'];
  value: Scalars['Boolean'];
};


export type MutationDeleteBannerArgs = {
  id: Scalars['String'];
};


export type MutationDeleteBlockStyleArgs = {
  id: Scalars['String'];
};


export type MutationDeleteConsentArgs = {
  id: Scalars['String'];
};


export type MutationDeleteEventArgs = {
  id: Scalars['String'];
};


export type MutationDeletePollVotesArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationDeleteSubscriptionFlowArgs = {
  id: Scalars['String'];
};


export type MutationDeleteSubscriptionIntervalArgs = {
  id: Scalars['String'];
};


export type MutationDeleteUserConsentArgs = {
  id: Scalars['String'];
};


export type MutationExtendSubscriptionArgs = {
  failureURL?: InputMaybe<Scalars['String']>;
  subscriptionId: Scalars['ID'];
  successURL?: InputMaybe<Scalars['String']>;
};


export type MutationImportEventArgs = {
  id: Scalars['String'];
  source: Scalars['String'];
};


export type MutationRateCommentArgs = {
  answerId: Scalars['ID'];
  commentId: Scalars['ID'];
  value: Scalars['Int'];
};


export type MutationRegisterMemberArgs = {
  address?: InputMaybe<UserAddressInput>;
  birthday?: InputMaybe<Scalars['DateTime']>;
  challengeAnswer: ChallengeInput;
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  password?: InputMaybe<Scalars['String']>;
};


export type MutationRegisterMemberAndReceivePaymentArgs = {
  address?: InputMaybe<UserAddressInput>;
  autoRenew: Scalars['Boolean'];
  birthday?: InputMaybe<Scalars['DateTime']>;
  challengeAnswer: ChallengeInput;
  email: Scalars['String'];
  failureURL?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  memberPlanID?: InputMaybe<Scalars['ID']>;
  memberPlanSlug?: InputMaybe<Scalars['Slug']>;
  monthlyAmount: Scalars['Int'];
  name: Scalars['String'];
  password?: InputMaybe<Scalars['String']>;
  paymentMethodID?: InputMaybe<Scalars['ID']>;
  paymentMethodSlug?: InputMaybe<Scalars['Slug']>;
  paymentPeriodicity: PaymentPeriodicity;
  subscriptionProperties?: InputMaybe<Array<PublicPropertiesInput>>;
  successURL?: InputMaybe<Scalars['String']>;
};


export type MutationRemoveLikeArgs = {
  input: LikeDeleteInput;
};


export type MutationSendWebsiteLoginArgs = {
  email: Scalars['String'];
};


export type MutationTestSystemMailArgs = {
  event: UserEvent;
};


export type MutationUpdateBannerArgs = {
  input: UpdateBannerInput;
};


export type MutationUpdateBlockStyleArgs = {
  blocks?: InputMaybe<Array<BlockType>>;
  id: Scalars['String'];
  name?: InputMaybe<Scalars['String']>;
};


export type MutationUpdateCommentArgs = {
  input: CommentUpdateInput;
};


export type MutationUpdateConsentArgs = {
  defaultValue?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['String'];
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type MutationUpdateEventArgs = {
  description?: InputMaybe<Scalars['RichText']>;
  endsAt?: InputMaybe<Scalars['DateTime']>;
  id: Scalars['String'];
  imageId?: InputMaybe<Scalars['String']>;
  lead?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  startsAt?: InputMaybe<Scalars['DateTime']>;
  tagIds?: InputMaybe<Array<Scalars['String']>>;
};


export type MutationUpdatePasswordArgs = {
  password: Scalars['String'];
  passwordRepeated: Scalars['String'];
};


export type MutationUpdatePaymentProviderCustomersArgs = {
  input: Array<PaymentProviderCustomerInput>;
};


export type MutationUpdateSettingArgs = {
  name: SettingName;
  value: Scalars['GraphQLSettingValueType'];
};


export type MutationUpdateSubscriptionFlowArgs = {
  autoRenewal?: InputMaybe<Array<Scalars['Boolean']>>;
  id: Scalars['String'];
  paymentMethodIds?: InputMaybe<Array<Scalars['String']>>;
  periodicities?: InputMaybe<Array<PaymentPeriodicity>>;
};


export type MutationUpdateSubscriptionIntervalArgs = {
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  id: Scalars['String'];
  mailTemplateId?: InputMaybe<Scalars['String']>;
};


export type MutationUpdateSystemMailArgs = {
  event: UserEvent;
  mailTemplateId: Scalars['String'];
};


export type MutationUpdateUserArgs = {
  input: UserInput;
};


export type MutationUpdateUserConsentArgs = {
  id: Scalars['String'];
  value: Scalars['Boolean'];
};


export type MutationUpdateUserSubscriptionArgs = {
  id: Scalars['ID'];
  input: SubscriptionInput;
};


export type MutationUploadUserProfileImageArgs = {
  uploadImageInput?: InputMaybe<UploadImageInput>;
};


export type MutationVoteOnPollArgs = {
  answerId: Scalars['ID'];
};

export type Navigation = {
  __typename?: 'Navigation';
  id: Scalars['ID'];
  key: Scalars['String'];
  links: Array<NavigationLink>;
  name: Scalars['String'];
};

export type NavigationLink = ArticleNavigationLink | ExternalNavigationLink | PageNavigationLink;

export type OAuth2Account = {
  __typename?: 'OAuth2Account';
  provider: Scalars['String'];
  scope: Scalars['String'];
  type: Scalars['String'];
};

export type Page = {
  __typename?: 'Page';
  blocks: Array<Block>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image?: Maybe<Image>;
  properties: Array<PublicProperties>;
  publishedAt: Scalars['DateTime'];
  slug: Scalars['Slug'];
  socialMediaDescription?: Maybe<Scalars['String']>;
  socialMediaImage?: Maybe<Image>;
  socialMediaTitle?: Maybe<Scalars['String']>;
  tags: Array<Tag>;
  title: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  url: Scalars['String'];
};

export type PageConnection = {
  __typename?: 'PageConnection';
  nodes: Array<Page>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['String']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['String']>;
};

export type PageModel = {
  __typename?: 'PageModel';
  id: Scalars['ID'];
};

export type PageModelInput = {
  id: Scalars['ID'];
};

export type PageNavigationLink = BaseNavigationLink & {
  __typename?: 'PageNavigationLink';
  label: Scalars['String'];
  page?: Maybe<Page>;
};

export type PageTeaser = {
  __typename?: 'PageTeaser';
  image?: Maybe<Image>;
  lead?: Maybe<Scalars['String']>;
  page?: Maybe<Page>;
  preTitle?: Maybe<Scalars['String']>;
  /** @deprecated Use block styles instead of this */
  style: TeaserStyle;
  title?: Maybe<Scalars['String']>;
};

export type PaginatedEvents = {
  __typename?: 'PaginatedEvents';
  nodes: Array<Event>;
  pageInfo: PageInfo;
  totalCount: Scalars['Float'];
};

export type PaginatedPollVotes = {
  __typename?: 'PaginatedPollVotes';
  nodes: Array<PollVote>;
  pageInfo: PageInfo;
  totalCount: Scalars['Float'];
};

export type Payment = {
  __typename?: 'Payment';
  id: Scalars['ID'];
  intentSecret?: Maybe<Scalars['String']>;
  paymentMethod: PaymentMethod;
  state: PaymentState;
};

export type PaymentFromInvoiceInput = {
  failureURL?: InputMaybe<Scalars['String']>;
  invoiceID: Scalars['ID'];
  paymentMethodID?: InputMaybe<Scalars['ID']>;
  paymentMethodSlug?: InputMaybe<Scalars['Slug']>;
  successURL?: InputMaybe<Scalars['String']>;
};

export type PaymentMethod = {
  __typename?: 'PaymentMethod';
  description: Scalars['String'];
  id: Scalars['ID'];
  image?: Maybe<Image>;
  imageId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  paymentProviderID: Scalars['String'];
  slug: Scalars['Slug'];
};

export enum PaymentPeriodicity {
  Biannual = 'biannual',
  Monthly = 'monthly',
  Quarterly = 'quarterly',
  Yearly = 'yearly'
}

export type PaymentProviderCustomer = {
  __typename?: 'PaymentProviderCustomer';
  customerID: Scalars['String'];
  paymentProviderID: Scalars['String'];
};

export type PaymentProviderCustomerInput = {
  customerID: Scalars['String'];
  paymentProviderID: Scalars['String'];
};

export enum PaymentState {
  Canceled = 'canceled',
  Created = 'created',
  Declined = 'declined',
  Paid = 'paid',
  Processing = 'processing',
  RequiresUserAction = 'requiresUserAction',
  Submitted = 'submitted'
}

export type Peer = {
  __typename?: 'Peer';
  createdAt: Scalars['DateTime'];
  hostURL: Scalars['String'];
  id: Scalars['ID'];
  isDisabled?: Maybe<Scalars['Boolean']>;
  modifiedAt: Scalars['DateTime'];
  name: Scalars['String'];
  profile?: Maybe<PeerProfile>;
  slug: Scalars['String'];
};

export type PeerArticleTeaser = {
  __typename?: 'PeerArticleTeaser';
  article?: Maybe<Article>;
  articleID: Scalars['ID'];
  image?: Maybe<Image>;
  lead?: Maybe<Scalars['String']>;
  peer?: Maybe<Peer>;
  preTitle?: Maybe<Scalars['String']>;
  /** @deprecated Use block styles instead of this */
  style: TeaserStyle;
  title?: Maybe<Scalars['String']>;
};

export type PeerProfile = {
  __typename?: 'PeerProfile';
  callToActionImage?: Maybe<Image>;
  callToActionImageURL?: Maybe<Scalars['String']>;
  callToActionText: Scalars['RichText'];
  callToActionURL: Scalars['String'];
  hostURL: Scalars['String'];
  logo?: Maybe<Image>;
  name: Scalars['String'];
  themeColor: Scalars['Color'];
  themeFontColor: Scalars['Color'];
  websiteURL: Scalars['String'];
};

export type PeriodicJob = {
  __typename?: 'PeriodicJob';
  createdAt: Scalars['DateTime'];
  date: Scalars['DateTime'];
  error?: Maybe<Scalars['String']>;
  executionTime?: Maybe<Scalars['DateTime']>;
  finishedWithError?: Maybe<Scalars['DateTime']>;
  id: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  successfullyFinished?: Maybe<Scalars['DateTime']>;
  tries: Scalars['Float'];
};

export type Phrase = {
  __typename?: 'Phrase';
  articles?: Maybe<PhraseResultArticleContent>;
  pages?: Maybe<PhraseResultPageContent>;
};

export type PhraseResultArticleContent = {
  __typename?: 'PhraseResultArticleContent';
  nodes: Array<Article>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PhraseResultPageContent = {
  __typename?: 'PhraseResultPageContent';
  nodes: Array<Page>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type PolisConversationBlock = {
  __typename?: 'PolisConversationBlock';
  blockStyle?: Maybe<Scalars['String']>;
  conversationID: Scalars['String'];
};

export type PollAnswerInVote = {
  __typename?: 'PollAnswerInVote';
  answer: Scalars['String'];
  id: Scalars['ID'];
};

export type PollAnswerWithVoteCount = {
  __typename?: 'PollAnswerWithVoteCount';
  answer?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  pollId: Scalars['ID'];
  votes: Scalars['Int'];
};

export type PollBlock = {
  __typename?: 'PollBlock';
  blockStyle?: Maybe<Scalars['String']>;
  poll?: Maybe<FullPoll>;
};

export type PollExternalVote = {
  __typename?: 'PollExternalVote';
  amount: Scalars['VoteValue'];
  answerId: Scalars['ID'];
  id: Scalars['ID'];
};

export type PollExternalVoteSource = {
  __typename?: 'PollExternalVoteSource';
  id: Scalars['ID'];
  source?: Maybe<Scalars['String']>;
  voteAmounts: Array<PollExternalVote>;
};

export type PollVote = {
  __typename?: 'PollVote';
  answer: PollAnswerInVote;
  answerId: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  disabled: Scalars['Boolean'];
  fingerprint?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  pollId: Scalars['ID'];
  userId?: Maybe<Scalars['ID']>;
};

export type PollVoteFilter = {
  answerIds?: InputMaybe<Array<Scalars['String']>>;
  fingerprint?: InputMaybe<Scalars['String']>;
  from?: InputMaybe<Scalars['DateTime']>;
  pollId?: InputMaybe<Scalars['String']>;
  to?: InputMaybe<Scalars['DateTime']>;
  userId?: InputMaybe<Scalars['String']>;
};

export enum PollVoteSort {
  CreatedAt = 'CreatedAt'
}

export type PublicProperties = {
  __typename?: 'PublicProperties';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type PublicPropertiesInput = {
  key: Scalars['String'];
  value: Scalars['String'];
};

export type PublishedPageFilter = {
  tags?: InputMaybe<Array<Scalars['String']>>;
};

export enum PublishedPageSort {
  PublishedAt = 'publishedAt',
  UpdatedAt = 'updatedAt'
}

export type Query = {
  __typename?: 'Query';
  _entities: Array<Maybe<_Entity>>;
  _service: _Service;
  /**
   *
   *       Returns all active subscribers.
   *       Includes subscribers with a cancelled but not run out subscription.
   *
   */
  activeSubscribers: Array<DashboardSubscription>;
  /** This query takes either the ID, slug or token and returns the article. */
  article?: Maybe<Article>;
  /** This query returns the articles. */
  articles: ArticleConnection;
  /** This query returns the redirect Uri. */
  authProviders: Array<AuthProvider>;
  /** This query takes either the ID or the slug and returns the author. */
  author?: Maybe<Author>;
  /** This query is to get the authors. */
  authors: AuthorConnection;
  banner: Banner;
  banners: Array<Banner>;
  /** Returns a list of block styles. */
  blockStyles: Array<BlockStyle>;
  /** This query generates a challenge which can be used to access protected endpoints. */
  challenge: Challenge;
  /** This mutation will check the invoice status and update with information from the paymentProvider */
  checkInvoiceStatus?: Maybe<Invoice>;
  /** This query returns the comments of an item. */
  comments: Array<Comment>;
  /**
   *
   *       Returns a consent by id.
   *
   */
  consent: Consent;
  /**
   *
   *       Returns all consents.
   *
   */
  consents: Array<Consent>;
  /** Returns a event by id. */
  event: Event;
  /**
   *
   *       Returns a list of Importable Event Providers
   *
   */
  eventProviders: Array<Scalars['String']>;
  /** Returns a paginated list of events based on the filters given. */
  events: PaginatedEvents;
  /**
   *
   *       Returns the expected revenue for the time period given.
   *       Excludes cancelled or manually set as paid invoices.
   *
   */
  expectedRevenue: Array<DashboardInvoice>;
  /** Returns an image by id. */
  getImage: ImageV2;
  /**
   *
   *       Returns the most viewed articles in descending order.
   *
   */
  hotAndTrending: Array<Article>;
  /**
   *
   *       Returns a more detailed version of a single importable event, by id and source.
   *
   */
  importedEvent: EventFromSource;
  /**
   *
   *       Returns a list of imported events from external sources, transformed to match our model.
   *
   */
  importedEvents: ImportedEventsDocument;
  /**
   *
   *       Returns a list of external source ids of already imported events.
   *
   */
  importedEventsIds: Array<Scalars['String']>;
  /** This query returns the invoices  of the authenticated user. */
  invoices: Array<Invoice>;
  /** Return all mail templates */
  mailTemplates: Array<MailTemplateWithUrlAndStatusModel>;
  /** This query returns the user. */
  me?: Maybe<User>;
  /** This query returns a member plan. */
  memberPlan?: Maybe<MemberPlan>;
  /** This query returns the member plans. */
  memberPlans: MemberPlanConnection;
  /** This query takes either the ID or the key and returns the navigation. */
  navigation?: Maybe<Navigation>;
  /** This query returns all navigations. */
  navigations?: Maybe<Array<Navigation>>;
  /**
   *
   *       Returns all new deactivations in a given timeframe.
   *       This considers the time the deactivation was made, not when the subscription runs out.
   *
   */
  newDeactivations: Array<DashboardSubscription>;
  /**
   *
   *       Returns all new subscribers in a given timeframe.
   *       Includes already deactivated ones.
   *
   */
  newSubscribers: Array<DashboardSubscription>;
  /** This query takes either the ID, slug or token and returns the page. */
  page?: Maybe<Page>;
  /** This query returns the pages. */
  pages: PageConnection;
  /** Returns all payment methods */
  paymentMethods: Array<PaymentMethod>;
  /** This query takes either the ID or the slug and returns the peer profile. */
  peer?: Maybe<Peer>;
  /** This query takes either the peer ID or the peer slug and returns the article. */
  peerArticle?: Maybe<Article>;
  /** This query returns the peer profile. */
  peerProfile: PeerProfile;
  periodicJobLog: Array<PeriodicJob>;
  /** This query performs a fulltext search on titles and blocks of articles/pages and returns all matching ones. */
  phrase?: Maybe<Phrase>;
  /** This query returns a poll with all the needed data */
  poll: FullPoll;
  /** Returns a paginated list of poll votes */
  pollVotes: PaginatedPollVotes;
  primaryBanner: Banner;
  provider: MailProviderModel;
  ratingSystem: FullCommentRatingSystem;
  /**
   *
   *       Returns all renewing subscribers in a given timeframe.
   *
   */
  renewingSubscribers: Array<DashboardSubscription>;
  /**
   *
   *       Returns the revenue generated for the time period given.
   *       Only includes paid invoices that have not been manually paid.
   *
   */
  revenue: Array<DashboardInvoice>;
  /**
   *
   *       Returns a single setting by name.
   *
   */
  setting: Setting;
  /**
   *
   *       Returns a single setting by id.
   *
   */
  settingById: Setting;
  /**
   *
   *       Returns all settings.
   *
   */
  settings: Array<Setting>;
  stats?: Maybe<Stats>;
  /** Returns all subscription flows */
  subscriptionFlows: Array<SubscriptionFlowModel>;
  /** This query returns the subscriptions of the authenticated user. */
  subscriptions: Array<Subscription>;
  /** Returns all mail flows */
  systemMails: Array<SystemMailModel>;
  /** This query returns a list of tags */
  tags?: Maybe<TagConnection>;
  /**
   *
   *       Returns a single userConsent by id.
   *
   */
  userConsent: UserConsent;
  /**
   *
   *       Returns a list of userConsents. Possible to filter.
   *
   */
  userConsents: Array<UserConsent>;
  /** This query returns the answerId of a poll if the user has already voted on it. */
  userPollVote?: Maybe<Scalars['ID']>;
  versionInformation: VersionInformation;
};


export type Query_EntitiesArgs = {
  representations: Array<Scalars['_Any']>;
};


export type QueryArticleArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['Slug']>;
  token?: InputMaybe<Scalars['String']>;
};


export type QueryArticlesArgs = {
  cursor?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<ArticleFilter>;
  order?: InputMaybe<SortOrder>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ArticleSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryAuthProvidersArgs = {
  redirectUri?: InputMaybe<Scalars['String']>;
};


export type QueryAuthorArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['Slug']>;
};


export type QueryAuthorsArgs = {
  cursor?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<AuthorFilter>;
  order?: InputMaybe<SortOrder>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<AuthorSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryBannerArgs = {
  id: Scalars['String'];
};


export type QueryBannersArgs = {
  skip: Scalars['Int'];
  take: Scalars['Int'];
};


export type QueryCheckInvoiceStatusArgs = {
  id: Scalars['ID'];
};


export type QueryCommentsArgs = {
  itemId: Scalars['ID'];
  order?: InputMaybe<SortOrder>;
  sort?: InputMaybe<CommentSort>;
};


export type QueryConsentArgs = {
  id: Scalars['String'];
};


export type QueryConsentsArgs = {
  filter?: InputMaybe<ConsentFilter>;
};


export type QueryEventArgs = {
  id: Scalars['ID'];
};


export type QueryEventsArgs = {
  cursorId?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<EventFilter>;
  order?: InputMaybe<SortOrder>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<EventSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryExpectedRevenueArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryGetImageArgs = {
  id: Scalars['String'];
};


export type QueryHotAndTrendingArgs = {
  start?: InputMaybe<Scalars['DateTime']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryImportedEventArgs = {
  filter: SingleEventFilter;
};


export type QueryImportedEventsArgs = {
  filter?: InputMaybe<ImportedEventFilter>;
  order?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ImportedEventSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryMemberPlanArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['Slug']>;
};


export type QueryMemberPlansArgs = {
  cursor?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<MemberPlanFilter>;
  order?: InputMaybe<SortOrder>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<MemberPlanSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryNavigationArgs = {
  id?: InputMaybe<Scalars['ID']>;
  key?: InputMaybe<Scalars['ID']>;
};


export type QueryNewDeactivationsArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryNewSubscribersArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryPageArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['Slug']>;
  token?: InputMaybe<Scalars['String']>;
};


export type QueryPagesArgs = {
  cursor?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<PublishedPageFilter>;
  order?: InputMaybe<SortOrder>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<PublishedPageSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryPeerArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['Slug']>;
};


export type QueryPeerArticleArgs = {
  id: Scalars['ID'];
  peerID?: InputMaybe<Scalars['ID']>;
  peerSlug?: InputMaybe<Scalars['Slug']>;
};


export type QueryPeriodicJobLogArgs = {
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryPhraseArgs = {
  articleSort?: InputMaybe<ArticleSort>;
  order?: InputMaybe<SortOrder>;
  pageSort?: InputMaybe<PublishedPageSort>;
  query: Scalars['String'];
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryPollArgs = {
  id: Scalars['ID'];
};


export type QueryPollVotesArgs = {
  cursorId?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<PollVoteFilter>;
  order?: InputMaybe<SortOrder>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<PollVoteSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryPrimaryBannerArgs = {
  documentId: Scalars['ID'];
  documentType: BannerDocumentType;
};


export type QueryRenewingSubscribersArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QueryRevenueArgs = {
  end?: InputMaybe<Scalars['DateTime']>;
  start: Scalars['DateTime'];
};


export type QuerySettingArgs = {
  name: Scalars['String'];
};


export type QuerySettingByIdArgs = {
  id: Scalars['String'];
};


export type QuerySettingsArgs = {
  filter?: InputMaybe<SettingFilter>;
};


export type QuerySubscriptionFlowsArgs = {
  defaultFlowOnly: Scalars['Boolean'];
  memberPlanId?: InputMaybe<Scalars['String']>;
};


export type QueryTagsArgs = {
  cursor?: InputMaybe<Scalars['ID']>;
  filter?: InputMaybe<TagFilter>;
  order?: InputMaybe<SortOrder>;
  skip?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<TagSort>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryUserConsentArgs = {
  id: Scalars['String'];
};


export type QueryUserConsentsArgs = {
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['Boolean']>;
};


export type QueryUserPollVoteArgs = {
  pollId: Scalars['ID'];
};

export type QuoteBlock = {
  __typename?: 'QuoteBlock';
  author?: Maybe<Scalars['String']>;
  blockStyle?: Maybe<Scalars['String']>;
  image?: Maybe<Image>;
  quote?: Maybe<Scalars['String']>;
};

export enum RatingSystemType {
  Star = 'star'
}

export type Registration = {
  __typename?: 'Registration';
  session: UserSession;
  user: User;
};

export type RegistrationAndPayment = {
  __typename?: 'RegistrationAndPayment';
  payment: Payment;
  session: UserSession;
  user: User;
};

export type RichTextBlock = {
  __typename?: 'RichTextBlock';
  blockStyle?: Maybe<Scalars['String']>;
  richText: Scalars['RichText'];
};

export type SessionWithToken = {
  __typename?: 'SessionWithToken';
  createdAt: Scalars['DateTime'];
  expiresAt: Scalars['DateTime'];
  token: Scalars['String'];
  user: User;
};

export type Setting = {
  __typename?: 'Setting';
  id: Scalars['ID'];
  name: SettingName;
  settingRestriction?: Maybe<SettingRestriction>;
  value?: Maybe<Scalars['GraphQLSettingValueType']>;
};

export type SettingFilter = {
  name?: InputMaybe<Scalars['String']>;
};

export enum SettingName {
  AllowCommentEditing = 'ALLOW_COMMENT_EDITING',
  AllowGuestCommenting = 'ALLOW_GUEST_COMMENTING',
  AllowGuestCommentRating = 'ALLOW_GUEST_COMMENT_RATING',
  AllowGuestPollVoting = 'ALLOW_GUEST_POLL_VOTING',
  CommentCharLimit = 'COMMENT_CHAR_LIMIT',
  MailProviderName = 'MAIL_PROVIDER_NAME',
  MakeActiveSubscribersApiPublic = 'MAKE_ACTIVE_SUBSCRIBERS_API_PUBLIC',
  MakeExpectedRevenueApiPublic = 'MAKE_EXPECTED_REVENUE_API_PUBLIC',
  MakeNewDeactivationsApiPublic = 'MAKE_NEW_DEACTIVATIONS_API_PUBLIC',
  MakeNewSubscribersApiPublic = 'MAKE_NEW_SUBSCRIBERS_API_PUBLIC',
  MakeRenewingSubscribersApiPublic = 'MAKE_RENEWING_SUBSCRIBERS_API_PUBLIC',
  MakeRevenueApiPublic = 'MAKE_REVENUE_API_PUBLIC',
  PeeringTimeoutMs = 'PEERING_TIMEOUT_MS',
  ResetPasswordJwtExpiresMin = 'RESET_PASSWORD_JWT_EXPIRES_MIN',
  SendLoginJwtExpiresMin = 'SEND_LOGIN_JWT_EXPIRES_MIN'
}

export type SettingRestriction = {
  __typename?: 'SettingRestriction';
  allowedValues?: Maybe<AllowedSettingVals>;
  inputLength?: Maybe<Scalars['Int']>;
  maxValue?: Maybe<Scalars['Int']>;
  minValue?: Maybe<Scalars['Int']>;
};

export type SingleEventFilter = {
  id: Scalars['String'];
  source: Scalars['String'];
};

export enum SortOrder {
  Ascending = 'Ascending',
  Descending = 'Descending'
}

export type SoundCloudTrackBlock = {
  __typename?: 'SoundCloudTrackBlock';
  blockStyle?: Maybe<Scalars['String']>;
  trackID: Scalars['String'];
};

export type Stats = {
  __typename?: 'Stats';
  articlesCount: Scalars['Int'];
  authorsCount: Scalars['Int'];
  firstArticleDate?: Maybe<Scalars['DateTime']>;
};

export type Subscription = {
  __typename?: 'Subscription';
  autoRenew: Scalars['Boolean'];
  deactivation?: Maybe<SubscriptionDeactivation>;
  extendable: Scalars['Boolean'];
  id: Scalars['ID'];
  memberPlan: MemberPlan;
  monthlyAmount: Scalars['Int'];
  paidUntil?: Maybe<Scalars['DateTime']>;
  paymentMethod: PaymentMethod;
  paymentPeriodicity: PaymentPeriodicity;
  properties: Array<PublicProperties>;
  startsAt: Scalars['DateTime'];
  url: Scalars['String'];
};

export type SubscriptionDeactivation = {
  __typename?: 'SubscriptionDeactivation';
  date: Scalars['DateTime'];
  reason: SubscriptionDeactivationReason;
};

export enum SubscriptionDeactivationReason {
  InvoiceNotPaid = 'invoiceNotPaid',
  None = 'none',
  UserSelfDeactivated = 'userSelfDeactivated'
}

export enum SubscriptionEvent {
  Custom = 'CUSTOM',
  DeactivationByUser = 'DEACTIVATION_BY_USER',
  DeactivationUnpaid = 'DEACTIVATION_UNPAID',
  InvoiceCreation = 'INVOICE_CREATION',
  RenewalFailed = 'RENEWAL_FAILED',
  RenewalSuccess = 'RENEWAL_SUCCESS',
  Resubscribe = 'RESUBSCRIBE',
  Subscribe = 'SUBSCRIBE'
}

export type SubscriptionFlowModel = {
  __typename?: 'SubscriptionFlowModel';
  autoRenewal: Array<Scalars['Boolean']>;
  default: Scalars['Boolean'];
  id: Scalars['String'];
  intervals: Array<SubscriptionInterval>;
  memberPlan?: Maybe<MemberPlan>;
  numberOfSubscriptions: Scalars['Int'];
  paymentMethods: Array<PaymentMethod>;
  periodicities: Array<PaymentPeriodicity>;
};

export type SubscriptionInput = {
  autoRenew: Scalars['Boolean'];
  id: Scalars['ID'];
  memberPlanID: Scalars['String'];
  monthlyAmount: Scalars['Int'];
  paymentMethodID: Scalars['String'];
  paymentPeriodicity: PaymentPeriodicity;
};

export type SubscriptionInterval = {
  __typename?: 'SubscriptionInterval';
  daysAwayFromEnding?: Maybe<Scalars['Int']>;
  event: SubscriptionEvent;
  id: Scalars['String'];
  mailTemplate?: Maybe<MailTemplateRef>;
};

export type SystemMailModel = {
  __typename?: 'SystemMailModel';
  event: UserEvent;
  mailTemplate?: Maybe<MailTemplateRef>;
};

export type Tag = {
  __typename?: 'Tag';
  id: Scalars['ID'];
  main: Scalars['Boolean'];
  tag?: Maybe<Scalars['String']>;
  type?: Maybe<TagType>;
  url: Scalars['String'];
};

export type TagConnection = {
  __typename?: 'TagConnection';
  nodes: Array<Tag>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type TagFilter = {
  tag?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<TagType>;
};

export enum TagSort {
  CreatedAt = 'CreatedAt',
  ModifiedAt = 'ModifiedAt',
  Tag = 'Tag'
}

export enum TagType {
  Article = 'Article',
  Author = 'Author',
  Comment = 'Comment',
  Event = 'Event',
  Page = 'Page'
}

export type Teaser = ArticleTeaser | CustomTeaser | EventTeaser | PageTeaser | PeerArticleTeaser;

export type TeaserGridBlock = {
  __typename?: 'TeaserGridBlock';
  blockStyle?: Maybe<Scalars['String']>;
  numColumns: Scalars['Int'];
  teasers: Array<Maybe<Teaser>>;
};

export type TeaserGridFlexBlock = {
  __typename?: 'TeaserGridFlexBlock';
  blockStyle?: Maybe<Scalars['String']>;
  flexTeasers: Array<FlexTeaser>;
};

export type TeaserListBlock = {
  __typename?: 'TeaserListBlock';
  blockStyle?: Maybe<Scalars['String']>;
  filter: TeaserListBlockFilter;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  teaserType?: Maybe<TeaserType>;
  teasers: Array<Maybe<Teaser>>;
  title?: Maybe<Scalars['String']>;
};

export type TeaserListBlockFilter = {
  __typename?: 'TeaserListBlockFilter';
  tagObjects: Array<Tag>;
  tags?: Maybe<Array<Scalars['ID']>>;
};

export enum TeaserStyle {
  Default = 'default',
  Light = 'light',
  Text = 'text'
}

export enum TeaserType {
  Article = 'article',
  Custom = 'custom',
  Event = 'event',
  Page = 'page',
  PeerArticle = 'peerArticle'
}

export type TikTokVideoBlock = {
  __typename?: 'TikTokVideoBlock';
  blockStyle?: Maybe<Scalars['String']>;
  userID: Scalars['String'];
  videoID: Scalars['String'];
};

export type TitleBlock = {
  __typename?: 'TitleBlock';
  blockStyle?: Maybe<Scalars['String']>;
  lead?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
};

export type TwitterTweetBlock = {
  __typename?: 'TwitterTweetBlock';
  blockStyle?: Maybe<Scalars['String']>;
  tweetID: Scalars['String'];
  userID: Scalars['String'];
};

export type UpdateBannerInput = {
  actions?: InputMaybe<Array<CreateBannerActionInput>>;
  active: Scalars['Boolean'];
  cta?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  imageId?: InputMaybe<Scalars['String']>;
  showOnArticles: Scalars['Boolean'];
  showOnPages?: InputMaybe<Array<PageModelInput>>;
  text: Scalars['String'];
  title: Scalars['String'];
};

export type UploadImageInput = {
  description?: InputMaybe<Scalars['String']>;
  file: Scalars['Upload'];
  filename?: InputMaybe<Scalars['String']>;
  focalPoint?: InputMaybe<InputPoint>;
  license?: InputMaybe<Scalars['String']>;
  link?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Array<Scalars['String']>>;
  title?: InputMaybe<Scalars['String']>;
};

export type User = {
  __typename?: 'User';
  address?: Maybe<UserAddress>;
  birthday?: Maybe<Scalars['DateTime']>;
  email: Scalars['String'];
  emailVerifiedAt?: Maybe<Scalars['DateTime']>;
  firstName?: Maybe<Scalars['String']>;
  flair?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  image?: Maybe<Image>;
  lastLogin?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  oauth2Accounts: Array<OAuth2Account>;
  paymentProviderCustomers: Array<PaymentProviderCustomer>;
  properties: Array<PublicProperties>;
  roleIDs?: Maybe<Array<Scalars['String']>>;
  userImageID?: Maybe<Scalars['String']>;
};

export type UserAddress = {
  __typename?: 'UserAddress';
  city?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  streetAddress?: Maybe<Scalars['String']>;
  streetAddress2?: Maybe<Scalars['String']>;
  zipCode?: Maybe<Scalars['String']>;
};

export type UserAddressInput = {
  city?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  streetAddress?: InputMaybe<Scalars['String']>;
  streetAddress2?: InputMaybe<Scalars['String']>;
  zipCode?: InputMaybe<Scalars['String']>;
};

export type UserConsent = {
  __typename?: 'UserConsent';
  consent: Consent;
  createdAt: Scalars['DateTime'];
  id: Scalars['String'];
  modifiedAt: Scalars['DateTime'];
  user: User;
  value: Scalars['Boolean'];
};

export enum UserEvent {
  AccountCreation = 'ACCOUNT_CREATION',
  LoginLink = 'LOGIN_LINK',
  PasswordReset = 'PASSWORD_RESET',
  TestMail = 'TEST_MAIL'
}

export type UserInput = {
  address?: InputMaybe<UserAddressInput>;
  birthday?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  firstName?: InputMaybe<Scalars['String']>;
  flair?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  uploadImageInput?: InputMaybe<UploadImageInput>;
};

export type UserSession = {
  __typename?: 'UserSession';
  createdAt: Scalars['DateTime'];
  expiresAt: Scalars['DateTime'];
  token: Scalars['String'];
};

export type VersionInformation = {
  __typename?: 'VersionInformation';
  version: Scalars['String'];
};

export type VimeoVideoBlock = {
  __typename?: 'VimeoVideoBlock';
  blockStyle?: Maybe<Scalars['String']>;
  videoID: Scalars['String'];
};

export type YouTubeVideoBlock = {
  __typename?: 'YouTubeVideoBlock';
  blockStyle?: Maybe<Scalars['String']>;
  videoID: Scalars['String'];
};

export type _Entity = Article | Event | Image | MemberPlan | Page | PaymentMethod | PollVote | Tag | User;

export type _Service = {
  __typename?: '_Service';
  sdl?: Maybe<Scalars['String']>;
};

export type OverriddenRating = {
  __typename?: 'overriddenRating';
  answerId: Scalars['ID'];
  value?: Maybe<Scalars['Int']>;
};

export type BannersQueryVariables = Exact<{
  take: Scalars['Int'];
  skip: Scalars['Int'];
}>;


export type BannersQuery = { __typename?: 'Query', banners: Array<{ __typename?: 'Banner', id: string, title: string, text: string, cta?: string | null, active: boolean, showOnArticles: boolean, showOnPages?: Array<{ __typename?: 'PageModel', id: string }> | null, image?: { __typename?: 'Image', id: string, filename?: string | null, extension: string, title?: string | null, description?: string | null, width: number, height: number, url?: string | null, largeURL?: string | null, mediumURL?: string | null, thumbURL?: string | null, squareURL?: string | null, previewURL?: string | null, column1URL?: string | null, column6URL?: string | null } | null, actions?: Array<{ __typename?: 'BannerAction', id: string, label: string, url: string, style: string, role: BannerActionRole }> | null }> };

export type BannerQueryVariables = Exact<{
  id: Scalars['String'];
}>;


export type BannerQuery = { __typename?: 'Query', banner: { __typename?: 'Banner', id: string, title: string, text: string, cta?: string | null, active: boolean, showOnArticles: boolean, showOnPages?: Array<{ __typename?: 'PageModel', id: string }> | null, image?: { __typename?: 'Image', id: string, filename?: string | null, extension: string, title?: string | null, description?: string | null, width: number, height: number, url?: string | null, largeURL?: string | null, mediumURL?: string | null, thumbURL?: string | null, squareURL?: string | null, previewURL?: string | null, column1URL?: string | null, column6URL?: string | null } | null, actions?: Array<{ __typename?: 'BannerAction', id: string, label: string, url: string, style: string, role: BannerActionRole }> | null } };

export type CreateBannerMutationVariables = Exact<{
  input: CreateBannerInput;
}>;


export type CreateBannerMutation = { __typename?: 'Mutation', createBanner: { __typename?: 'Banner', id: string, title: string, text: string, cta?: string | null, active: boolean, showOnArticles: boolean, showOnPages?: Array<{ __typename?: 'PageModel', id: string }> | null, image?: { __typename?: 'Image', id: string, filename?: string | null, extension: string, title?: string | null, description?: string | null, width: number, height: number, url?: string | null, largeURL?: string | null, mediumURL?: string | null, thumbURL?: string | null, squareURL?: string | null, previewURL?: string | null, column1URL?: string | null, column6URL?: string | null } | null, actions?: Array<{ __typename?: 'BannerAction', id: string, label: string, url: string, style: string, role: BannerActionRole }> | null } };

export type UpdateBannerMutationVariables = Exact<{
  input: UpdateBannerInput;
}>;


export type UpdateBannerMutation = { __typename?: 'Mutation', updateBanner: { __typename?: 'Banner', id: string, title: string, text: string, cta?: string | null, active: boolean, showOnArticles: boolean, showOnPages?: Array<{ __typename?: 'PageModel', id: string }> | null, image?: { __typename?: 'Image', id: string, filename?: string | null, extension: string, title?: string | null, description?: string | null, width: number, height: number, url?: string | null, largeURL?: string | null, mediumURL?: string | null, thumbURL?: string | null, squareURL?: string | null, previewURL?: string | null, column1URL?: string | null, column6URL?: string | null } | null, actions?: Array<{ __typename?: 'BannerAction', id: string, label: string, url: string, style: string, role: BannerActionRole }> | null } };

export type DeleteBannerMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteBannerMutation = { __typename?: 'Mutation', deleteBanner?: boolean | null };

export type PageRefFragment = { __typename?: 'PageModel', id: string };

export type FullBannerFragment = { __typename?: 'Banner', id: string, title: string, text: string, cta?: string | null, active: boolean, showOnArticles: boolean, showOnPages?: Array<{ __typename?: 'PageModel', id: string }> | null, image?: { __typename?: 'Image', id: string, filename?: string | null, extension: string, title?: string | null, description?: string | null, width: number, height: number, url?: string | null, largeURL?: string | null, mediumURL?: string | null, thumbURL?: string | null, squareURL?: string | null, previewURL?: string | null, column1URL?: string | null, column6URL?: string | null } | null, actions?: Array<{ __typename?: 'BannerAction', id: string, label: string, url: string, style: string, role: BannerActionRole }> | null };

export type FullBannerActionFragment = { __typename?: 'BannerAction', id: string, label: string, url: string, style: string, role: BannerActionRole };

export type ImageUrLsFragment = { __typename?: 'Image', url?: string | null, largeURL?: string | null, mediumURL?: string | null, thumbURL?: string | null, squareURL?: string | null, previewURL?: string | null, column1URL?: string | null, column6URL?: string | null };

export type ImageRefFragment = { __typename?: 'Image', id: string, filename?: string | null, extension: string, title?: string | null, description?: string | null, width: number, height: number, url?: string | null, largeURL?: string | null, mediumURL?: string | null, thumbURL?: string | null, squareURL?: string | null, previewURL?: string | null, column1URL?: string | null, column6URL?: string | null };

export type FullBlockStyleFragment = { __typename?: 'BlockStyle', id: string, createdAt: string, modifiedAt: string, name: string, blocks: Array<BlockType> };

export type BlockStylesQueryVariables = Exact<{ [key: string]: never; }>;


export type BlockStylesQuery = { __typename?: 'Query', blockStyles: Array<{ __typename?: 'BlockStyle', id: string, createdAt: string, modifiedAt: string, name: string, blocks: Array<BlockType> }> };

export type CreateBlockStyleMutationVariables = Exact<{
  name: Scalars['String'];
  blocks: Array<BlockType> | BlockType;
}>;


export type CreateBlockStyleMutation = { __typename?: 'Mutation', createBlockStyle: { __typename?: 'BlockStyle', id: string, createdAt: string, modifiedAt: string, name: string, blocks: Array<BlockType> } };

export type UpdateBlockStyleMutationVariables = Exact<{
  id: Scalars['String'];
  name?: InputMaybe<Scalars['String']>;
  blocks: Array<BlockType> | BlockType;
}>;


export type UpdateBlockStyleMutation = { __typename?: 'Mutation', updateBlockStyle: { __typename?: 'BlockStyle', id: string, createdAt: string, modifiedAt: string, name: string, blocks: Array<BlockType> } };

export type DeleteBlockStyleMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteBlockStyleMutation = { __typename?: 'Mutation', deleteBlockStyle: { __typename?: 'BlockStyle', id: string, createdAt: string, modifiedAt: string, name: string, blocks: Array<BlockType> } };

export type FullConsentFragment = { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string };

export type FullUserConsentFragment = { __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } };

export type ConsentsQueryVariables = Exact<{ [key: string]: never; }>;


export type ConsentsQuery = { __typename?: 'Query', consents: Array<{ __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }> };

export type ConsentQueryVariables = Exact<{
  id: Scalars['String'];
}>;


export type ConsentQuery = { __typename?: 'Query', consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string } };

export type CreateConsentMutationVariables = Exact<{
  name: Scalars['String'];
  slug: Scalars['String'];
  defaultValue: Scalars['Boolean'];
}>;


export type CreateConsentMutation = { __typename?: 'Mutation', createConsent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string } };

export type UpdateConsentMutationVariables = Exact<{
  id: Scalars['String'];
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  defaultValue?: InputMaybe<Scalars['Boolean']>;
}>;


export type UpdateConsentMutation = { __typename?: 'Mutation', updateConsent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string } };

export type DeleteConsentMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteConsentMutation = { __typename?: 'Mutation', deleteConsent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string } };

export type UserConsentsQueryVariables = Exact<{ [key: string]: never; }>;


export type UserConsentsQuery = { __typename?: 'Query', userConsents: Array<{ __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } }> };

export type UserConsentQueryVariables = Exact<{
  id: Scalars['String'];
}>;


export type UserConsentQuery = { __typename?: 'Query', userConsent: { __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } } };

export type CreateUserConsentMutationVariables = Exact<{
  consentId: Scalars['String'];
  userId: Scalars['String'];
  value: Scalars['Boolean'];
}>;


export type CreateUserConsentMutation = { __typename?: 'Mutation', createUserConsent: { __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } } };

export type UpdateUserConsentMutationVariables = Exact<{
  id: Scalars['String'];
  value: Scalars['Boolean'];
}>;


export type UpdateUserConsentMutation = { __typename?: 'Mutation', updateUserConsent: { __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } } };

export type DeleteUserConsentMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteUserConsentMutation = { __typename?: 'Mutation', deleteUserConsent: { __typename?: 'UserConsent', id: string, value: boolean, createdAt: string, modifiedAt: string, consent: { __typename?: 'Consent', id: string, name: string, slug: string, defaultValue: boolean, createdAt: string, modifiedAt: string }, user: { __typename?: 'User', id: string, name: string, firstName?: string | null, email: string } } };

export type ImportableEventRefFragment = { __typename?: 'EventFromSource', id: string, name: string, description?: Node[] | null, status: EventStatus, location?: string | null, externalSourceId?: string | null, externalSourceName?: string | null, imageUrl?: string | null, startsAt: string, endsAt?: string | null };

export type ImportedEventListQueryVariables = Exact<{
  filter?: InputMaybe<ImportedEventFilter>;
  order?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ImportedEventSort>;
}>;


export type ImportedEventListQuery = { __typename?: 'Query', importedEvents: { __typename?: 'ImportedEventsDocument', totalCount: number, nodes: Array<{ __typename?: 'EventFromSource', id: string, name: string, description?: Node[] | null, status: EventStatus, location?: string | null, externalSourceId?: string | null, externalSourceName?: string | null, imageUrl?: string | null, startsAt: string, endsAt?: string | null }>, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null, hasNextPage: boolean, hasPreviousPage: boolean } } };

export type ImportedEventQueryVariables = Exact<{
  filter: SingleEventFilter;
}>;


export type ImportedEventQuery = { __typename?: 'Query', importedEvent: { __typename?: 'EventFromSource', id: string, name: string, description?: Node[] | null, status: EventStatus, location?: string | null, externalSourceId?: string | null, externalSourceName?: string | null, imageUrl?: string | null, startsAt: string, endsAt?: string | null } };

export type ImportedEventsIdsQueryVariables = Exact<{ [key: string]: never; }>;


export type ImportedEventsIdsQuery = { __typename?: 'Query', importedEventsIds: Array<string> };

export type EventProvidersQueryVariables = Exact<{ [key: string]: never; }>;


export type EventProvidersQuery = { __typename?: 'Query', eventProviders: Array<string> };

export type ImportEventMutationVariables = Exact<{
  id: Scalars['String'];
  source: Scalars['String'];
}>;


export type ImportEventMutation = { __typename?: 'Mutation', importEvent: string };

export type MailTemplateQueryVariables = Exact<{ [key: string]: never; }>;


export type MailTemplateQuery = { __typename?: 'Query', mailTemplates: Array<{ __typename?: 'MailTemplateWithUrlAndStatusModel', id: string, name: string, description?: string | null, externalMailTemplateId: string, remoteMissing: boolean, url: string, status: string }>, provider: { __typename?: 'MailProviderModel', name: string } };

export type SynchronizeMailTemplatesMutationVariables = Exact<{ [key: string]: never; }>;


export type SynchronizeMailTemplatesMutation = { __typename?: 'Mutation', syncTemplates?: boolean | null };

export type FullMailTemplateFragment = { __typename?: 'MailTemplateWithUrlAndStatusModel', id: string, name: string, description?: string | null, externalMailTemplateId: string, remoteMissing: boolean, url: string, status: string };

export type FullMailProviderFragment = { __typename?: 'MailProviderModel', name: string };

export type FullPeriodicJobFragment = { __typename?: 'PeriodicJob', id: string, date: string, error?: string | null, executionTime?: string | null, finishedWithError?: string | null, modifiedAt: string, successfullyFinished?: string | null, tries: number, createdAt: string };

export type PeriodicJobLogsQueryVariables = Exact<{
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
}>;


export type PeriodicJobLogsQuery = { __typename?: 'Query', periodicJobLog: Array<{ __typename?: 'PeriodicJob', id: string, date: string, error?: string | null, executionTime?: string | null, finishedWithError?: string | null, modifiedAt: string, successfullyFinished?: string | null, tries: number, createdAt: string }> };

export type FullPollVoteFragment = { __typename?: 'PollVote', id: string, createdAt: string, pollId: string, answerId: string, userId?: string | null, fingerprint?: string | null };

export type FullPollVoteWithAnswerFragment = { __typename?: 'PollVote', id: string, createdAt: string, pollId: string, answerId: string, userId?: string | null, fingerprint?: string | null, answer: { __typename?: 'PollAnswerInVote', id: string, answer: string } };

export type PollVoteListQueryVariables = Exact<{
  filter?: InputMaybe<PollVoteFilter>;
  cursor?: InputMaybe<Scalars['ID']>;
  take?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  order?: InputMaybe<SortOrder>;
  sort?: InputMaybe<PollVoteSort>;
}>;


export type PollVoteListQuery = { __typename?: 'Query', pollVotes: { __typename?: 'PaginatedPollVotes', totalCount: number, nodes: Array<{ __typename?: 'PollVote', id: string, createdAt: string, pollId: string, answerId: string, userId?: string | null, fingerprint?: string | null, answer: { __typename?: 'PollAnswerInVote', id: string, answer: string } }>, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null, hasNextPage: boolean, hasPreviousPage: boolean } } };

export type DeletePollVotesMutationVariables = Exact<{
  ids: Array<Scalars['ID']> | Scalars['ID'];
}>;


export type DeletePollVotesMutation = { __typename?: 'Mutation', deletePollVotes: { __typename?: 'DeletePollVotesResult', count: number } };

export type SettingsListQueryVariables = Exact<{ [key: string]: never; }>;


export type SettingsListQuery = { __typename?: 'Query', settings: Array<{ __typename?: 'Setting', id: string, name: SettingName, value?: any | null, settingRestriction?: { __typename?: 'SettingRestriction', maxValue?: number | null, minValue?: number | null, inputLength?: number | null, allowedValues?: { __typename?: 'AllowedSettingVals', stringChoice?: Array<string> | null, boolChoice?: boolean | null } | null } | null }> };

export type UpdateSettingMutationVariables = Exact<{
  name: SettingName;
  value: Scalars['GraphQLSettingValueType'];
}>;


export type UpdateSettingMutation = { __typename?: 'Mutation', updateSetting: { __typename?: 'Setting', name: SettingName, value?: any | null } };

export type SubscriptionFlowsQueryVariables = Exact<{
  defaultFlowOnly: Scalars['Boolean'];
  memberPlanId?: InputMaybe<Scalars['String']>;
}>;


export type SubscriptionFlowsQuery = { __typename?: 'Query', subscriptionFlows: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type CreateSubscriptionFlowMutationVariables = Exact<{
  memberPlanId: Scalars['String'];
  paymentMethodIds: Array<Scalars['String']> | Scalars['String'];
  periodicities: Array<PaymentPeriodicity> | PaymentPeriodicity;
  autoRenewal: Array<Scalars['Boolean']> | Scalars['Boolean'];
}>;


export type CreateSubscriptionFlowMutation = { __typename?: 'Mutation', createSubscriptionFlow: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type UpdateSubscriptionFlowMutationVariables = Exact<{
  id: Scalars['String'];
  paymentMethodIds: Array<Scalars['String']> | Scalars['String'];
  periodicities: Array<PaymentPeriodicity> | PaymentPeriodicity;
  autoRenewal: Array<Scalars['Boolean']> | Scalars['Boolean'];
}>;


export type UpdateSubscriptionFlowMutation = { __typename?: 'Mutation', updateSubscriptionFlow: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type DeleteSubscriptionFlowMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteSubscriptionFlowMutation = { __typename?: 'Mutation', deleteSubscriptionFlow: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type CreateSubscriptionIntervalMutationVariables = Exact<{
  subscriptionFlowId: Scalars['String'];
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  mailTemplateId?: InputMaybe<Scalars['String']>;
  event: SubscriptionEvent;
}>;


export type CreateSubscriptionIntervalMutation = { __typename?: 'Mutation', createSubscriptionInterval: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type UpdateSubscriptionIntervalMutationVariables = Exact<{
  id: Scalars['String'];
  daysAwayFromEnding?: InputMaybe<Scalars['Int']>;
  mailTemplateId?: InputMaybe<Scalars['String']>;
}>;


export type UpdateSubscriptionIntervalMutation = { __typename?: 'Mutation', updateSubscriptionInterval: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type DeleteSubscriptionIntervalMutationVariables = Exact<{
  id: Scalars['String'];
}>;


export type DeleteSubscriptionIntervalMutation = { __typename?: 'Mutation', deleteSubscriptionInterval: Array<{ __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> }> };

export type ListPaymentMethodsQueryVariables = Exact<{ [key: string]: never; }>;


export type ListPaymentMethodsQuery = { __typename?: 'Query', paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> };

export type SubscriptionFlowFragment = { __typename?: 'SubscriptionFlowModel', id: string, default: boolean, autoRenewal: Array<boolean>, periodicities: Array<PaymentPeriodicity>, numberOfSubscriptions: number, memberPlan?: { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> } | null, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }>, intervals: Array<{ __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> };

export type SubscriptionIntervalFragment = { __typename?: 'SubscriptionInterval', id: string, daysAwayFromEnding?: number | null, event: SubscriptionEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null };

export type MailTemplateRefFragment = { __typename?: 'MailTemplateRef', id: string, name: string };

export type MemberPlanRefFragment = { __typename?: 'MemberPlan', id: string, name: string, amountPerMonthMin: number, currency: Currency, extendable: boolean, slug: string, availablePaymentMethods: Array<{ __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> }> };

export type FullAvailablePaymentMethodFragment = { __typename?: 'AvailablePaymentMethod', paymentPeriodicities: Array<PaymentPeriodicity>, forceAutoRenewal: boolean, paymentMethods: Array<{ __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string }> };

export type FullPaymentMethodFragment = { __typename?: 'PaymentMethod', id: string, paymentProviderID: string, name: string, slug: string, description: string };

export type SystemMailsQueryVariables = Exact<{ [key: string]: never; }>;


export type SystemMailsQuery = { __typename?: 'Query', systemMails: Array<{ __typename?: 'SystemMailModel', event: UserEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> };

export type UpdateSystemMailMutationVariables = Exact<{
  event: UserEvent;
  mailTemplateId: Scalars['String'];
}>;


export type UpdateSystemMailMutation = { __typename?: 'Mutation', updateSystemMail: Array<{ __typename?: 'SystemMailModel', event: UserEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null }> };

export type TestSystemMailMutationVariables = Exact<{
  event: UserEvent;
}>;


export type TestSystemMailMutation = { __typename?: 'Mutation', testSystemMail: boolean };

export type SystemMailFragment = { __typename?: 'SystemMailModel', event: UserEvent, mailTemplate?: { __typename?: 'MailTemplateRef', id: string, name: string } | null };

export type VersionInformationQueryVariables = Exact<{ [key: string]: never; }>;


export type VersionInformationQuery = { __typename?: 'Query', versionInformation: { __typename?: 'VersionInformation', version: string } };

export const PageRefFragmentDoc = gql`
    fragment PageRef on PageModel {
  id
}
    `;
export const ImageUrLsFragmentDoc = gql`
    fragment ImageURLs on Image {
  url
  largeURL: transformURL(input: {width: 500})
  mediumURL: transformURL(input: {width: 300})
  thumbURL: transformURL(input: {width: 280, height: 200})
  squareURL: transformURL(input: {width: 100, height: 100})
  previewURL: transformURL(input: {width: 400, height: 200})
  column1URL: transformURL(input: {width: 800, height: 300})
  column6URL: transformURL(input: {width: 260, height: 300})
}
    `;
export const ImageRefFragmentDoc = gql`
    fragment ImageRef on Image {
  id
  filename
  extension
  title
  description
  width
  height
  ...ImageURLs
}
    ${ImageUrLsFragmentDoc}`;
export const FullBannerActionFragmentDoc = gql`
    fragment FullBannerAction on BannerAction {
  id
  label
  url
  style
  role
}
    `;
export const FullBannerFragmentDoc = gql`
    fragment FullBanner on Banner {
  id
  title
  text
  cta
  active
  showOnArticles
  showOnPages {
    ...PageRef
  }
  image {
    ...ImageRef
  }
  actions {
    ...FullBannerAction
  }
}
    ${PageRefFragmentDoc}
${ImageRefFragmentDoc}
${FullBannerActionFragmentDoc}`;
export const FullBlockStyleFragmentDoc = gql`
    fragment FullBlockStyle on BlockStyle {
  id
  createdAt
  modifiedAt
  name
  blocks
}
    `;
export const FullConsentFragmentDoc = gql`
    fragment FullConsent on Consent {
  id
  name
  slug
  defaultValue
  createdAt
  modifiedAt
}
    `;
export const FullUserConsentFragmentDoc = gql`
    fragment FullUserConsent on UserConsent {
  id
  value
  createdAt
  modifiedAt
  consent {
    ...FullConsent
  }
  user {
    id
    name
    firstName
    email
  }
}
    ${FullConsentFragmentDoc}`;
export const ImportableEventRefFragmentDoc = gql`
    fragment ImportableEventRef on EventFromSource {
  id
  name
  description
  status
  location
  externalSourceId
  externalSourceName
  imageUrl
  startsAt
  endsAt
}
    `;
export const FullMailTemplateFragmentDoc = gql`
    fragment FullMailTemplate on MailTemplateWithUrlAndStatusModel {
  id
  name
  description
  externalMailTemplateId
  remoteMissing
  url
  status
}
    `;
export const FullMailProviderFragmentDoc = gql`
    fragment FullMailProvider on MailProviderModel {
  name
}
    `;
export const FullPeriodicJobFragmentDoc = gql`
    fragment FullPeriodicJob on PeriodicJob {
  id
  date
  error
  executionTime
  finishedWithError
  modifiedAt
  successfullyFinished
  tries
  createdAt
}
    `;
export const FullPollVoteFragmentDoc = gql`
    fragment FullPollVote on PollVote {
  id
  createdAt
  pollId
  answerId
  userId
  fingerprint
}
    `;
export const FullPollVoteWithAnswerFragmentDoc = gql`
    fragment FullPollVoteWithAnswer on PollVote {
  ...FullPollVote
  answer {
    id
    answer
  }
}
    ${FullPollVoteFragmentDoc}`;
export const FullPaymentMethodFragmentDoc = gql`
    fragment FullPaymentMethod on PaymentMethod {
  id
  paymentProviderID
  name
  slug
  description
}
    `;
export const FullAvailablePaymentMethodFragmentDoc = gql`
    fragment FullAvailablePaymentMethod on AvailablePaymentMethod {
  paymentMethods {
    ...FullPaymentMethod
  }
  paymentPeriodicities
  forceAutoRenewal
}
    ${FullPaymentMethodFragmentDoc}`;
export const MemberPlanRefFragmentDoc = gql`
    fragment MemberPlanRef on MemberPlan {
  id
  name
  amountPerMonthMin
  availablePaymentMethods {
    ...FullAvailablePaymentMethod
  }
  currency
  extendable
  slug
}
    ${FullAvailablePaymentMethodFragmentDoc}`;
export const MailTemplateRefFragmentDoc = gql`
    fragment MailTemplateRef on MailTemplateRef {
  id
  name
}
    `;
export const SubscriptionIntervalFragmentDoc = gql`
    fragment SubscriptionInterval on SubscriptionInterval {
  id
  daysAwayFromEnding
  event
  mailTemplate {
    ...MailTemplateRef
  }
}
    ${MailTemplateRefFragmentDoc}`;
export const SubscriptionFlowFragmentDoc = gql`
    fragment SubscriptionFlow on SubscriptionFlowModel {
  id
  default
  memberPlan {
    ...MemberPlanRef
  }
  autoRenewal
  paymentMethods {
    ...FullPaymentMethod
  }
  periodicities
  intervals {
    ...SubscriptionInterval
  }
  numberOfSubscriptions
}
    ${MemberPlanRefFragmentDoc}
${FullPaymentMethodFragmentDoc}
${SubscriptionIntervalFragmentDoc}`;
export const SystemMailFragmentDoc = gql`
    fragment SystemMail on SystemMailModel {
  event
  mailTemplate {
    ...MailTemplateRef
  }
}
    ${MailTemplateRefFragmentDoc}`;
export const BannersDocument = gql`
    query Banners($take: Int!, $skip: Int!) {
  banners(take: $take, skip: $skip) {
    ...FullBanner
  }
}
    ${FullBannerFragmentDoc}`;

/**
 * __useBannersQuery__
 *
 * To run a query within a React component, call `useBannersQuery` and pass it any options that fit your needs.
 * When your component renders, `useBannersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBannersQuery({
 *   variables: {
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useBannersQuery(baseOptions: Apollo.QueryHookOptions<BannersQuery, BannersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BannersQuery, BannersQueryVariables>(BannersDocument, options);
      }
export function useBannersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BannersQuery, BannersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BannersQuery, BannersQueryVariables>(BannersDocument, options);
        }
export type BannersQueryHookResult = ReturnType<typeof useBannersQuery>;
export type BannersLazyQueryHookResult = ReturnType<typeof useBannersLazyQuery>;
export type BannersQueryResult = Apollo.QueryResult<BannersQuery, BannersQueryVariables>;
export const BannerDocument = gql`
    query Banner($id: String!) {
  banner(id: $id) {
    ...FullBanner
  }
}
    ${FullBannerFragmentDoc}`;

/**
 * __useBannerQuery__
 *
 * To run a query within a React component, call `useBannerQuery` and pass it any options that fit your needs.
 * When your component renders, `useBannerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBannerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBannerQuery(baseOptions: Apollo.QueryHookOptions<BannerQuery, BannerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BannerQuery, BannerQueryVariables>(BannerDocument, options);
      }
export function useBannerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BannerQuery, BannerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BannerQuery, BannerQueryVariables>(BannerDocument, options);
        }
export type BannerQueryHookResult = ReturnType<typeof useBannerQuery>;
export type BannerLazyQueryHookResult = ReturnType<typeof useBannerLazyQuery>;
export type BannerQueryResult = Apollo.QueryResult<BannerQuery, BannerQueryVariables>;
export const CreateBannerDocument = gql`
    mutation CreateBanner($input: CreateBannerInput!) {
  createBanner(input: $input) {
    ...FullBanner
  }
}
    ${FullBannerFragmentDoc}`;
export type CreateBannerMutationFn = Apollo.MutationFunction<CreateBannerMutation, CreateBannerMutationVariables>;

/**
 * __useCreateBannerMutation__
 *
 * To run a mutation, you first call `useCreateBannerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBannerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBannerMutation, { data, loading, error }] = useCreateBannerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBannerMutation(baseOptions?: Apollo.MutationHookOptions<CreateBannerMutation, CreateBannerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBannerMutation, CreateBannerMutationVariables>(CreateBannerDocument, options);
      }
export type CreateBannerMutationHookResult = ReturnType<typeof useCreateBannerMutation>;
export type CreateBannerMutationResult = Apollo.MutationResult<CreateBannerMutation>;
export type CreateBannerMutationOptions = Apollo.BaseMutationOptions<CreateBannerMutation, CreateBannerMutationVariables>;
export const UpdateBannerDocument = gql`
    mutation UpdateBanner($input: UpdateBannerInput!) {
  updateBanner(input: $input) {
    ...FullBanner
  }
}
    ${FullBannerFragmentDoc}`;
export type UpdateBannerMutationFn = Apollo.MutationFunction<UpdateBannerMutation, UpdateBannerMutationVariables>;

/**
 * __useUpdateBannerMutation__
 *
 * To run a mutation, you first call `useUpdateBannerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBannerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBannerMutation, { data, loading, error }] = useUpdateBannerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBannerMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBannerMutation, UpdateBannerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBannerMutation, UpdateBannerMutationVariables>(UpdateBannerDocument, options);
      }
export type UpdateBannerMutationHookResult = ReturnType<typeof useUpdateBannerMutation>;
export type UpdateBannerMutationResult = Apollo.MutationResult<UpdateBannerMutation>;
export type UpdateBannerMutationOptions = Apollo.BaseMutationOptions<UpdateBannerMutation, UpdateBannerMutationVariables>;
export const DeleteBannerDocument = gql`
    mutation DeleteBanner($id: String!) {
  deleteBanner(id: $id)
}
    `;
export type DeleteBannerMutationFn = Apollo.MutationFunction<DeleteBannerMutation, DeleteBannerMutationVariables>;

/**
 * __useDeleteBannerMutation__
 *
 * To run a mutation, you first call `useDeleteBannerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBannerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBannerMutation, { data, loading, error }] = useDeleteBannerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBannerMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBannerMutation, DeleteBannerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBannerMutation, DeleteBannerMutationVariables>(DeleteBannerDocument, options);
      }
export type DeleteBannerMutationHookResult = ReturnType<typeof useDeleteBannerMutation>;
export type DeleteBannerMutationResult = Apollo.MutationResult<DeleteBannerMutation>;
export type DeleteBannerMutationOptions = Apollo.BaseMutationOptions<DeleteBannerMutation, DeleteBannerMutationVariables>;
export const BlockStylesDocument = gql`
    query BlockStyles {
  blockStyles {
    ...FullBlockStyle
  }
}
    ${FullBlockStyleFragmentDoc}`;

/**
 * __useBlockStylesQuery__
 *
 * To run a query within a React component, call `useBlockStylesQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlockStylesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlockStylesQuery({
 *   variables: {
 *   },
 * });
 */
export function useBlockStylesQuery(baseOptions?: Apollo.QueryHookOptions<BlockStylesQuery, BlockStylesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BlockStylesQuery, BlockStylesQueryVariables>(BlockStylesDocument, options);
      }
export function useBlockStylesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlockStylesQuery, BlockStylesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BlockStylesQuery, BlockStylesQueryVariables>(BlockStylesDocument, options);
        }
export type BlockStylesQueryHookResult = ReturnType<typeof useBlockStylesQuery>;
export type BlockStylesLazyQueryHookResult = ReturnType<typeof useBlockStylesLazyQuery>;
export type BlockStylesQueryResult = Apollo.QueryResult<BlockStylesQuery, BlockStylesQueryVariables>;
export const CreateBlockStyleDocument = gql`
    mutation CreateBlockStyle($name: String!, $blocks: [BlockType!]!) {
  createBlockStyle(name: $name, blocks: $blocks) {
    ...FullBlockStyle
  }
}
    ${FullBlockStyleFragmentDoc}`;
export type CreateBlockStyleMutationFn = Apollo.MutationFunction<CreateBlockStyleMutation, CreateBlockStyleMutationVariables>;

/**
 * __useCreateBlockStyleMutation__
 *
 * To run a mutation, you first call `useCreateBlockStyleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBlockStyleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBlockStyleMutation, { data, loading, error }] = useCreateBlockStyleMutation({
 *   variables: {
 *      name: // value for 'name'
 *      blocks: // value for 'blocks'
 *   },
 * });
 */
export function useCreateBlockStyleMutation(baseOptions?: Apollo.MutationHookOptions<CreateBlockStyleMutation, CreateBlockStyleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBlockStyleMutation, CreateBlockStyleMutationVariables>(CreateBlockStyleDocument, options);
      }
export type CreateBlockStyleMutationHookResult = ReturnType<typeof useCreateBlockStyleMutation>;
export type CreateBlockStyleMutationResult = Apollo.MutationResult<CreateBlockStyleMutation>;
export type CreateBlockStyleMutationOptions = Apollo.BaseMutationOptions<CreateBlockStyleMutation, CreateBlockStyleMutationVariables>;
export const UpdateBlockStyleDocument = gql`
    mutation UpdateBlockStyle($id: String!, $name: String, $blocks: [BlockType!]!) {
  updateBlockStyle(id: $id, name: $name, blocks: $blocks) {
    ...FullBlockStyle
  }
}
    ${FullBlockStyleFragmentDoc}`;
export type UpdateBlockStyleMutationFn = Apollo.MutationFunction<UpdateBlockStyleMutation, UpdateBlockStyleMutationVariables>;

/**
 * __useUpdateBlockStyleMutation__
 *
 * To run a mutation, you first call `useUpdateBlockStyleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBlockStyleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBlockStyleMutation, { data, loading, error }] = useUpdateBlockStyleMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      blocks: // value for 'blocks'
 *   },
 * });
 */
export function useUpdateBlockStyleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBlockStyleMutation, UpdateBlockStyleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateBlockStyleMutation, UpdateBlockStyleMutationVariables>(UpdateBlockStyleDocument, options);
      }
export type UpdateBlockStyleMutationHookResult = ReturnType<typeof useUpdateBlockStyleMutation>;
export type UpdateBlockStyleMutationResult = Apollo.MutationResult<UpdateBlockStyleMutation>;
export type UpdateBlockStyleMutationOptions = Apollo.BaseMutationOptions<UpdateBlockStyleMutation, UpdateBlockStyleMutationVariables>;
export const DeleteBlockStyleDocument = gql`
    mutation DeleteBlockStyle($id: String!) {
  deleteBlockStyle(id: $id) {
    ...FullBlockStyle
  }
}
    ${FullBlockStyleFragmentDoc}`;
export type DeleteBlockStyleMutationFn = Apollo.MutationFunction<DeleteBlockStyleMutation, DeleteBlockStyleMutationVariables>;

/**
 * __useDeleteBlockStyleMutation__
 *
 * To run a mutation, you first call `useDeleteBlockStyleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBlockStyleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBlockStyleMutation, { data, loading, error }] = useDeleteBlockStyleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBlockStyleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBlockStyleMutation, DeleteBlockStyleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBlockStyleMutation, DeleteBlockStyleMutationVariables>(DeleteBlockStyleDocument, options);
      }
export type DeleteBlockStyleMutationHookResult = ReturnType<typeof useDeleteBlockStyleMutation>;
export type DeleteBlockStyleMutationResult = Apollo.MutationResult<DeleteBlockStyleMutation>;
export type DeleteBlockStyleMutationOptions = Apollo.BaseMutationOptions<DeleteBlockStyleMutation, DeleteBlockStyleMutationVariables>;
export const ConsentsDocument = gql`
    query Consents {
  consents {
    ...FullConsent
  }
}
    ${FullConsentFragmentDoc}`;

/**
 * __useConsentsQuery__
 *
 * To run a query within a React component, call `useConsentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConsentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConsentsQuery({
 *   variables: {
 *   },
 * });
 */
export function useConsentsQuery(baseOptions?: Apollo.QueryHookOptions<ConsentsQuery, ConsentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConsentsQuery, ConsentsQueryVariables>(ConsentsDocument, options);
      }
export function useConsentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConsentsQuery, ConsentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConsentsQuery, ConsentsQueryVariables>(ConsentsDocument, options);
        }
export type ConsentsQueryHookResult = ReturnType<typeof useConsentsQuery>;
export type ConsentsLazyQueryHookResult = ReturnType<typeof useConsentsLazyQuery>;
export type ConsentsQueryResult = Apollo.QueryResult<ConsentsQuery, ConsentsQueryVariables>;
export const ConsentDocument = gql`
    query consent($id: String!) {
  consent(id: $id) {
    ...FullConsent
  }
}
    ${FullConsentFragmentDoc}`;

/**
 * __useConsentQuery__
 *
 * To run a query within a React component, call `useConsentQuery` and pass it any options that fit your needs.
 * When your component renders, `useConsentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConsentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useConsentQuery(baseOptions: Apollo.QueryHookOptions<ConsentQuery, ConsentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConsentQuery, ConsentQueryVariables>(ConsentDocument, options);
      }
export function useConsentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConsentQuery, ConsentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConsentQuery, ConsentQueryVariables>(ConsentDocument, options);
        }
export type ConsentQueryHookResult = ReturnType<typeof useConsentQuery>;
export type ConsentLazyQueryHookResult = ReturnType<typeof useConsentLazyQuery>;
export type ConsentQueryResult = Apollo.QueryResult<ConsentQuery, ConsentQueryVariables>;
export const CreateConsentDocument = gql`
    mutation createConsent($name: String!, $slug: String!, $defaultValue: Boolean!) {
  createConsent(name: $name, slug: $slug, defaultValue: $defaultValue) {
    ...FullConsent
  }
}
    ${FullConsentFragmentDoc}`;
export type CreateConsentMutationFn = Apollo.MutationFunction<CreateConsentMutation, CreateConsentMutationVariables>;

/**
 * __useCreateConsentMutation__
 *
 * To run a mutation, you first call `useCreateConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConsentMutation, { data, loading, error }] = useCreateConsentMutation({
 *   variables: {
 *      name: // value for 'name'
 *      slug: // value for 'slug'
 *      defaultValue: // value for 'defaultValue'
 *   },
 * });
 */
export function useCreateConsentMutation(baseOptions?: Apollo.MutationHookOptions<CreateConsentMutation, CreateConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConsentMutation, CreateConsentMutationVariables>(CreateConsentDocument, options);
      }
export type CreateConsentMutationHookResult = ReturnType<typeof useCreateConsentMutation>;
export type CreateConsentMutationResult = Apollo.MutationResult<CreateConsentMutation>;
export type CreateConsentMutationOptions = Apollo.BaseMutationOptions<CreateConsentMutation, CreateConsentMutationVariables>;
export const UpdateConsentDocument = gql`
    mutation updateConsent($id: String!, $name: String, $slug: String, $defaultValue: Boolean) {
  updateConsent(id: $id, name: $name, slug: $slug, defaultValue: $defaultValue) {
    ...FullConsent
  }
}
    ${FullConsentFragmentDoc}`;
export type UpdateConsentMutationFn = Apollo.MutationFunction<UpdateConsentMutation, UpdateConsentMutationVariables>;

/**
 * __useUpdateConsentMutation__
 *
 * To run a mutation, you first call `useUpdateConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConsentMutation, { data, loading, error }] = useUpdateConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      slug: // value for 'slug'
 *      defaultValue: // value for 'defaultValue'
 *   },
 * });
 */
export function useUpdateConsentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConsentMutation, UpdateConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConsentMutation, UpdateConsentMutationVariables>(UpdateConsentDocument, options);
      }
export type UpdateConsentMutationHookResult = ReturnType<typeof useUpdateConsentMutation>;
export type UpdateConsentMutationResult = Apollo.MutationResult<UpdateConsentMutation>;
export type UpdateConsentMutationOptions = Apollo.BaseMutationOptions<UpdateConsentMutation, UpdateConsentMutationVariables>;
export const DeleteConsentDocument = gql`
    mutation deleteConsent($id: String!) {
  deleteConsent(id: $id) {
    ...FullConsent
  }
}
    ${FullConsentFragmentDoc}`;
export type DeleteConsentMutationFn = Apollo.MutationFunction<DeleteConsentMutation, DeleteConsentMutationVariables>;

/**
 * __useDeleteConsentMutation__
 *
 * To run a mutation, you first call `useDeleteConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteConsentMutation, { data, loading, error }] = useDeleteConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteConsentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteConsentMutation, DeleteConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteConsentMutation, DeleteConsentMutationVariables>(DeleteConsentDocument, options);
      }
export type DeleteConsentMutationHookResult = ReturnType<typeof useDeleteConsentMutation>;
export type DeleteConsentMutationResult = Apollo.MutationResult<DeleteConsentMutation>;
export type DeleteConsentMutationOptions = Apollo.BaseMutationOptions<DeleteConsentMutation, DeleteConsentMutationVariables>;
export const UserConsentsDocument = gql`
    query UserConsents {
  userConsents {
    ...FullUserConsent
  }
}
    ${FullUserConsentFragmentDoc}`;

/**
 * __useUserConsentsQuery__
 *
 * To run a query within a React component, call `useUserConsentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserConsentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserConsentsQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserConsentsQuery(baseOptions?: Apollo.QueryHookOptions<UserConsentsQuery, UserConsentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserConsentsQuery, UserConsentsQueryVariables>(UserConsentsDocument, options);
      }
export function useUserConsentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserConsentsQuery, UserConsentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserConsentsQuery, UserConsentsQueryVariables>(UserConsentsDocument, options);
        }
export type UserConsentsQueryHookResult = ReturnType<typeof useUserConsentsQuery>;
export type UserConsentsLazyQueryHookResult = ReturnType<typeof useUserConsentsLazyQuery>;
export type UserConsentsQueryResult = Apollo.QueryResult<UserConsentsQuery, UserConsentsQueryVariables>;
export const UserConsentDocument = gql`
    query userConsent($id: String!) {
  userConsent(id: $id) {
    ...FullUserConsent
  }
}
    ${FullUserConsentFragmentDoc}`;

/**
 * __useUserConsentQuery__
 *
 * To run a query within a React component, call `useUserConsentQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserConsentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserConsentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserConsentQuery(baseOptions: Apollo.QueryHookOptions<UserConsentQuery, UserConsentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserConsentQuery, UserConsentQueryVariables>(UserConsentDocument, options);
      }
export function useUserConsentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserConsentQuery, UserConsentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserConsentQuery, UserConsentQueryVariables>(UserConsentDocument, options);
        }
export type UserConsentQueryHookResult = ReturnType<typeof useUserConsentQuery>;
export type UserConsentLazyQueryHookResult = ReturnType<typeof useUserConsentLazyQuery>;
export type UserConsentQueryResult = Apollo.QueryResult<UserConsentQuery, UserConsentQueryVariables>;
export const CreateUserConsentDocument = gql`
    mutation createUserConsent($consentId: String!, $userId: String!, $value: Boolean!) {
  createUserConsent(consentId: $consentId, userId: $userId, value: $value) {
    ...FullUserConsent
  }
}
    ${FullUserConsentFragmentDoc}`;
export type CreateUserConsentMutationFn = Apollo.MutationFunction<CreateUserConsentMutation, CreateUserConsentMutationVariables>;

/**
 * __useCreateUserConsentMutation__
 *
 * To run a mutation, you first call `useCreateUserConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUserConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUserConsentMutation, { data, loading, error }] = useCreateUserConsentMutation({
 *   variables: {
 *      consentId: // value for 'consentId'
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useCreateUserConsentMutation(baseOptions?: Apollo.MutationHookOptions<CreateUserConsentMutation, CreateUserConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateUserConsentMutation, CreateUserConsentMutationVariables>(CreateUserConsentDocument, options);
      }
export type CreateUserConsentMutationHookResult = ReturnType<typeof useCreateUserConsentMutation>;
export type CreateUserConsentMutationResult = Apollo.MutationResult<CreateUserConsentMutation>;
export type CreateUserConsentMutationOptions = Apollo.BaseMutationOptions<CreateUserConsentMutation, CreateUserConsentMutationVariables>;
export const UpdateUserConsentDocument = gql`
    mutation updateUserConsent($id: String!, $value: Boolean!) {
  updateUserConsent(id: $id, value: $value) {
    ...FullUserConsent
  }
}
    ${FullUserConsentFragmentDoc}`;
export type UpdateUserConsentMutationFn = Apollo.MutationFunction<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>;

/**
 * __useUpdateUserConsentMutation__
 *
 * To run a mutation, you first call `useUpdateUserConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserConsentMutation, { data, loading, error }] = useUpdateUserConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateUserConsentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>(UpdateUserConsentDocument, options);
      }
export type UpdateUserConsentMutationHookResult = ReturnType<typeof useUpdateUserConsentMutation>;
export type UpdateUserConsentMutationResult = Apollo.MutationResult<UpdateUserConsentMutation>;
export type UpdateUserConsentMutationOptions = Apollo.BaseMutationOptions<UpdateUserConsentMutation, UpdateUserConsentMutationVariables>;
export const DeleteUserConsentDocument = gql`
    mutation deleteUserConsent($id: String!) {
  deleteUserConsent(id: $id) {
    ...FullUserConsent
  }
}
    ${FullUserConsentFragmentDoc}`;
export type DeleteUserConsentMutationFn = Apollo.MutationFunction<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>;

/**
 * __useDeleteUserConsentMutation__
 *
 * To run a mutation, you first call `useDeleteUserConsentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserConsentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserConsentMutation, { data, loading, error }] = useDeleteUserConsentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserConsentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>(DeleteUserConsentDocument, options);
      }
export type DeleteUserConsentMutationHookResult = ReturnType<typeof useDeleteUserConsentMutation>;
export type DeleteUserConsentMutationResult = Apollo.MutationResult<DeleteUserConsentMutation>;
export type DeleteUserConsentMutationOptions = Apollo.BaseMutationOptions<DeleteUserConsentMutation, DeleteUserConsentMutationVariables>;
export const ImportedEventListDocument = gql`
    query ImportedEventList($filter: ImportedEventFilter, $order: Int, $skip: Int, $take: Int, $sort: ImportedEventSort) {
  importedEvents(
    filter: $filter
    order: $order
    skip: $skip
    take: $take
    sort: $sort
  ) {
    nodes {
      ...ImportableEventRef
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${ImportableEventRefFragmentDoc}`;

/**
 * __useImportedEventListQuery__
 *
 * To run a query within a React component, call `useImportedEventListQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedEventListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedEventListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      order: // value for 'order'
 *      skip: // value for 'skip'
 *      take: // value for 'take'
 *      sort: // value for 'sort'
 *   },
 * });
 */
export function useImportedEventListQuery(baseOptions?: Apollo.QueryHookOptions<ImportedEventListQuery, ImportedEventListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedEventListQuery, ImportedEventListQueryVariables>(ImportedEventListDocument, options);
      }
export function useImportedEventListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedEventListQuery, ImportedEventListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedEventListQuery, ImportedEventListQueryVariables>(ImportedEventListDocument, options);
        }
export type ImportedEventListQueryHookResult = ReturnType<typeof useImportedEventListQuery>;
export type ImportedEventListLazyQueryHookResult = ReturnType<typeof useImportedEventListLazyQuery>;
export type ImportedEventListQueryResult = Apollo.QueryResult<ImportedEventListQuery, ImportedEventListQueryVariables>;
export const ImportedEventDocument = gql`
    query ImportedEvent($filter: SingleEventFilter!) {
  importedEvent(filter: $filter) {
    ...ImportableEventRef
  }
}
    ${ImportableEventRefFragmentDoc}`;

/**
 * __useImportedEventQuery__
 *
 * To run a query within a React component, call `useImportedEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedEventQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useImportedEventQuery(baseOptions: Apollo.QueryHookOptions<ImportedEventQuery, ImportedEventQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedEventQuery, ImportedEventQueryVariables>(ImportedEventDocument, options);
      }
export function useImportedEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedEventQuery, ImportedEventQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedEventQuery, ImportedEventQueryVariables>(ImportedEventDocument, options);
        }
export type ImportedEventQueryHookResult = ReturnType<typeof useImportedEventQuery>;
export type ImportedEventLazyQueryHookResult = ReturnType<typeof useImportedEventLazyQuery>;
export type ImportedEventQueryResult = Apollo.QueryResult<ImportedEventQuery, ImportedEventQueryVariables>;
export const ImportedEventsIdsDocument = gql`
    query ImportedEventsIds {
  importedEventsIds
}
    `;

/**
 * __useImportedEventsIdsQuery__
 *
 * To run a query within a React component, call `useImportedEventsIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useImportedEventsIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImportedEventsIdsQuery({
 *   variables: {
 *   },
 * });
 */
export function useImportedEventsIdsQuery(baseOptions?: Apollo.QueryHookOptions<ImportedEventsIdsQuery, ImportedEventsIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImportedEventsIdsQuery, ImportedEventsIdsQueryVariables>(ImportedEventsIdsDocument, options);
      }
export function useImportedEventsIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImportedEventsIdsQuery, ImportedEventsIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImportedEventsIdsQuery, ImportedEventsIdsQueryVariables>(ImportedEventsIdsDocument, options);
        }
export type ImportedEventsIdsQueryHookResult = ReturnType<typeof useImportedEventsIdsQuery>;
export type ImportedEventsIdsLazyQueryHookResult = ReturnType<typeof useImportedEventsIdsLazyQuery>;
export type ImportedEventsIdsQueryResult = Apollo.QueryResult<ImportedEventsIdsQuery, ImportedEventsIdsQueryVariables>;
export const EventProvidersDocument = gql`
    query EventProviders {
  eventProviders
}
    `;

/**
 * __useEventProvidersQuery__
 *
 * To run a query within a React component, call `useEventProvidersQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventProvidersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventProvidersQuery({
 *   variables: {
 *   },
 * });
 */
export function useEventProvidersQuery(baseOptions?: Apollo.QueryHookOptions<EventProvidersQuery, EventProvidersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventProvidersQuery, EventProvidersQueryVariables>(EventProvidersDocument, options);
      }
export function useEventProvidersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventProvidersQuery, EventProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventProvidersQuery, EventProvidersQueryVariables>(EventProvidersDocument, options);
        }
export type EventProvidersQueryHookResult = ReturnType<typeof useEventProvidersQuery>;
export type EventProvidersLazyQueryHookResult = ReturnType<typeof useEventProvidersLazyQuery>;
export type EventProvidersQueryResult = Apollo.QueryResult<EventProvidersQuery, EventProvidersQueryVariables>;
export const ImportEventDocument = gql`
    mutation ImportEvent($id: String!, $source: String!) {
  importEvent(id: $id, source: $source)
}
    `;
export type ImportEventMutationFn = Apollo.MutationFunction<ImportEventMutation, ImportEventMutationVariables>;

/**
 * __useImportEventMutation__
 *
 * To run a mutation, you first call `useImportEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importEventMutation, { data, loading, error }] = useImportEventMutation({
 *   variables: {
 *      id: // value for 'id'
 *      source: // value for 'source'
 *   },
 * });
 */
export function useImportEventMutation(baseOptions?: Apollo.MutationHookOptions<ImportEventMutation, ImportEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportEventMutation, ImportEventMutationVariables>(ImportEventDocument, options);
      }
export type ImportEventMutationHookResult = ReturnType<typeof useImportEventMutation>;
export type ImportEventMutationResult = Apollo.MutationResult<ImportEventMutation>;
export type ImportEventMutationOptions = Apollo.BaseMutationOptions<ImportEventMutation, ImportEventMutationVariables>;
export const MailTemplateDocument = gql`
    query MailTemplate {
  mailTemplates {
    ...FullMailTemplate
  }
  provider {
    ...FullMailProvider
  }
}
    ${FullMailTemplateFragmentDoc}
${FullMailProviderFragmentDoc}`;

/**
 * __useMailTemplateQuery__
 *
 * To run a query within a React component, call `useMailTemplateQuery` and pass it any options that fit your needs.
 * When your component renders, `useMailTemplateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMailTemplateQuery({
 *   variables: {
 *   },
 * });
 */
export function useMailTemplateQuery(baseOptions?: Apollo.QueryHookOptions<MailTemplateQuery, MailTemplateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MailTemplateQuery, MailTemplateQueryVariables>(MailTemplateDocument, options);
      }
export function useMailTemplateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MailTemplateQuery, MailTemplateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MailTemplateQuery, MailTemplateQueryVariables>(MailTemplateDocument, options);
        }
export type MailTemplateQueryHookResult = ReturnType<typeof useMailTemplateQuery>;
export type MailTemplateLazyQueryHookResult = ReturnType<typeof useMailTemplateLazyQuery>;
export type MailTemplateQueryResult = Apollo.QueryResult<MailTemplateQuery, MailTemplateQueryVariables>;
export const SynchronizeMailTemplatesDocument = gql`
    mutation SynchronizeMailTemplates {
  syncTemplates
}
    `;
export type SynchronizeMailTemplatesMutationFn = Apollo.MutationFunction<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>;

/**
 * __useSynchronizeMailTemplatesMutation__
 *
 * To run a mutation, you first call `useSynchronizeMailTemplatesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSynchronizeMailTemplatesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [synchronizeMailTemplatesMutation, { data, loading, error }] = useSynchronizeMailTemplatesMutation({
 *   variables: {
 *   },
 * });
 */
export function useSynchronizeMailTemplatesMutation(baseOptions?: Apollo.MutationHookOptions<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>(SynchronizeMailTemplatesDocument, options);
      }
export type SynchronizeMailTemplatesMutationHookResult = ReturnType<typeof useSynchronizeMailTemplatesMutation>;
export type SynchronizeMailTemplatesMutationResult = Apollo.MutationResult<SynchronizeMailTemplatesMutation>;
export type SynchronizeMailTemplatesMutationOptions = Apollo.BaseMutationOptions<SynchronizeMailTemplatesMutation, SynchronizeMailTemplatesMutationVariables>;
export const PeriodicJobLogsDocument = gql`
    query PeriodicJobLogs($skip: Int, $take: Int) {
  periodicJobLog(skip: $skip, take: $take) {
    ...FullPeriodicJob
  }
}
    ${FullPeriodicJobFragmentDoc}`;

/**
 * __usePeriodicJobLogsQuery__
 *
 * To run a query within a React component, call `usePeriodicJobLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePeriodicJobLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePeriodicJobLogsQuery({
 *   variables: {
 *      skip: // value for 'skip'
 *      take: // value for 'take'
 *   },
 * });
 */
export function usePeriodicJobLogsQuery(baseOptions?: Apollo.QueryHookOptions<PeriodicJobLogsQuery, PeriodicJobLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PeriodicJobLogsQuery, PeriodicJobLogsQueryVariables>(PeriodicJobLogsDocument, options);
      }
export function usePeriodicJobLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PeriodicJobLogsQuery, PeriodicJobLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PeriodicJobLogsQuery, PeriodicJobLogsQueryVariables>(PeriodicJobLogsDocument, options);
        }
export type PeriodicJobLogsQueryHookResult = ReturnType<typeof usePeriodicJobLogsQuery>;
export type PeriodicJobLogsLazyQueryHookResult = ReturnType<typeof usePeriodicJobLogsLazyQuery>;
export type PeriodicJobLogsQueryResult = Apollo.QueryResult<PeriodicJobLogsQuery, PeriodicJobLogsQueryVariables>;
export const PollVoteListDocument = gql`
    query PollVoteList($filter: PollVoteFilter, $cursor: ID, $take: Int, $skip: Int, $order: SortOrder, $sort: PollVoteSort) {
  pollVotes(
    filter: $filter
    cursorId: $cursor
    take: $take
    skip: $skip
    order: $order
    sort: $sort
  ) {
    nodes {
      ...FullPollVoteWithAnswer
    }
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    totalCount
  }
}
    ${FullPollVoteWithAnswerFragmentDoc}`;

/**
 * __usePollVoteListQuery__
 *
 * To run a query within a React component, call `usePollVoteListQuery` and pass it any options that fit your needs.
 * When your component renders, `usePollVoteListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePollVoteListQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      cursor: // value for 'cursor'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *      order: // value for 'order'
 *      sort: // value for 'sort'
 *   },
 * });
 */
export function usePollVoteListQuery(baseOptions?: Apollo.QueryHookOptions<PollVoteListQuery, PollVoteListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PollVoteListQuery, PollVoteListQueryVariables>(PollVoteListDocument, options);
      }
export function usePollVoteListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PollVoteListQuery, PollVoteListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PollVoteListQuery, PollVoteListQueryVariables>(PollVoteListDocument, options);
        }
export type PollVoteListQueryHookResult = ReturnType<typeof usePollVoteListQuery>;
export type PollVoteListLazyQueryHookResult = ReturnType<typeof usePollVoteListLazyQuery>;
export type PollVoteListQueryResult = Apollo.QueryResult<PollVoteListQuery, PollVoteListQueryVariables>;
export const DeletePollVotesDocument = gql`
    mutation DeletePollVotes($ids: [ID!]!) {
  deletePollVotes(ids: $ids) {
    count
  }
}
    `;
export type DeletePollVotesMutationFn = Apollo.MutationFunction<DeletePollVotesMutation, DeletePollVotesMutationVariables>;

/**
 * __useDeletePollVotesMutation__
 *
 * To run a mutation, you first call `useDeletePollVotesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePollVotesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePollVotesMutation, { data, loading, error }] = useDeletePollVotesMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useDeletePollVotesMutation(baseOptions?: Apollo.MutationHookOptions<DeletePollVotesMutation, DeletePollVotesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePollVotesMutation, DeletePollVotesMutationVariables>(DeletePollVotesDocument, options);
      }
export type DeletePollVotesMutationHookResult = ReturnType<typeof useDeletePollVotesMutation>;
export type DeletePollVotesMutationResult = Apollo.MutationResult<DeletePollVotesMutation>;
export type DeletePollVotesMutationOptions = Apollo.BaseMutationOptions<DeletePollVotesMutation, DeletePollVotesMutationVariables>;
export const SettingsListDocument = gql`
    query SettingsList {
  settings {
    id
    name
    value
    settingRestriction {
      maxValue
      minValue
      inputLength
      allowedValues {
        stringChoice
        boolChoice
      }
    }
  }
}
    `;

/**
 * __useSettingsListQuery__
 *
 * To run a query within a React component, call `useSettingsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsListQuery({
 *   variables: {
 *   },
 * });
 */
export function useSettingsListQuery(baseOptions?: Apollo.QueryHookOptions<SettingsListQuery, SettingsListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SettingsListQuery, SettingsListQueryVariables>(SettingsListDocument, options);
      }
export function useSettingsListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SettingsListQuery, SettingsListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SettingsListQuery, SettingsListQueryVariables>(SettingsListDocument, options);
        }
export type SettingsListQueryHookResult = ReturnType<typeof useSettingsListQuery>;
export type SettingsListLazyQueryHookResult = ReturnType<typeof useSettingsListLazyQuery>;
export type SettingsListQueryResult = Apollo.QueryResult<SettingsListQuery, SettingsListQueryVariables>;
export const UpdateSettingDocument = gql`
    mutation UpdateSetting($name: SettingName!, $value: GraphQLSettingValueType!) {
  updateSetting(name: $name, value: $value) {
    name
    value
  }
}
    `;
export type UpdateSettingMutationFn = Apollo.MutationFunction<UpdateSettingMutation, UpdateSettingMutationVariables>;

/**
 * __useUpdateSettingMutation__
 *
 * To run a mutation, you first call `useUpdateSettingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingMutation, { data, loading, error }] = useUpdateSettingMutation({
 *   variables: {
 *      name: // value for 'name'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingMutation, UpdateSettingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingMutation, UpdateSettingMutationVariables>(UpdateSettingDocument, options);
      }
export type UpdateSettingMutationHookResult = ReturnType<typeof useUpdateSettingMutation>;
export type UpdateSettingMutationResult = Apollo.MutationResult<UpdateSettingMutation>;
export type UpdateSettingMutationOptions = Apollo.BaseMutationOptions<UpdateSettingMutation, UpdateSettingMutationVariables>;
export const SubscriptionFlowsDocument = gql`
    query SubscriptionFlows($defaultFlowOnly: Boolean!, $memberPlanId: String) {
  subscriptionFlows(
    defaultFlowOnly: $defaultFlowOnly
    memberPlanId: $memberPlanId
  ) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;

/**
 * __useSubscriptionFlowsQuery__
 *
 * To run a query within a React component, call `useSubscriptionFlowsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscriptionFlowsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscriptionFlowsQuery({
 *   variables: {
 *      defaultFlowOnly: // value for 'defaultFlowOnly'
 *      memberPlanId: // value for 'memberPlanId'
 *   },
 * });
 */
export function useSubscriptionFlowsQuery(baseOptions: Apollo.QueryHookOptions<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>(SubscriptionFlowsDocument, options);
      }
export function useSubscriptionFlowsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>(SubscriptionFlowsDocument, options);
        }
export type SubscriptionFlowsQueryHookResult = ReturnType<typeof useSubscriptionFlowsQuery>;
export type SubscriptionFlowsLazyQueryHookResult = ReturnType<typeof useSubscriptionFlowsLazyQuery>;
export type SubscriptionFlowsQueryResult = Apollo.QueryResult<SubscriptionFlowsQuery, SubscriptionFlowsQueryVariables>;
export const CreateSubscriptionFlowDocument = gql`
    mutation CreateSubscriptionFlow($memberPlanId: String!, $paymentMethodIds: [String!]!, $periodicities: [PaymentPeriodicity!]!, $autoRenewal: [Boolean!]!) {
  createSubscriptionFlow(
    memberPlanId: $memberPlanId
    paymentMethodIds: $paymentMethodIds
    periodicities: $periodicities
    autoRenewal: $autoRenewal
  ) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type CreateSubscriptionFlowMutationFn = Apollo.MutationFunction<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>;

/**
 * __useCreateSubscriptionFlowMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionFlowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionFlowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionFlowMutation, { data, loading, error }] = useCreateSubscriptionFlowMutation({
 *   variables: {
 *      memberPlanId: // value for 'memberPlanId'
 *      paymentMethodIds: // value for 'paymentMethodIds'
 *      periodicities: // value for 'periodicities'
 *      autoRenewal: // value for 'autoRenewal'
 *   },
 * });
 */
export function useCreateSubscriptionFlowMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>(CreateSubscriptionFlowDocument, options);
      }
export type CreateSubscriptionFlowMutationHookResult = ReturnType<typeof useCreateSubscriptionFlowMutation>;
export type CreateSubscriptionFlowMutationResult = Apollo.MutationResult<CreateSubscriptionFlowMutation>;
export type CreateSubscriptionFlowMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionFlowMutation, CreateSubscriptionFlowMutationVariables>;
export const UpdateSubscriptionFlowDocument = gql`
    mutation UpdateSubscriptionFlow($id: String!, $paymentMethodIds: [String!]!, $periodicities: [PaymentPeriodicity!]!, $autoRenewal: [Boolean!]!) {
  updateSubscriptionFlow(
    id: $id
    paymentMethodIds: $paymentMethodIds
    periodicities: $periodicities
    autoRenewal: $autoRenewal
  ) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type UpdateSubscriptionFlowMutationFn = Apollo.MutationFunction<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>;

/**
 * __useUpdateSubscriptionFlowMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionFlowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionFlowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionFlowMutation, { data, loading, error }] = useUpdateSubscriptionFlowMutation({
 *   variables: {
 *      id: // value for 'id'
 *      paymentMethodIds: // value for 'paymentMethodIds'
 *      periodicities: // value for 'periodicities'
 *      autoRenewal: // value for 'autoRenewal'
 *   },
 * });
 */
export function useUpdateSubscriptionFlowMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>(UpdateSubscriptionFlowDocument, options);
      }
export type UpdateSubscriptionFlowMutationHookResult = ReturnType<typeof useUpdateSubscriptionFlowMutation>;
export type UpdateSubscriptionFlowMutationResult = Apollo.MutationResult<UpdateSubscriptionFlowMutation>;
export type UpdateSubscriptionFlowMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionFlowMutation, UpdateSubscriptionFlowMutationVariables>;
export const DeleteSubscriptionFlowDocument = gql`
    mutation DeleteSubscriptionFlow($id: String!) {
  deleteSubscriptionFlow(id: $id) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type DeleteSubscriptionFlowMutationFn = Apollo.MutationFunction<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>;

/**
 * __useDeleteSubscriptionFlowMutation__
 *
 * To run a mutation, you first call `useDeleteSubscriptionFlowMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSubscriptionFlowMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSubscriptionFlowMutation, { data, loading, error }] = useDeleteSubscriptionFlowMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteSubscriptionFlowMutation(baseOptions?: Apollo.MutationHookOptions<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>(DeleteSubscriptionFlowDocument, options);
      }
export type DeleteSubscriptionFlowMutationHookResult = ReturnType<typeof useDeleteSubscriptionFlowMutation>;
export type DeleteSubscriptionFlowMutationResult = Apollo.MutationResult<DeleteSubscriptionFlowMutation>;
export type DeleteSubscriptionFlowMutationOptions = Apollo.BaseMutationOptions<DeleteSubscriptionFlowMutation, DeleteSubscriptionFlowMutationVariables>;
export const CreateSubscriptionIntervalDocument = gql`
    mutation CreateSubscriptionInterval($subscriptionFlowId: String!, $daysAwayFromEnding: Int, $mailTemplateId: String, $event: SubscriptionEvent!) {
  createSubscriptionInterval(
    subscriptionFlowId: $subscriptionFlowId
    daysAwayFromEnding: $daysAwayFromEnding
    mailTemplateId: $mailTemplateId
    event: $event
  ) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type CreateSubscriptionIntervalMutationFn = Apollo.MutationFunction<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>;

/**
 * __useCreateSubscriptionIntervalMutation__
 *
 * To run a mutation, you first call `useCreateSubscriptionIntervalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubscriptionIntervalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubscriptionIntervalMutation, { data, loading, error }] = useCreateSubscriptionIntervalMutation({
 *   variables: {
 *      subscriptionFlowId: // value for 'subscriptionFlowId'
 *      daysAwayFromEnding: // value for 'daysAwayFromEnding'
 *      mailTemplateId: // value for 'mailTemplateId'
 *      event: // value for 'event'
 *   },
 * });
 */
export function useCreateSubscriptionIntervalMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>(CreateSubscriptionIntervalDocument, options);
      }
export type CreateSubscriptionIntervalMutationHookResult = ReturnType<typeof useCreateSubscriptionIntervalMutation>;
export type CreateSubscriptionIntervalMutationResult = Apollo.MutationResult<CreateSubscriptionIntervalMutation>;
export type CreateSubscriptionIntervalMutationOptions = Apollo.BaseMutationOptions<CreateSubscriptionIntervalMutation, CreateSubscriptionIntervalMutationVariables>;
export const UpdateSubscriptionIntervalDocument = gql`
    mutation UpdateSubscriptionInterval($id: String!, $daysAwayFromEnding: Int, $mailTemplateId: String) {
  updateSubscriptionInterval(
    id: $id
    daysAwayFromEnding: $daysAwayFromEnding
    mailTemplateId: $mailTemplateId
  ) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type UpdateSubscriptionIntervalMutationFn = Apollo.MutationFunction<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>;

/**
 * __useUpdateSubscriptionIntervalMutation__
 *
 * To run a mutation, you first call `useUpdateSubscriptionIntervalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubscriptionIntervalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubscriptionIntervalMutation, { data, loading, error }] = useUpdateSubscriptionIntervalMutation({
 *   variables: {
 *      id: // value for 'id'
 *      daysAwayFromEnding: // value for 'daysAwayFromEnding'
 *      mailTemplateId: // value for 'mailTemplateId'
 *   },
 * });
 */
export function useUpdateSubscriptionIntervalMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>(UpdateSubscriptionIntervalDocument, options);
      }
export type UpdateSubscriptionIntervalMutationHookResult = ReturnType<typeof useUpdateSubscriptionIntervalMutation>;
export type UpdateSubscriptionIntervalMutationResult = Apollo.MutationResult<UpdateSubscriptionIntervalMutation>;
export type UpdateSubscriptionIntervalMutationOptions = Apollo.BaseMutationOptions<UpdateSubscriptionIntervalMutation, UpdateSubscriptionIntervalMutationVariables>;
export const DeleteSubscriptionIntervalDocument = gql`
    mutation DeleteSubscriptionInterval($id: String!) {
  deleteSubscriptionInterval(id: $id) {
    ...SubscriptionFlow
  }
}
    ${SubscriptionFlowFragmentDoc}`;
export type DeleteSubscriptionIntervalMutationFn = Apollo.MutationFunction<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>;

/**
 * __useDeleteSubscriptionIntervalMutation__
 *
 * To run a mutation, you first call `useDeleteSubscriptionIntervalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSubscriptionIntervalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSubscriptionIntervalMutation, { data, loading, error }] = useDeleteSubscriptionIntervalMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteSubscriptionIntervalMutation(baseOptions?: Apollo.MutationHookOptions<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>(DeleteSubscriptionIntervalDocument, options);
      }
export type DeleteSubscriptionIntervalMutationHookResult = ReturnType<typeof useDeleteSubscriptionIntervalMutation>;
export type DeleteSubscriptionIntervalMutationResult = Apollo.MutationResult<DeleteSubscriptionIntervalMutation>;
export type DeleteSubscriptionIntervalMutationOptions = Apollo.BaseMutationOptions<DeleteSubscriptionIntervalMutation, DeleteSubscriptionIntervalMutationVariables>;
export const ListPaymentMethodsDocument = gql`
    query ListPaymentMethods {
  paymentMethods {
    ...FullPaymentMethod
  }
}
    ${FullPaymentMethodFragmentDoc}`;

/**
 * __useListPaymentMethodsQuery__
 *
 * To run a query within a React component, call `useListPaymentMethodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListPaymentMethodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListPaymentMethodsQuery({
 *   variables: {
 *   },
 * });
 */
export function useListPaymentMethodsQuery(baseOptions?: Apollo.QueryHookOptions<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>(ListPaymentMethodsDocument, options);
      }
export function useListPaymentMethodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>(ListPaymentMethodsDocument, options);
        }
export type ListPaymentMethodsQueryHookResult = ReturnType<typeof useListPaymentMethodsQuery>;
export type ListPaymentMethodsLazyQueryHookResult = ReturnType<typeof useListPaymentMethodsLazyQuery>;
export type ListPaymentMethodsQueryResult = Apollo.QueryResult<ListPaymentMethodsQuery, ListPaymentMethodsQueryVariables>;
export const SystemMailsDocument = gql`
    query SystemMails {
  systemMails {
    ...SystemMail
  }
}
    ${SystemMailFragmentDoc}`;

/**
 * __useSystemMailsQuery__
 *
 * To run a query within a React component, call `useSystemMailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSystemMailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSystemMailsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSystemMailsQuery(baseOptions?: Apollo.QueryHookOptions<SystemMailsQuery, SystemMailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SystemMailsQuery, SystemMailsQueryVariables>(SystemMailsDocument, options);
      }
export function useSystemMailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SystemMailsQuery, SystemMailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SystemMailsQuery, SystemMailsQueryVariables>(SystemMailsDocument, options);
        }
export type SystemMailsQueryHookResult = ReturnType<typeof useSystemMailsQuery>;
export type SystemMailsLazyQueryHookResult = ReturnType<typeof useSystemMailsLazyQuery>;
export type SystemMailsQueryResult = Apollo.QueryResult<SystemMailsQuery, SystemMailsQueryVariables>;
export const UpdateSystemMailDocument = gql`
    mutation UpdateSystemMail($event: UserEvent!, $mailTemplateId: String!) {
  updateSystemMail(event: $event, mailTemplateId: $mailTemplateId) {
    ...SystemMail
  }
}
    ${SystemMailFragmentDoc}`;
export type UpdateSystemMailMutationFn = Apollo.MutationFunction<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>;

/**
 * __useUpdateSystemMailMutation__
 *
 * To run a mutation, you first call `useUpdateSystemMailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSystemMailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSystemMailMutation, { data, loading, error }] = useUpdateSystemMailMutation({
 *   variables: {
 *      event: // value for 'event'
 *      mailTemplateId: // value for 'mailTemplateId'
 *   },
 * });
 */
export function useUpdateSystemMailMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>(UpdateSystemMailDocument, options);
      }
export type UpdateSystemMailMutationHookResult = ReturnType<typeof useUpdateSystemMailMutation>;
export type UpdateSystemMailMutationResult = Apollo.MutationResult<UpdateSystemMailMutation>;
export type UpdateSystemMailMutationOptions = Apollo.BaseMutationOptions<UpdateSystemMailMutation, UpdateSystemMailMutationVariables>;
export const TestSystemMailDocument = gql`
    mutation TestSystemMail($event: UserEvent!) {
  testSystemMail(event: $event)
}
    `;
export type TestSystemMailMutationFn = Apollo.MutationFunction<TestSystemMailMutation, TestSystemMailMutationVariables>;

/**
 * __useTestSystemMailMutation__
 *
 * To run a mutation, you first call `useTestSystemMailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTestSystemMailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [testSystemMailMutation, { data, loading, error }] = useTestSystemMailMutation({
 *   variables: {
 *      event: // value for 'event'
 *   },
 * });
 */
export function useTestSystemMailMutation(baseOptions?: Apollo.MutationHookOptions<TestSystemMailMutation, TestSystemMailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TestSystemMailMutation, TestSystemMailMutationVariables>(TestSystemMailDocument, options);
      }
export type TestSystemMailMutationHookResult = ReturnType<typeof useTestSystemMailMutation>;
export type TestSystemMailMutationResult = Apollo.MutationResult<TestSystemMailMutation>;
export type TestSystemMailMutationOptions = Apollo.BaseMutationOptions<TestSystemMailMutation, TestSystemMailMutationVariables>;
export const VersionInformationDocument = gql`
    query VersionInformation {
  versionInformation {
    version
  }
}
    `;

/**
 * __useVersionInformationQuery__
 *
 * To run a query within a React component, call `useVersionInformationQuery` and pass it any options that fit your needs.
 * When your component renders, `useVersionInformationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVersionInformationQuery({
 *   variables: {
 *   },
 * });
 */
export function useVersionInformationQuery(baseOptions?: Apollo.QueryHookOptions<VersionInformationQuery, VersionInformationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VersionInformationQuery, VersionInformationQueryVariables>(VersionInformationDocument, options);
      }
export function useVersionInformationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VersionInformationQuery, VersionInformationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VersionInformationQuery, VersionInformationQueryVariables>(VersionInformationDocument, options);
        }
export type VersionInformationQueryHookResult = ReturnType<typeof useVersionInformationQuery>;
export type VersionInformationLazyQueryHookResult = ReturnType<typeof useVersionInformationLazyQuery>;
export type VersionInformationQueryResult = Apollo.QueryResult<VersionInformationQuery, VersionInformationQueryVariables>;